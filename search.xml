<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java补充]]></title>
    <url>%2FJava%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Javase思维导图]]></title>
    <url>%2FJavase%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[A]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaIO流]]></title>
    <url>%2FJavaIO%E6%B5%81%2F</url>
    <content type="text"><![CDATA[I/O流1、File类的使用 java.io.File类：文件或文件夹的抽象表示形式，与平台无关。 File能新建，删除、重命名文件和目录，但不能访问文件本身。如果需要访问文件内容，则需要输入/输出流 File对象可以作为参数传递给IO流的构造器 File对象可以不对应真实存在的文件或文件夹 File的构造器： 构造器 描述 File(String pathname) 根据路径获取File对象 File(String parent, String child) File(File parent, String child) 示例代码： 123456789101112File f1 = new File("hello.txt"); //相对路径，以当前的文件所在的工程为相对路径的起点f1 = new File("E:\\workspace\\java_io\\hello.txt"); //绝对路径System.out.println(f1);//hello.txtSystem.out.println(f1.exists()); //true//构造器2 \表示转义符File f2 = new File("E:\\workspace\\java_io","hello.txt");System.out.println(f2.exists());//true//构造器3File f3 = new File(new File("E:\\workspace\\java_io"),"hello2.txt");System.out.println(f3.exists()); //false 常用方法： 123456789101112File f1 = new File("hello.txt");File f2 = new File("java\\javaee\\hello.txt");System.out.println(f1.getAbsolutePath()); //获取完整的路径System.out.println(f1.getPath()); //相对路径System.out.println(f1.getParent()); //上级路径System.out.println(f1.length()); //文件的字节数System.out.println(new Date(f1.lastModified())); //修改时间System.out.println("---------------");System.out.println(f2.getAbsolutePath());System.out.println(f2.getPath());System.out.println(f2.getParent());System.out.println(f2.length()); 常用方法2： 123456789101112131415File f = new File("E:\\workspace");String[] list = f.list(); //遍历当前目录下的所有文件和文件夹for (int i = 0; i &lt; list.length; i++) &#123; String fileName = list[i]; System.out.println(fileName);&#125;System.out.println("-------------");File[] listFiles = f.listFiles();for (int i = 0; i &lt; listFiles.length; i++) &#123; File file = listFiles[i]; System.out.println(file);&#125; 2、IO流的原理和使用 I/O是Input/Output的缩写，用于处理设备之间的数据传输，如：读/写文件, 网络通信。 java.io包下提供了各种“流”类和接口 输入(input)：读取外部数据（硬盘、网络等外部存储设备）到程序（内存）中（读） 输出（output）：将程序（内存）数据输出到外部存储设备（硬盘、网络等）中（写） 2.1、流的分类 我们对IO流一般会从3个维度进行描述 根据流的方向：输出、输出 根据流的大小：字节、字符 根据流的角色：（功能越来越强大） 节点（文件流）， 处理流 四个抽象基类 字节流 字符流 输入流 InputStream Read 输出流 OutputStream Writer 流的体系： 这些所有的流都是这4个基类的实现类 3、节点流 文件流 缓冲流(处理流的一种) FileInputStream BufferedInputStream FileOutputStream BufferedOutputStream FileReader BufferedReader FileWriter BufferedWriter 字符流读文件： 示例代码：（） 123456789101112131415161718192021222324252627282930313233343536 FileReader reader = null; try &#123; // 1.创建File类对象，指向操作的文件 File file = new File("hello.txt"); // 2.创建具体的流,读文本（字符流，输入） reader = new FileReader(file); // 3.读数据 read() : 返回读入的一个字符, 返回-1读取完毕// int data = reader.read();// while (data != -1) &#123;// System.out.println((char) data);// data = reader.read();// &#125; //方式二: int data; while( (data = reader.read()) != -1)&#123; System.out.println((char)(data)); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 不能自动回收gc try &#123; if (reader != null) &#123; reader.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 示例代码： 1234567891011121314151617181920212223242526272829 FileReader r = null; try &#123; // 1.創建File对象 File file = new File("hello.txt"); // 2.创建流 r = new FileReader(file); // 3.读数据 char[] cs = new char[3]; //缓存的大小 int len; //读取的字符数 while ((len = r.read(cs)) != -1) &#123; //错误方式// for (int i = 0; i &lt; cs.length; i++) &#123;// System.out.print(cs[i] + " ");// &#125; //正确方式一// for (int i = 0; i &lt; len; i++) &#123;// System.out.print(cs[i] + " ");// &#125; //正确方式二 String str = new String(cs, 0, len); System.out.println(str); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125;finally &#123; r.close(); &#125; 总结： read（）理解：返回读入的一个字符，如果达到末尾，返回-1 读取的文件一定要存在，否则报异常FileNotFoundException 为了保证资源合理利用，必须使用try-catch-finally关闭资源 字符流的写： 示例代码： 123456789//1.创建File对象 File file = new File("hello2.txt"); //文本可以不存在 //2.获取字符输出流 默认false：覆盖 ， true：追加 FileWriter writer = new FileWriter(file); //3.写 writer.write("红红的太阳，蓝蓝的天"); writer.write("admin"); //4.关 writer.close(); 123456789101112131415161718192021222324252627//创建File File srcFile = new File("hello.txt"); File destFile = new File("hello3.txt"); //字符流不能读取和写入图片 --- 非文本数据 //File srcFile = new File("123.jpg"); //File destFile = new File("456.jpg"); //创建流 FileReader re = new FileReader(srcFile); FileWriter wr = new FileWriter(destFile); //数据读写操作 char[] cbuf = new char[5]; int len; //记录每次读取的字符个数 while((len = re.read(cbuf)) != -1)&#123; //读取的数据临时保存到cbuf缓存中 //写 --- 每次写len个字符 wr.write(cbuf, 0, len); &#125; //关闭资源 if(wr != null)&#123; wr.close(); &#125; if(re != null)&#123; re.close(); &#125; 总结： 输出操作，对应的File可以不存在，不会报错，会自动生成对应的文件 FileWriter(file ，false) ： 对原有文件进行覆盖（默认） FileWriter(file ，true)：对原有文件进行追加 字节流读文件 示例代码：（字符流读取信息） 1234567891011121314//1造文件 File f = new File("hello.txt"); //2造流 FileInputStream input = new FileInputStream(f); //3读文件 byte[] bs = new byte[3]; //缓存字节数 int len; //返回读取得字节总数，读取的数据放入bs缓存中 while((len = input.read(bs)) != -1)&#123; //中文显示默认2个字节保存 String str = new String(bs, 0, len); //将字节组装为string System.out.println(str); &#125; //关闭资源 input.close(); 示例代码：（复制图片） 12345678910111213141516//1.创建File File srcFile = new File("123.jpg"); File destFile = new File("456.png"); //2.创流 FileInputStream inputStream = new FileInputStream(srcFile); FileOutputStream outputStream = new FileOutputStream(destFile); //3读写 byte[] buffer = new byte[1024]; int len; while((len = inputStream.read(buffer)) != -1)&#123; //写 outputStream.write(buffer, 0, len); &#125; //4.关 inputStream.close(); outputStream.close(); 总结： 文本文件（.txt, java,c.cpp等），使用字符流处理 非文本文件：使用字节流处理 （图片，视频...） 4、缓存流 为了提高数据的读取效率，javaAPI提供了带缓冲功能的流，在使用这些流类时，会创建一个内部缓冲区数组，缺省使用8192个字符（8kb）缓存区 示例代码： 12345678910111213141516171819//1.创建File类// File f = new File("123.jpg");// File f2 = new File("789.jpg");// //2.造流// FileInputStream input = new FileInputStream(f);// FileOutputStream out = new FileOutputStream(f2); //3.包装 --- 可以嵌套 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(new File("123.jpg"))); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(new File("789.jpg"))); //4.操作 --- 读写 byte[] buffer = new byte[10]; int len; while(( len = bis.read(buffer)) != -1)&#123; bos.write(buffer, 0, len); &#125; //5关 --- 先关外部的包装类, 内部的也会关联关闭 bis.close(); bos.close(); 5、 转换流 转换流提供了在字节流和字符流之间的转换 很多时候我们使用转换流来处理文件乱码问题，实现编码和解码的功能 如果字节流中的数据都是字符类型时，转成字符流效率更高 名称 作用 方向 InputStreamReader 将InputStream转换为Reader 字节 ---》字符 OutputStreamWriter 将Writer转换为OutputStream 字符---》字节 示例代码： 1234567891011121314//1、创建输入流 FileInputStream inputStream = new FileInputStream("db.txt"); //2、转换 字节流转换为字符流 InputStreamReader reader = new InputStreamReader(inputStream); //使用系统默认编码格式 reader = new InputStreamReader(inputStream, "UTF-8"); //3、读取操作 char[] buffer = new char[3]; int len; while((len = reader.read(buffer)) != -1)&#123; String str = new String(buffer, 0, len); System.out.println(str); &#125; //4关闭资源 reader.close(); //内层关联关闭 示例代码： 123456789101112131415//1创建流 FileInputStream input = new FileInputStream("db.txt"); FileOutputStream out = new FileOutputStream("db_2.txt"); //2转换流 InputStreamReader reader = new InputStreamReader(input); OutputStreamWriter writer = new OutputStreamWriter(out); //3读写 char[] buffer = new char[10]; int len; while((len = reader.read(buffer)) != -1)&#123; writer.write(buffer, 0, len); &#125; //4.关闭 reader.close(); writer.close(); 总结： 解码：字节/字节数组 ---》 字符数组/字符串 编码：字符数组/字符串 ---》字节、字节数组 6. 对象序列化 序列化：用ObjectOutputStream类保存基本类型数据或对象。 反序列化：使用ObjectInputStream类读取基本类型数据或对象 不能序列化static和transient修饰的成员变量 对象序列化机制允许把内存中的对象转换成与平台无关的二进制流。从而把这种二进制数据保存在硬盘中。获取通过网络将这种二进制数据传输到另一个网络节点。当程序获取到这种二进制流，就可以恢复成原来java对象。 对象序列化需要实现Serializable接口 序列化的步骤： 创建ObjectOutputStream 调用ObjectOutputStream的writerObjet（）方法可输出序列化对象 操作flush 反序列化步骤： 创建ObjectInputStream 调用ObjectInputStrea的Readobject()方法读取流中的对象 示例代码： 12345678910111213141516171819202122232425262728293031class Person implements Serializable&#123; private static final long serialVersionUID = 1L; private String name; private int age; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + "]"; &#125; &#125; 1234567//创建处理流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("object.dat")); //序列化 //oos.writeObject(new String("测试信息")); // oos.writeObject(new Person("admin",20)); oos.flush(); 123456//创建处理流ObjectInputStream ois = new ObjectInputStream(new FileInputStream("object.dat"));//反序列化Person p = (Person) ois.readObject();System.out.println(p);]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java异常]]></title>
    <url>%2FJava%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[异常为什么高级语言会出现异常： 12- 因为程序出错是不可避免的，所以为了提高程序的健壮性，所以所有的高级语言都添加了异常的处理方式，被称为异常处理机制- 注意开发过程中的逻辑错误和语法错误不是异常 1、异常概述java把异常分为两大类： Error ： jvm无法处理和解决的严重问题。（类似重大交通事故） Exception：可以处理 java.lang.Error 实例代码： 12345//java.lang.StackOverflowError : 栈溢出test();//java.lang.OutOfMemoryError: 内存溢出Integer[] arr = new Integer[1024 * 1024 * 1024]; java.lang.Exception 偶然出现的编程错误导致的一般性问题，可以使用异常机制进行处理，目的是让程序能够处理“错误”，提高程序的健壮性，看起来比较智能。 处理方式： 11. 遇到错误终止程序 处理错误，给出提示，继续运行 捕捉错误的时机： 12- 编译时期：编译时出现的错误，需要事先强制处理错误（checked）- 运行时期：运行时出现的错误（unchecked） 异常体系 java.lang.Throwable java.lang.Error：不做处理 java.lang.Exception：处理 2、常见的异常类型面试常问：需要记住 编译时期异常：（checked） IOException FileNotFoundException ClassNotFoundException 运行时期异常：（unchecked，java.lang.RuntimeException） NullPointException ArrayIndexOutOfBoundsException ClassCastException NumberFormatException InputMismatchException ArithmeticException 示例代码： 123456789101112131415161718192021222324 // //java.lang.NullPointerException// String str = null;// System.out.println(str.length());// // //ArrayIndexOutOfBoundsException// String[] arr = new String[4];// System.out.println(arr[5]); //ClassCastException// Object obj = new Date();// String str2 = (String)obj; //NumberFormatException // int num = Integer.parseInt("abc"); //InputMismatchException// Scanner input = new Scanner(System.in);// System.out.println("请输入一个数");// int res = input.nextInt();// input.close(); //ArithmeticException int res = 10 / 0; 3、处理异常3.1、异常处理模型：抓抛模型 抓取：进行异常处理 方式一：try-catch-finally 方式二：throws + 异常类型 抛出：程序在运行的过程中一但出现异常，就会在异常出现的地方生成异常对象，并将此抛出，其后代码不在运行。 3.2 、处理方式方式一： try-catch-finally（自己处理） 语法结构： try { ​ //可能出现异常的代码 } catch(异常类型 变量名称) { ​ //处理异常代码 } catch（异常类型 变量名称） { ​ //处理异常代码 } ... { }finally { //可选择 //一定执行的代码 } 示例代码： 12345678910111213141516171819202122String str = "123";str = "abc";try &#123; int num = Integer.parseInt(str); //没有机会执行 Object obj = new Date(); String str2 = (String)obj; System.out.println("num = " + num);&#125;catch(NullPointerException e)&#123; System.out.println("NullPointerException --- ");&#125;catch(NumberFormatException e) &#123; //System.out.println(e.getMessage()); //异常对象信息// e.printStackTrace(); //异常堆栈信息 System.out.println("NumberFormatException----");&#125;catch(Exception e)&#123; System.out.println("Exception --- ");&#125;System.out.println("执行 ---------- "); 说明： 12345- try将可能出现的异常代码包含起来，一但代码出现异常将会在出现异常的地方生成异常对象并抛给系统，之后跳转到catch区域- catch则可以根据是否匹配（对应的类型或子类）捕捉到异常对象，再进行异常代码的处理- 处理完异常代码逻辑跳出try-catch块执行剩余的代码，（可能不会执行所有的catch块）- 在try-catch声明的变量不能跳出该结构被找到，所以有时候需要在try-catch块之外- try-catch将编译时出现的异常推迟到运行时异常处理，但仍然可能出错，所以在开发中运行时异常我们一般不做处理。 演示代码：（finally） 1234567891011try &#123; int num1 = 10; int num2 = 0; int res = num1 / num2; &#125;catch(ArithmeticException e)&#123; System.out.println(e.getMessage()); //继续抛出异常 System.out.println(Integer.parseInt("abc")); &#125;finally &#123; System.out.println("一定会执行 --- "); &#125; 演示代码：（return执行） 1234567891011121314151617@Test public void test4()&#123; System.out.println(method()); &#125; //演示return也执行 public int method()&#123; try &#123; int[] nums = new int[2]; System.out.println(nums[3]); return 0; &#125;catch(IndexOutOfBoundsException e)&#123; e.printStackTrace(); return 1; //执行在finally之后 &#125;finally&#123; System.out.println("一定会执行 --- "); &#125; &#125; 演示代码：（资源释放） 123456789101112131415161718192021222324252627FileInputStream input = null;try &#123; //File类代表一个文件/文件夹 File file = new File("hello.txt"); //创建流，建立“管道”，将文本读取到内存 input = new FileInputStream(file); //读取hello.txt文件信息 int data = input.read(); while(data != -1)&#123; //判断文件内容是否存在 System.out.print((char)data); data = input.read(); &#125;&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125;finally &#123; //关闭资源 if(input != null)&#123; try &#123; input.close();//关闭资源 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 说明： finally声明的语句一定会被执行，即使catch中出现异常，或try-catch中有return语句也会被执行 通常jvm不能够及时回收的资源可放入finally语句中，比如：数据库连接，输入输出流等资源的释放 方式二：throws + 异常类型 （别的方法处理） 123456789101112131415161718192021222324252627public void test6() &#123; try &#123; method2(); //调用者处理异常 &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //声明抛出异常，谁调用谁处理 public void method2() throws IOException &#123; FileInputStream input = null; try &#123; // File类代表一个文件/文件夹 File file = new File("hello.txt"); // 创建流，建立“管道”，将文本读取到内存 input = new FileInputStream(file); // 读取hello.txt文件信息 int data = input.read(); while (data != -1) &#123; // 判断文件内容是否存在 System.out.print((char) data); data = input.read(); &#125; &#125; finally &#123; input.close();// 关闭资源 &#125; &#125; 说明： 写方法声明时可以说明此方法执行时会被抛出的异常 此方法没有真正处理异常，只给抛出调用者来处理 3.3. 开发中选择try-catch或throws注意事项12345678910111213141516171819202122232425public class OverrideTest &#123; public void display(SuperClass sup)&#123; try &#123; sup.method(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class SuperClass &#123; public void method() throws IOException &#123; &#125;&#125;class subClass extends SuperClass &#123; public void method() throws FileNotFoundException &#123; &#125;&#125; 说明： 如果父类中被重写的方法没有throws异常，则子类重写的方法也不能抛出异常，子类只能try-catch处理 子类重写的方法抛出的异常必须是父类的同类型或子类类型 4、 手动生成异常（throw）示例代码： 1234567891011121314151617181920212223242526public class StudentTest &#123; public static void main(String[] args) &#123; Student stu = new Student(); try &#123; stu.regist(-100); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Student&#123; private int id; public void regist(int id) throws Exception&#123; if(id &gt; 0)&#123; this.id = id; &#125;else &#123; //System.out.println("输出数据有误"); //手动抛出异常 throw new Exception("输出数据有误"); &#125; &#125;&#125; 5、 自定义异常示例代码： 12345678910111213public class MyException extends Exception &#123; private static final long serialVersionUID = 1L; public MyException() &#123; super(); &#125; public MyException(String message) &#123; super(message); &#125;&#125; 用户自定义异常类都是RuntimeException的子类 自定义异常类通常需要编写几个重载的构造器 自定义异常类需要提供serialVersionUID 自定义的异常通过throw抛出 总结：]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合]]></title>
    <url>%2FJava%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[集合1、集合框架概述 java中为了对多个对象进行操作，就需要对多个对象进行存储，针对Array的弊端，Java集合就创建一个“容器”，可以动态的把多个对象的引用放入容器中。 java集合类就是对多个对象进行存储的操作类，存储的类型可以是单个对象，也可以是关联对象。 注意Java集合中存储的对象在内存中，如果存储在硬盘中的叫做“持久化操作” Java集合分为两种不同的体系： Collection：单值接口操作 List：接口：元素有序，可重复 ---“动态”数组 ArrayList、LinkedList、Vector Set：接口：元素无序，不可重复 --- “高中集合” HashSet、LinkedHashSet、TreeSet Map：键值操作接口、有key---value组成 --- “高中函数y = f（x）” HashMap、LinkedHashMap、TreeMap、Hashtable、Properties 2、Collection接口 Collection接口不提供任何实现类，而是提供更加具体的子接口 在JDK5之前，集合会丢失容器中所放入的对象的类型，会把所有放入的对象都当成Object类型处理，从1.5之后增加了泛型，则Java集合可以记住容器中的对象的数据类型。 2.1、collection接口体系： 2.2、常用方法：（API）演示代码：（） 1234567891011121314151617181920212223242526272829//通过ArrayList创建对象Collection coll = new ArrayList();//add(E e) //Object e：添加元素coll.add("AA");coll.add("BB");coll.add(123); //自动装箱coll.add(new Date());//size() ：获取集合中元素的个数System.out.println(coll);System.out.println("集合中元素个数： " + coll.size()); //4//将coll2中的所有元素添加到指定集合中//addAll(Collection&lt;? extends E&gt; c)Collection coll2 = new ArrayList();coll2.add(456);coll2.add("cc");coll.addAll(coll2);System.out.println(coll);System.out.println("集合中元素个数： " + coll.size()); //6// clear() ： 清空集合中的元素coll.clear();System.out.println(coll);System.out.println("集合中元素个数： " + coll.size()); //0//isEmpty():判断当前集合是否为空System.out.println(coll.isEmpty()); 实例代码：（contains(Object o)、containsAll(Collection&lt;?&gt; c)） 1234567891011121314151617181920212223Collection coll = new ArrayList();coll.add(123);coll.add(456);coll.add(new String("Tom"));coll.add(false);Person p = new Person("小王", 20);coll.add(p);// 1、contains(Object o) : 判断当前集合中是否包含指定的元素,判断对象相等会调用对象所在类的equals()方法// boolean contains = coll.contains(123);// System.out.println(contains);// boolean contains2 = coll.contains(new String("Tom"));// 添加p對// System.out.println(contains2); // true// boolean contains3 = coll.contains(p);// System.out.println(contains3); // trueboolean contains4 = coll.contains(new Person("小王", 20));System.out.println(contains4); // false: 调用的是父类（object的equals方法使用是==比较） // true : 重写父类的equals方法：属性相同就相同//2、containsAll(Collection&lt;?&gt; c) :判断coll2集合中的所有元素是否在某个集合中存在Collection coll2 = Arrays.asList(123,456);System.out.println(coll.containsAll(coll2)); 在Collection接口中的添加object类型的对象时，要求所在的类重写equals方法 集合在判断相同元素时会调用所在类的equals方法判断是否相同 示例代码：(remove(Object o),removeAll(Collection&lt;?&gt; c)) 12345678910111213141516171819Collection coll = new ArrayList();coll.add(123);coll.add(456);coll.add(new String("Tom"));coll.add(false);Person p = new Person("小王", 20);coll.add(p);coll.remove(123);System.out.println(coll);//remove(Object o)coll.remove(new Person("小王", 20));System.out.println(coll);//removeAll(Collection&lt;?&gt; c)Collection coll2 = Arrays.asList(123,456);coll.removeAll(coll2);System.out.println(coll); 示例代码：(equals(Object o),)retainAll(Collection&lt;?&gt; c) 12345678910111213141516171819202122232425Collection coll = new ArrayList();coll.add(123);coll.add(456);coll.add(new String("Tom"));coll.add(false);Person p = new Person("小王", 20);coll.add(p);// System.out.println(coll);// //retainAll(Collection&lt;?&gt; c):获取交集// Collection coll2 = Arrays.asList(123,456);// coll.retainAll(coll2);// System.out.println(coll);//equals(Object o)Collection coll2 = new ArrayList();coll2.add(123);coll2.add(456);coll2.add(new String("Tom"));coll2.add(false);Person p2 = new Person("小王", 20);coll2.add(p2);//传递的集合和本身的集合要完全相同，返回tureboolean res = coll.equals(coll2); //判断集合中的元素是否完全相同System.out.println(res); 示例代码： 1234567891011121314151617181920212223Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new String("Tom")); coll.add(false); Person p = new Person("小王", 20); coll.add(p); //hashCode()：返回当前对象的哈希值 System.out.println(coll.hashCode()); //? //集合 ---&gt; 数组 Object[] objs = coll.toArray(); for (int i = 0; i &lt; objs.length; i++) &#123; System.out.println(objs[i]); &#125; //扩展: 数组 ---&gt;集合 List&lt;String&gt; list = Arrays.asList(new String[]&#123;"a","b","c"&#125;); System.out.println(list); // size() System.out.println(coll.size()); 3、Iterator迭代器接口 Iterator对象称为迭代器（设计模式），主要用于遍历Collection集合中的元素 迭代器模式是为容器而生。 Collection接口继承了java.lang.Iterable接口 Iterator仅用于遍历集合，本身不提供承装对象的能力，如果需要创建Iterator对象，则必须有需要迭代的集合 集合对象每次调用iterator（）方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前 迭代器执行原理: 示例代码：(使用迭代器变量元素) 1234567891011121314151617181920212223Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new String("Tom")); coll.add(new String("Jac")); coll.add(false); //获取迭代器对象 Iterator iterator = coll.iterator(); //方式一： System.out.println(iterator.next()); System.out.println(iterator.next()); System.out.println(iterator.next()); System.out.println(iterator.next()); System.out.println(iterator.next()); System.out.println(iterator.next()); //没有元素抛出NoSuchElementException //方式二： //iterator.hasNext() ：判断是否有下一个元素 while(iterator.hasNext())&#123; //next：1、将指针下移，2、将下移后当前位置中的元素返回 System.out.println(iterator.next()); &#125; 示例代码：（深刻理解迭代器） 1234567891011121314151617Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new String("Tom")); coll.add(new String("Jack")); coll.add(false); //错误的方式// Iterator iterator = coll.iterator();// while(iterator.next() != null)&#123; //每次next都有移动指针// System.out.println(iterator.next());// &#125; //错误方式 ：每次iterator都会获取新的迭代器 while(coll.iterator().hasNext())&#123; System.out.println(coll.iterator().next()); &#125; 示例代码：（iterator中的remove） 123456789101112131415161718Collection coll = new ArrayList();coll.add(123);coll.add(456);coll.add(new String("Tom"));coll.add(new String("Jack"));coll.add(false);//删除TomIterator iterator = coll.iterator();while(iterator.hasNext())&#123; //iterator.remove(); //报错：IllegalStateException Object object = iterator.next(); if("Tom".equals(object))&#123; iterator.remove(); //iterator.remove();报错 &#125;&#125;System.out.println(coll); Iterator可以删除集合中的元素，但是在遍历过程中通过迭代器对象的remove()方法不是集合中的remove方法 如果还未调用next（）方法或多次调用remove方法都会报错 使用foreach循环遍历集合元素 jdk1.5之后提供了foreach循环迭代访问Collection和数组 foreach底层使用的迭代器方式 示例代码： 123456789101112131415161718192021Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new String("Tom")); coll.add(new String("Jack")); coll.add(false); //for(数据类型 变量：数组/集合) for(Object obj : coll)&#123; System.out.println(obj); &#125; int[] arr = new int[]&#123;1,2,3,4,5&#125;; //方式一： for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; //方式二：增强for循环 for(int i : arr)&#123; System.out.println(i); &#125; 思考题： 1234567891011121314String[] arr = new String[] &#123; "mm", "mm", "mm" &#125;;// 方式一：// for (int i = 0; i &lt; arr.length; i++) &#123;// arr[i] = "GG";// &#125;// 方式二：for (String str : arr) &#123; str = "GG"; //&#125;for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]);&#125; 4、List接口4.1、List概述 List集合有序，可重复。可看成“动态”数组，代替原来的数组 核心实现类： ArrayList、 LinkedList Vector 核心实现类特点：（面试内容） ArrayList：作为List接口的主要实现类、线程不安全、效率高。底层使用Object[]数组实现存储 LinkedList：底层使用双向链表存储数据，如果频繁添加，删除，插入元素则效率较高 Vector：古老的实现类、甚至出现在List接口之前，线程安全。效率低。底层使用Object[]数组实现存储 4.2、源码分析ArrayList源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/*** Constructs an empty list with an initial capacity of ten.默认构造器器*/public ArrayList() &#123;this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;//内部默认创建object[]数组保存数据/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */transient Object[] elementData; // non-private to simplify nested class access//jdk1.8初始状态创建了空&#123;&#125;数组/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;//向集合中添加元素/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; //添加调用的方法 ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; //参数 1 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); //获取10 &#125; //调用扩容方法 ensureExplicitCapacity(minCapacity);&#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) //扩容方法 grow(minCapacity); &#125;//扩容的执行算法/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; ArrayList底层使用Object[]数组来存储数据， add()添加元素、底层才初始数组长度，初始化数组的长度为10 每次扩充容量为1.5倍 LinkedList源码： 1234567891011121314151617181920212223242526272829303132333435363738394041 /** * Pointer to first node. * Invariant: (first == null &amp;&amp; last == null) || * (first.prev == null &amp;&amp; first.item != null) */ transient Node&lt;E&gt; first; //第一个节点 /** * Pointer to last node. * Invariant: (first == null &amp;&amp; last == null) || * (last.next == null &amp;&amp; last.item != null) */ transient Node&lt;E&gt; last; //最后一个节点 private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; //下一个节点 Node&lt;E&gt; prev; //上一个节点 //element：内容 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125;//添加元素的算法/** * Links e as last element. */ void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; &#125; LinkedList创建对象时，内部声明了Node类型的fist属性和last属性，默认为null add（）添加，将内容添加到新建的node节点中，再讲新建的node和原来的建立关联 其中node创建方式体现了双向链表的结构 Vector分析： 创建Vector对象时，底层都使用了长度为10的数组，再扩容方式上和List一样，，默认每次扩容2倍 面试题： ArrayList、LinkedList、Vector的异同，谈谈你的理解 4.3、常用方法(collection之外的方法)示例代码： 1234567891011121314151617//ArrayList list = new ArrayList();list.add(123);list.add(456);list.add("abc");list.add(123);System.out.println(list);//在指定位置添加元素list.add(1, "bbb");System.out.println(list);//获取指定位置的元素Object obj = list.get(5); //不能超出下标最大值System.out.println(obj); 示例代码： 12345678910111213141516171819202122232425262728293031323334 ArrayList list = new ArrayList(); list.add(123); list.add(456); list.add("abc"); list.add(123); list.add(new Person("admin", 20)); // //获取集合中首次出现的元素的位置// int i = list.indexOf(123);// System.out.println(i);// //获取集合中最后一次出现的元素的位置// int lastIndexOf = list.lastIndexOf(123);// System.out.println(lastIndexOf);// // //返回删除的对象// Object remove = list.remove(3);// System.out.println(remove);// // boolean remove2 = list.remove("abc");// System.out.println(remove2);// System.out.println(list);// // boolean remove3 = list.remove(new Person("admin", 20));// System.out.println(remove3);// System.out.println(list); //修改的效果 list.set(1, "cc"); System.out.println(list); //获取指定区间的元素[ ) List subList = list.subList(2, 4); System.out.println(subList); System.out.println(list); 总结： 增加：add(object obj)、 删：remove(int index)、remove(Object obj) 改：set（int index, object obj） 查：get(int index) 插入：add(int index, Object obj) 长度：size() 遍历： Iterator：迭代器 增强for循环 普通for 循环 面试题： 12345678910111213141516//删除时注意下标和对象的区别@Test public void test4()&#123; List list = new ArrayList(); list.add(1); list.add(2); //删除 list.add(3); updateList(list); System.out.println(list); &#125; private void updateList(List list)&#123; //list.remove(2); //下标2 list.remove(new Integer(2)); &#125; 5、Set接口 set：存储无序的，不可重复的数据 核心实现类： HashSet: LinkedHashSet（子类） TreeSet 核心实现类特点： HashSet：所为set接口的主要实现类，线程不安全的，可以存储null值 LinkedHashSet：作为hashSet的子类，遍历数据时，可以按照添加的顺序遍历，对于操作频繁的元素，可以考虑使用，提供效率。LinkedHashSet的存储效率高于HashSet TreeSet：可以按照添加对象的属性进行排序。要求添加的元素为同一类型 实现原理： 添加的过程描述如： 当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法 来得到该对象的 hashCode 值，然后根据 hashCode 值，通过某种散列函数决定该对象 在 HashSet 底层数组中的存储位置。（这个散列函数会与底层数组的长度相计算得到在 数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布， 该散列函数设计的越好） 如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果 为true，添加失败；如果为false，那么会保存该元素，但是该数组的位置已经有元素了， 那么会通过链表的方式继续链接 如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相 等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功 理解无序性，不可重复： 无序性：表示存储的数据在底层的数组中并非按照数组的索引顺序添加，而是根据数据的哈希值决定 不可重复：为了保证元素的不可重写，我们需要重写hashcode和equals方法 1234567891011121314Set set = new HashSet();set.add(456);set.add(123);set.add(123); //重复的不能添加set.add("aa");//set.add("aa");// set.add(new String("abc"));// set.add(new String("abc")); //string重写hashcode和equeals//需要重写hashcode和equeals方法保证元素唯一性set.add(new Person("tom", 20)); set.add(new Person("tom", 20));System.out.println(set); 总结：（面试） HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类 Set接口是Collection的子接口，set接口没有提供额外的方法 Set 判断两个对象是否相同不是使用 == 运算符，而是根据 equals() 方法 HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取、查找、删除性能 HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等 对于存放在Set容器中的对象，对应的类一定要重写equals() 和hashCode(Objectobj) 方法，以实现对象相等规则 。即： “相等的对象必须具有相等的散列码“ LinkedHashSet LinkedHashSet 是 HashSet 的子类 LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的 LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能 LinkedHashSet 不允许集合元素重复 TreeSet TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态 TreeSet底层使用 红黑树结构存储数据 判断两个对象是否相等的唯一标准： 自然排序使用： compareTo(Object obj) ==0判断相等，不再使用equals（）方法 定制排序使用：compare(Object o1, Object o2)判断相等， 不再使用equals（）方法 当需要把一个对象放入 TreeSet 中，重写该对象对应的 equals() 方法时，应保证该方法与compareTo(Object obj) 方法有一致的结果：如果两个对象通过equals() 方法比较返回 true，则通过 compareTo(Object obj) 方法比较应返回 0 123456789101112131415161718192021222324252627282930//定制排序 Comparator&lt;Person&gt; com = new Comparator&lt;Person&gt;() &#123; @Override public int compare(Person o1, Person o2) &#123; //姓名 a -- z //return o1.getName().compareTo(o2.getName()); // z--a 当姓名相同时，判断年龄 int res = o1.getName().compareTo(o2.getName()); if(res == 0)&#123; return -Integer.compare(o1.getAge(), o2.getAge()); &#125; return -res; &#125; &#125;; TreeSet&lt;Person&gt; set = new TreeSet&lt;Person&gt;(com); set.add(new Person("a", 12)); set.add(new Person("b", 20)); set.add(new Person("c", 24)); set.add(new Person("d", 26)); //姓名相同，年龄不同为不同对象，需要添加到容器中，判断标准为compareTo set.add(new Person("e", 10)); set.add(new Person("e", 33)); //set.add("abc"); System.out.println(set); 6、Map接口1- map：双列数据、存储key-value对数据 核心实现类： HashMap LinkedHashMap(子类) TreeMap Hashtable Properties（子类） 实现类特点： 12345- HashMap：作为Map接口的主要实现类，线程不安全的，效率高。存储null的key和value，底层使用数组+链表（jdk7）， 数组+链表+红黑树（jdk8）- LinkedHashMap：实现了遍历map集合中元素的顺序和添加的顺序一直。以为在原有的HashMap的底层结构中添加了一对指针，指向前一个和后一个元素。所以对于频繁的操作，此执行效率高于HashMap- TreeMap：可以按照key-value对进行排序，实现排序遍历，此时考虑key的自然排序和定制排序的使用- Hashtable：作为古老的实现类，线程安全的，效率低，不能存储null的key或value- Properties：常用来作为配置文件，key和value都是String类型 6.1 Map结构的理解map结构的理解： Map中的key是无序的，不能重复的。使用set存储所有的key ---- &gt;key所在的类必须重写equals和hashcode方法 Map中的value是无序的，可重复的，使用collection存储所有的value ---&gt; value所在的类重写equals()方法 一个键值对： key-value构成了一个Entry对象 Map中的Entry是无序的，不可重复的，使用set存储所有的entry 6.2 HashMap的底层实现原理JDK8：HashMap使用的是数组+链表+红黑树实现 JDK7：HashMap使用的是数组+链表 源码： 12 6.3、LinkedHashMap 在HashMap的存储结构的基础上，使用了一对双向链表来记录添加的元素顺序 迭代顺序和添加顺序一致 常用方法： 123456789101112131415161718192021222324Map map = new HashMap();//添加map.put(123, "AA");map.put(456, "BB");map.put(789, "CC");//修改map.put(123, "dd");//Map map1 = new HashMap();map1.put("cc", 123);map1.put("dd", 456);map.putAll(map1);//removeObject obj = map.remove("cc");System.out.println(obj);//clearmap.clear();System.out.println(map); 1234567891011121314151617181920Map map = new HashMap();map.put("AA", 123);map.put(45, 123);map.put("bb", 67);//get（）Object value = map.get("AA");System.out.println(value);//判断key是否存在boolean key = map.containsKey("bb");System.out.println(key);//判断valueboolean containsValue = map.containsValue(67);System.out.println(containsValue);//Empty：内容空 null：没有地址map.clear(); System.out.println(map.isEmpty()); 1234567891011121314151617181920212223242526272829303132333435363738Map map = new HashMap();map.put("AA", 123);map.put(45, 123);map.put("bb", 67);//遍历所有的keySet keySet = map.keySet();Iterator iterator = keySet.iterator();while(iterator.hasNext())&#123; Object next = iterator.next(); System.out.print(next);&#125;System.out.println("\n---------");//遍历所有的valueCollection values = map.values();for(Object obj:values)&#123; System.out.print(obj);&#125;System.out.println("\n---------");//方式一：entrySet Set entrySet = map.entrySet();Iterator iterator2 = entrySet.iterator();while(iterator2.hasNext())&#123; Object next = iterator2.next(); //entry/node Entry entry = (Entry)next; System.out.println(entry.getKey() + "---" + entry.getValue());&#125;System.out.println("\n---------");//方式二:Set keySet2 = map.keySet(); //所有的keyIterator iterator3 = keySet2.iterator(); while(iterator3.hasNext())&#123;//遍历所有key Object key = iterator3.next(); //key Object value = map.get(key); //根据key获取value System.out.println(key + "---" + value);&#125; 总结： 添加：put（Object key, Object vlaue） 修改：put（Object key, Object vlaue） 删除：remove(Object key) 查询：get（object key） 长度：size（） 遍历： keySet () / values() / entrySet() ---key-value = entry 6.4 TreeMap TreeMap可以实现所有的kev-value处于有序状态 TreeMap底层使用红黑树数据结构存储 TreeMap的key的排序： 自然排序：TreeMap的所有的key必须实现Comparable接口，而且所有的key必须为同一类对象，否则抛出ClassCastException异常 定制排序：创建TreeMap时，传入一个Compartor接口的实现类，该对象负责对TreeMap中的所有key进行排序 TreeMap判断两个key相等的标准：两个key通过compareTo()或compare() == 0 演示代码： 12345678910111213141516171819202122232425262728293031class Person implements Comparable&lt;Person&gt;&#123; private String name; private int age; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + "]"; &#125; @Override public int compareTo(Person o) &#123; //姓名自然顺序 0 , 1 -1 return this.getName().compareTo(o.getName()); //return this.getName() - o.getName(); &#125;&#125; 12345678910111213141516171819TreeMap map = new TreeMap();new String();//方式一：// map.put("c", 3);// map.put("b", 3);// map.put("d", 3);// map.put("e", 3);// map.put("a", 3);map.put(new Person("a",20), 90);map.put(new Person("c",20), 90);map.put(new Person("d",20), 90);map.put(new Person("b",20), 90);map.put(new Person("f",20), 90);System.out.println(map); 123456789101112131415TreeMap map = new TreeMap(new Comparator&lt;Person&gt;() &#123;@Overridepublic int compare(Person o1, Person o2) &#123; return -o1.getName().compareTo(o2.getName());&#125;&#125;);map.put(new Person("a",20), 90);map.put(new Person("c",20), 90);map.put(new Person("d",20), 90);map.put(new Person("b",20), 90);map.put(new Person("f",20), 90);System.out.println(map); 6.5 Properties Properties该对象是属性文件，常用来保存配置信息 属性文件中的内容都为String类型 示例代码： 12345678910111213141516171819202122232425262728FileInputStream input = null; try &#123; //System.out.println(new File("/java_collection/src/db.properties").getPath()); //创建文件输入流 input = new FileInputStream("db.properties"); //创建配置文件对象 Properties pro = new Properties(); //加载配置文件信息 pro.load(input); //配置信息加载到pro对象中 //获取配置文件对象中保存的数据 String user = pro.getProperty("user"); String password = pro.getProperty("password"); System.out.println(user + "---" + password); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(input != null)&#123; try &#123; input.close(); input = null; //gc &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 7、Collections工具类 Collections是操作Set、List、Map集合的工具类 Collection中提供了一系列的静态方法对集合中的元素进行排序、查询、修改等操作，还提供了对集合中对象设置不可变性，同步等方法 1234567891011121314151617181920212223242526272829303132List list = new ArrayList();list.add(123);list.add(23);list.add(45);list.add(33);list.add(78);list.add(33);//6System.out.println(list);//反转//Collections.reverse(list);//随机排序//Collections.shuffle(list);//自然排序//Collections.sort(list);//交换//Collections.swap(list, 1, 2);//返回指定集合中指定的元素出现的次数//int i = Collections.frequency(list, 33);//System.out.println(i);//System.out.println(list);//容器初始大小为6，元素个数为零 size() == 0//List dest = new ArrayList(6);//copyList dest = Arrays.asList(new Object[list.size()]);Collections.copy(dest, list);System.out.println(dest);//返回线程安全的listList list2 = Collections.synchronizedList(list);]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程]]></title>
    <url>%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Java多线程1、程序、进程、线程 程序：完成特定任务，编写的一组特定的指令集合。 静态代码 ---- 静态 进程：正在运行的一个程序。有其自身的产生，运行、消亡的过程（生命周期） --- 动态 系统在运行时会为每个不同的程序分配不同的内存区域，进程作为资源的分配单位。 线程：进程的进一步细分，是程序内部的一条执行路径。 一个进程同一时间内执行多个线程，就是多线程。 每个进程有独立的运行栈和计数器。切换的开销少。 多个线程共享相同的内存单元/内存地址，从同一个堆中分配对象，访问相同的变量和对象。存在安全隐患 内存结构图（了解）： 1](/Users/jiangwei/hexo/source/_posts/多线程/timg.jpeg) 多线程： 并行、并发 并行：多个cpu同时执行多个任务。 并发：一个cpu同时执行多个任务，时间片段 单核、多核 单核：执行多线程时，一个单位时间内只能执行一个线程，只是切换时间特别短，宏观看起来就是同时执行对个线程。 多核：多个内核单位时间内同时执行多个线程。 2、线程创建和使用（重点）多线的使用场景： 12- 程序需要同时执行多个任务- 程序需要实现一些特殊的等待任务，如：用户输入，文件的读写，网络操作，搜索等需要后台执行的程序时。 线程的创建和启动 两种方式： 继承java.lang.Thread 实现Runnable接口 多线程创建方式一：(继承) 步骤：1. 创建一个继承Thread的子类 重写Thread的Run()方法 创建Thread子类的对象 通过此对象调用start（）方法 示例代码：(输出0-99个数) 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.woniu.thread;//. 创建一个继承Thread的子类class MyThread extends Thread&#123; //2.重写Thread的Run()方法 @Override public void run() &#123; //线程完成的业务逻辑 //输出0-99个数 for (int i = 0; i &lt; 100; i++) &#123; System.out.println( Thread.currentThread().getName() + " ： " + i); &#125; &#125; &#125;public class ThreadTest &#123; //main方法运行后会开启一个主线程 public static void main(String[] args) &#123; //3.创建Thread子类的对象 --- 创建分线程 MyThread t1 = new MyThread(); //4.通过此对象调用start（）方法 t1.start(); //start最后调用run //不能直接调用run(),此刻没有实现多线程调用 //t1.run(); //此刻或抛出IllegalThreadStateException ,不能再次调用start方法，启动线程，必须重写创建线程 //t1.start(); new MyThread().start(); // //输出0-99个数// for (int i = 0; i &lt; 100; i++) &#123;// System.out.println("main：" + i);// &#125; System.out.println("------main-------"); &#125;&#125; 说明： 如果手动调用run（）方法，则是普通方法调用，没有启动多线程 run()方法由jvm调用，什么时候调用，执行过程的控制都有操作系统的CPU调度决定。 启动多线程必须调用start（）方法 一个线程对象只能调用一次start（）方法，如果重复调用则抛出llegalThreadStateException异常 练习： 创建两个分线程，一个输出100之内的偶数，一个输出100之内的奇数。 线程常用方法： 方法名称 说明 getName() 获取线程名称 run() 线程在被调度时执行方法 setName(String name) 设置线程名称 sleep(long millis) 让当前线程指定的毫秒数暂停 start() 启动线程 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.woniu.thread;class MyThread2 extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt;= 100; i++) &#123; if(i % 2 == 0)&#123; try &#123; Thread.sleep(10);// &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + ": " + i); &#125;// if(i % 20 == 0)&#123;// yield(); //释放执行权限，交给cpu，让cpu从新分配资源（切换线程），// //但有可能重新分配给自己// &#125; &#125; &#125;&#125;public class MethodTest &#123; public static void main(String[] args) &#123; MyThread2 t1 = new MyThread2(); //设置分线程名称 t1.setName("线程一 "); t1.start(); //设置主线程名称 Thread.currentThread().setName("主线程："); //主线程业务 for (int i = 0; i &lt; 100; i++) &#123; if(i % 2 != 0) &#123; System.out.println(Thread.currentThread().getName() + ": " + i); &#125; if(i == 20)&#123; try //注意：此刻主线程调用分线程t1 t1.join();//(让步)主线程将执行权限分给t1分线程，直达t1分线程执行完毕后再切换回来继续执行 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; System.out.println(t1.isAlive()); //线程消失 &#125;&#125; 线程调度： 调度策略 时间片：分时段执行 抢占式：高优先级可抢占低优先级的线程 调度方法 同优先级线程组成先进先出队列（先到先服务），使用时间片策略 对高优先级，使用优先调度的抢占式策略 优先级等级 MAX_PRIORITY ：10 MIN _PRIORITY ：1 NORM_PRIORITY ：5 1234567891011121314151617181920212223242526272829303132333435package com.woniu.thread;class ThreadDemo extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; if (i % 2 == 0) &#123; System.out.println( Thread.currentThread().getName() + ":" + Thread.currentThread().getPriority() + ":" + i); &#125; &#125; &#125;&#125;public class PriorityTest &#123; public static void main(String[] args) &#123; // 创建子线程 ThreadDemo t1 = new ThreadDemo(); t1.setName("子线程"); // 设置优先级，只是概率高 t1.setPriority(Thread.MAX_PRIORITY); t1.start(); Thread.currentThread().setName("主线程"); Thread.currentThread().setPriority(Thread.MIN_PRIORITY); for (int i = 0; i &lt; 100; i++) &#123; if (i % 2 == 0) &#123; System.out.println( Thread.currentThread().getName() + ":" + Thread.currentThread().getPriority() + ":" + i); &#125; &#125; &#125;&#125; 演示代码：（三个窗口买票，总票数为100张） 1234567891011121314151617181920212223242526272829303132333435363738394041package com.woniu.thread;//三个窗口买票，总票数为100张class Window extends Thread &#123; //定义总票数 private static int ticket = 100; @Override public void run() &#123; while(true)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if(ticket &gt; 0)&#123; System.out.println(getName() + "： 买票， 票号为：" + ticket); ticket--; &#125;else &#123; break; &#125; &#125; &#125;&#125;public class WindowTest &#123; public static void main(String[] args) &#123; Window t1 = new Window(); Window t2 = new Window(); Window t3 = new Window(); t1.setName("1号窗口"); t2.setName("2号窗口"); t3.setName("3号窗口"); t1.start(); t2.start(); t3.start(); &#125;&#125; 问题： 每个窗口卖的票数都是100张，可更改为static的方式实现，三个线程卖100张票的情况，但依然出现重票现象。 关于资源共享的问题，可以使用Runnable方式实现。 多线程的创建方式二：（实现Runnable接口） 步骤： 创建一个实现Runnable接口的实现类 重写实现类中的run()方法 创建实现类对象 创建Thread对象，并使用实现类作为Thread构造器的入参对象 调用Thread对象的start（）方法 示例代码：（使用接口实现多线程） 1234567891011121314151617181920212223242526272829package com.woniu.runnable;//1创建一个实现Runnable接口的实现类class MyThared implements Runnable&#123; //2.重写实现类中的run()方法 @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + ": " + i); &#125; &#125; &#125;public class RunnableTest &#123; public static void main(String[] args) &#123; //3.创建实现类对象 MyThared m = new MyThared(); //4.创建Thread对象，并使用实现类作为Thread构造器的入参对象 Thread t = new Thread(m); //5.调用Thread对象的start（）方法 t.start(); Thread t2 = new Thread(m); t2.start(); &#125;&#125; 示例代码：（三个窗口买票，总票数为100张） 123456789101112131415161718192021222324252627282930313233343536373839package com.woniu.runnable;class Window implements Runnable&#123; //总票数 private int ticket = 100; @Override public void run() &#123; while(true)&#123; if(ticket &gt; 0)&#123; System.out.println(Thread.currentThread().getName() + "卖票， 票号为：" + ticket); ticket--; &#125;else &#123; break; &#125; &#125; &#125; &#125;public class WindowTest &#123; public static void main(String[] args) &#123; Window w = new Window(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName("窗口一"); t2.setName("窗口二"); t3.setName("窗口三"); t1.start(); t2.start(); t3.start(); &#125;&#125; 两种方式说明： ​ 相同： ​ 两种方式都需要重写run()方法，需要实现的业务代码都写在run方法中 实现接口的方便之处： ​ 避免的单继承的局限性 ​ 多个线程可以共享同一个接口中的对象，非常适合多线程共享资源的情况 ​ 开发中优先使用 3、线程生命周期（理解）JDK 中用Thread.State 类定义了 线程的几种 新建：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态 就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片此时它已具备了运行的条件，只是没分配到CPU资源 运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能 阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态 死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束 线程生命周期; 4、线程同步（重点）问题： 12- 多个线程执行的不确定性引起的结果不稳定- 多个线程对同一资源的共享，会造成操作的不完整性，破坏数据 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.woniu.runnable;class Window implements Runnable&#123; //总票数 private int ticket = 100; @Override public void run() &#123; while(true)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if(ticket &gt; 0)&#123; System.out.println(Thread.currentThread().getName() + "卖票， 票号为：" + ticket); ticket--; &#125;else &#123; break; &#125; &#125; &#125; &#125;public class WindowTest &#123; public static void main(String[] args) &#123; Window w = new Window(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName("窗口一"); t2.setName("窗口二"); t3.setName("窗口三"); t1.start(); t2.start(); t3.start(); &#125;&#125; 问题： 买票过程中出现了错票和重票---线程安全问题 当某个线程再操作车票的过程中，尚未完成，其他线程也参与进来，所以也操作车票。 当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有 执行完，另一个线程参与进来执行。导致共享数据的错误 如何解决： 对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行 当一个线程使用操作ticke的时候，其它线程先不参与进来，直到操作完成其他线程再参与进来，也就是说在多线程在操作同一个资源时要排队。 使用同步代码块或同步方法解决 Synchronized的使用： java对于多线程的安全问题提供了专业的解决方式：同步机制（锁） 使用方式： ​ 同步代码块： ​ synchronized(对象) { ​ //需要被同步的代码 ​ } 示例代码：（线程同步，同步代码块，使用Runnable接口） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.woniu.runnable;class Window implements Runnable&#123; //总票数 private int ticket = 100; private Object obj = new Object(); @Override public void run() &#123; while(true)&#123;// try &#123;// Thread.sleep(100);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125; //注意线程同步必须使用同一把锁 //synchronized (obj) &#123; synchronized (this) &#123; if (ticket &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + "卖票， 票号为：" + ticket); ticket--; &#125; else &#123; break; &#125; &#125; &#125; &#125; &#125;public class WindowTest &#123; public static void main(String[] args) &#123; Window w = new Window(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName("窗口一"); t2.setName("窗口二"); t3.setName("窗口三"); t1.start(); t2.start(); t3.start(); &#125;&#125; 示例代码：（线程同步，同步代码块，使用继承Thread） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.woniu.syn;class Window2 extends Thread &#123; // 总票数 private static int ticket = 100; private static Object obj = new Object(); @Override public void run() &#123; while (true) &#123; //synchronized (this) &#123; synchronized (Window2.class) &#123; //this代表t1,t2,t3,不能使用 if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "卖票， 票号为：" + ticket); ticket--; &#125; else &#123; break; &#125; &#125; &#125; &#125;&#125;public class WindowTest2 &#123; public static void main(String[] args) &#123; Window2 t1 = new Window2(); Window2 t2 = new Window2(); Window2 t3 = new Window2(); t1.setName("窗口一"); t2.setName("窗口二"); t3.setName("窗口三"); t1.start(); t2.start(); t3.start(); &#125;&#125; 说明： 操作共享的数据代码，即需要被同步的代码 共享数据：多个线程需要共同操作的变量，比如我们的ticket变量 同步监视器：俗称锁，任何一个类的对象都可以充当锁 多个线程必须用一把锁 使用接口的方式的多线程，可考虑使用this当“锁”，使用继承的方式可考虑使用当前class对象当“锁” 同步方式解决的线程安全问题 同步方式在操作代码时，只能有一个线程参与，其他线程只能等待，相当于一个单线程的过程，效率低 2.使用同步方法实现同步机制： 当同步的行为可以封装为一个方法时，就可以使用同步方法的方式 示例代码：（使用接口） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.woniu.syn;class Window3 implements Runnable &#123; // 总票数 private int ticket = 100; @Override public void run() &#123; while (true) &#123; print(); &#125; &#125; //同步方法 private synchronized void print() &#123; //同步监视器(锁)？this if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "卖票， 票号为：" + ticket); ticket--; &#125; &#125;&#125;public class WindowTest3 &#123; public static void main(String[] args) &#123; Window3 w = new Window3(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName("窗口一"); t2.setName("窗口二"); t3.setName("窗口三"); t1.start(); t2.start(); t3.start(); &#125;&#125; 示例代码:（使用继承） 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.woniu.syn;class Window4 extends Thread &#123; // 总票数 private static int ticket = 100; @Override public void run() &#123; while (true) &#123; print(); &#125; &#125; private static synchronized void print()&#123; //锁是Window4.class if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "卖票， 票号为：" + ticket); ticket--; &#125; &#125;&#125;public class WindowTest4 &#123; public static void main(String[] args) &#123; Window4 t1 = new Window4(); Window4 t2 = new Window4(); Window4 t3 = new Window4(); t1.setName("窗口一"); t2.setName("窗口二"); t3.setName("窗口三"); t1.start(); t2.start(); t3.start(); &#125;&#125; 单例设计模式：（懒汉模式，线程安全） 123456789101112131415161718192021222324252627282930313233343536373839404142package com.woniu.designpatterns;/** * 单例模式(饿汉模式) * (懒汉模式) * @author Administrator * */public class Singleton &#123; //静态只有一份singleton //private static Singleton singleton = new Singleton(); private static Singleton singleton = null; //new Singleton(); private Singleton()&#123; &#125; //获取当前类的实例 public static Singleton getInstance()&#123; //改进： //方式一：// synchronized (Singleton.class) &#123; // if(singleton == null)&#123; // singleton = new Singleton();// &#125;// return singleton;// &#125; //方式二：效率高 if(singleton == null)&#123; synchronized (Singleton.class) &#123; if(singleton == null)&#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 死锁： 不同的线程分别占用对方需要的同步的资源不放弃，都在等待对象放弃自己需要的同步资源，就形成了线程的死锁， 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都出于阻塞状态，无法继续 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.woniu.deadlock;public class DeadLockTest &#123; public static void main(String[] args) &#123; StringBuffer s1 = new StringBuffer(); StringBuffer s2 = new StringBuffer(); //分线程1 new Thread() &#123; @Override public void run() &#123; synchronized (s1) &#123; s1.append("a"); s2.append("1"); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (s2) &#123; s1.append("b"); s2.append("2"); System.out.println(s1); System.out.println(s2); &#125; &#125; &#125;; &#125;.start(); //分线程2 new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (s2) &#123; s1.append("c"); s2.append("3"); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (s1) &#123; s1.append("d"); s2.append("4"); System.out.println(s1); System.out.println(s2); &#125; &#125; &#125; &#125;).start(); &#125;&#125; 解决方案： ​ 专门的算法 ​ 尽量减少同步资源的定义 ​ 尽量避免嵌套同步 5、线程通信 线程执行时互相交换执行。 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.woniu.comm;//让两个线程交替打印数字class PrintCount implements Runnable&#123; private int num = 1; @Override public void run() &#123; while(true)&#123; synchronized (this) &#123; //notify(); //唤醒线程 notifyAll(); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + ": " + num); num++; if(num &gt;= 30)&#123; break; &#125; try &#123; wait(); //线程等待，释放锁，object类中的方法， &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;public class CommTest &#123; public static void main(String[] args) &#123; PrintCount count = new PrintCount(); Thread t1 = new Thread(count); Thread t2 = new Thread(count); Thread t3 = new Thread(count); t1.setName("A"); t2.setName("B"); t3.setName("C"); t1.start(); t2.start(); t3.start(); &#125;&#125; 说明： wait() ：执行到wait（）当前线程排队阻塞（等待），并释放同步监视器notify()：执行到notify（）唤醒正在排队的阻塞线程，优先级最高的先唤醒notifyAll (）：唤醒正在排队等待资源的所有线程结束等待 这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报java.lang.IllegalMonitorStateException异常 这三个方法必须是同一个同步监视器 这三个方法是定义在java.lang.Object对象当中的 经典例题：生产者/消费者问题 问题描述： 生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处获取一定数量的产品店员一次只能持有固定数量的产品如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。 分析问题： ​ 1、是否为多线程？是。生产者线程、消费者线程 2、是否有数据共享？有。店员手中的产品 3、如何解决线程安全？使用同步机制（锁） 4、是否涉及线程通信？ 是 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.woniu.product;class Clerk &#123; private int productCount = 1; //添加产品 public synchronized void addProduct()&#123; if(productCount &lt; 20)&#123; productCount++; System.out.println(Thread.currentThread().getName() + ": 开始生产第" + productCount + "个产品"); notify(); &#125;else &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //消费产品 public synchronized void getProduct()&#123; if(productCount &gt; 0)&#123; System.out.println(Thread.currentThread().getName() + ": 消费者开始消费第" + productCount + "个产品"); productCount--; notify(); &#125;else &#123; //等待 try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;//生产者线程class Producer implements Runnable &#123; private Clerk clerk; public Producer(Clerk clerk) &#123; this.clerk = clerk; &#125; @Override public void run() &#123; //创建产品 System.out.println("生產者生产产品 ： "); while(true)&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; clerk.addProduct(); &#125; &#125; &#125;//消费者线程class Consumer implements Runnable &#123; private Clerk clerk; public Consumer(Clerk clerk) &#123; this.clerk = clerk; &#125; @Override public void run() &#123; //消费产品 System.out.println("消费者消费产品："); while(true)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; clerk.getProduct(); &#125; &#125; &#125;public class ProductTest &#123; public static void main(String[] args) &#123; Clerk c = new Clerk(); Thread t1 = new Thread(new Producer(c)); t1.setName("生产者"); Thread t2 = new Thread(new Consumer(c)); t2.setName("消费者"); t1.start(); t2.start(); &#125;&#125;]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识（二）]]></title>
    <url>%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[方法 定义：方法就是一段用来完成特定功能的代码片段，类似于其它语言的函数。方法用于定义该类或该类的实例的行为特征和功能实现。 方法是类和对象行为特征的抽象。方法很类似于面向过程中的函数。面向过程中，函数是最基本单位，整个程序由一个个函数调用组成。面向对象中，整个程序的基本单位是类，方法是从属于类和对象的。 对象名.方法名(实参列表)方法的详细说明 形式参数：在方法声明时用于接收外界传入的数据。实参：调用方法时实际传给方法的数据。 返回值：方法在执行完毕后返还给调用它的环境的数据。 返回值类型：事先约定的返回值的数据类型，如无返回值，必须显示指定为为void。 数组 声明一个数组： int a[];//指定数据类型 int []a; int a[]=new int[4]//声明的同时分配空间 int a[]=new int[]{1,6,4,10}//声明的同时分配空间并赋值 int a[]={1,6,4,10}//声明的同时分配空间并赋值 二维数组 声明 1234 int a [][]=&#123;&#123;1,2,3&#125;,&#123;1,2,3&#125;,&#123;1,2,3&#125;&#125; a.length=3a[0]=&#123;1,2,3&#125; a[0].length=1 输出： 123456 int a[][]=new int [3] []; a[0]=new int[3];a[1]=new int[4]; a[2]=new int[2]; 以上都属于开辟空间 赋值: a[0] [0]=1; 进制转换1234567891011121314151617二进制转十进制Integer.parseInt(&quot;0110&quot;, 2);八进制转十进制Integer.parseInt(&quot;17&quot;, 8);十六进制转十进制Integer.parseInt(&quot;17&quot;, 16);十进制转成二进制Integer.toBinaryString(int i);十进制转成八进制Integer.toOctalString(int i);十进制转成十六进制Integer.toHexString(int i); 获取随机数 方法一(数据类型)(最小值+Math.random()(最大值-最小值+1))例:(int)(1+Math.random()(10-1+1))从1到10的int型随数 方法二获得随机数for (int i=0;i&lt;30;i++){System.out.println((int)(1+Math.random()10));}(int)(1+Math.random()10)通过java.Math包的random方法得到1-10的int随机数公式是:最小值---最大值（整数）的随机数（类型）最小值+Math.random()*最大值 方法三Random ra =new Random();for (int i=0;i&lt;30;i++){System.out.println(ra.nextInt(10)+1);}通过java.util包中的Random类的nextInt方法来得到1-10的int随机数]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识（一）]]></title>
    <url>%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[java简介 界面：HTML CSS JAVASCRIPT JQUERY BOOTSTRAP VUE 服务器端技术：JAVA JAVAWEB 数据库（mysql oracle） JAVA:在大家要开发的项目中是一种服务器端技术，完成业务逻辑的处理，比如验证用户名密码是否正确。 B/S :浏览器/服务器,一种项目结构 JAVA之父 JAMES GOSLING HOTJAVA 根据开发项目类型JAVA 分为三种类型： JAVASE :标准版 桌面应用程序JAVAEE :企业版 开发B/S结构的项目JAVAME ：小型版 嵌入式 一般的高级语言的运行过程 .c /.cpp 源代码————&gt;编译----&gt;.exe可执行程序（针对特定操作系统） .java-----&gt;编译-----&gt;.class(字节码文件，在操作系统不能直接运行，可以跨平台)------&gt;解释（不同平台有不同的解释器JVM Java虚拟机）----&gt;看到程序的运行结果 JVM：JAVA虚拟机 解释字节码程序 管理Java程序在运行过程所占用的内存空间 JRE：Java运行环境 JRE（JVM是其一部分） JDK：JAVA开发工具包 bin目录：存放可执行文件； ib目录：存放Java的类库文件； include目录：存放用于本地方法的文件； demo目录：存放演示程序； jre目录：存放Java运行环境文件； 学会使用Java API文档 Java中已经定义好的类、接口数不胜数，不可能完完全全把这些类及其这些类的方法记住。但API文档能够帮助解决这样的问题。在学习Java的过程中和别人交流是很重要的，有助于提高自己的技术知识。 Java API文档是一种非常有用的文档，描述许多Java的内置功能，其中包含类、包、接口等帮助。 Java数据结构 标识符命名规则： 1.类名称（首字母大写） 2.方法名称 3.变量名称（一般首字母小写）字母、_、$ 双单词采用驼峰法 八种基本数据类型 整数型： byte（1字节）-128〜127 short（2） -2^15〜2^15-1 -32768〜32767 int（4） 21 4748 3647//java中任何整数默认int型 long（8字节） //d=214748xxxl 超过int型最大值要加l 浮点型： float e=3.14f （4字节） //浮点数不能做精确运算 double f=3.14 （8字节） 字符型： char j=&#39;中&#39;; （2字节）0〜65536//单引号只能且放一个字符（没有符号位）可以表示一个汉字 波尔型： Boolean（1字节） //变量能表示ture false 字符串数据类型： 不属于8种基本类型例如 String s=&quot;abc&quot; abc是字符串 s.length=3 数据类型转换 强制类型转换大数据向小数据放 // short d=128; 错误方式小数向整数放 //byte c=(byte)d;正确方式转换过程中都可能发生精度损失，因为转换过程中采用的原理是高位截断， 剩下的位数可能表示的数字跟原来就不一致了。 short s=1; s+=1; //等价于 s=(short)(s+1) 需要强制转换 精度损失：以下情况可能会发生精度损失，因为等号右边按照Int型运算，不够存放算术运算结果// long a=24246010001000;// long a=24246010001000l; 自动提升转换 1.可以将一个char型变量赋值给int型或者long型，不能byte和short2.不能将一个整型的变量赋值给char3.可以将一个整型的字面量赋值给char (0-65535)a+1&lt;a 在高位截短的情况下可能发生4.常量 只能赋一次值 例：final int a=10; 运算符 算数运算符%取余++自加 // a++先参与后自加 ++a先自加后参与--自减 关系运算符&lt; &gt; &lt;= &gt;= == != 逻辑运算符 &amp;&amp; 与 (&quot;A&amp;&amp;B&quot; A部分为false则B部分不执行输出false) || 或(&quot;A||B&quot; A部分为ture则B部分不执行输出ture) !（op1） 非（一元运算符 包括++ --）&amp; 、|(也是逻辑与和逻辑或，不存在短路效应) 位运算符位运算符用来对二进制数进行测试、置位或移位等操作，操作数只能为整型或字符型数据〜a //按位取反a&amp;ba|ba^ba&gt;&gt;2 A左移2位A&lt;&lt;2 A右移2位A &gt;&gt;&gt;3 A无符号右移3位（注意 赋值运算符 =和条件运算符max=a&gt;b?a:b;）注意：0b10 表示十进制2 010 表示十进制8 0x10 表示十进制16 Java控制语句 多重if 结构 判断某个数是否落在某个区间 123456789101112public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); // 从控制台输入 int jf = sc.nextInt(); if (jf &lt; 2000) System.out.println("0.9折"); else if (jf &gt;= 2000 &amp;&amp; jf &lt; 4000) System.out.println("0.8折"); else if (jf &gt;= 4000 &amp;&amp; jf &lt; 8000) System.out.println("0.7折"); else System.out.println("0.6折");&#125; Switch 123456789Switch（表达式）&#123; case 常量1: 语句// break； case 常量2: 语句// break； default: 语句// while while(布尔ture/false表达式) //循环条件，只要表达式为ture就一直执行下去 while(answer.equals(&quot;y&quot;)){ syso(&quot;早上。。中午。。晚上。。&quot;)； syso(&quot;表演的怎么样？请回答（y/n）:&quot;); answer=input.next(); //循环输入回答 } syso(&quot;圆满完成！&quot;)//只有当回答是y 时才跳出循环 循环结构do while 123do&#123;循环操作 //至少执行一次操作&#125;while(布尔ture/false表达式)； //循环条件，只要表达式为ture就一直执行 for循环 123456789 初始化；布尔表达式；更新 for (int=0; i&lt;100; i++)&#123; sysyo("我最棒")；//循环体&#125;for（；；）&#123; if（布尔表达式）&#123; break/continue； &#125;&#125; 最先执行初始化。可以声明一种类型，但可以初始化一个或多个循环控制变量，也可以是空语句。 然后检测布尔表达式。ture循环体被执行，false循环体终止，开始执行循环体后面的语句。 执行一次循环后，更新循环控制变量。 再次检测布尔表达式。执行上面的过程。 嵌套for循环 1234567891011121314public static void lest2()&#123; Scanner sc=new Scanner(System.in); System.out.println("请输入行数n"); int n=sc.nextInt(); for (int i = 0; i &lt;n; i++) &#123; for (int j = 0; j &lt; n-i-1; j++) &#123; System.out.print(" "); // 不加ln默认不换行！！ &#125; for (int j = 0; j &lt; 2*i+1;j++) &#123; System.out.print("*"); &#125; System.out.println(""); &#125; &#125;]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客美化]]></title>
    <url>%2F%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[NexT主题美化 ☑️ NexT.v7.2.0 自带功能集合 1️⃣ NexT网站配置源码 ：主要看站点配置文件_config.yml 2️⃣ NexT主题配置源码：主要看主题配置文件_config.yml 3️⃣Next主题官方博客: 绝大部分配置这里都可以找到 ❗️ 本博客具体实现功能如下： 设置站点名称/昵称/简介 设置菜单menu 设置头像avatar 博客评论功能valine,需注册leancloud 设置社交链接&amp;图标social&amp; social_icons 图标大全：Font Awesome 设置网站图标favicon,把头像设置成.png文件放到image文件夹下，在代码里替换掉image/后面的XXXX.png；logo.svg也可以用png替换（本人测试成功） 1234567favicon： small：/ images / favicon-16x16-next.png medium：/images/favicon-32x32-next.png apple_touch_icon：/images/apple-touch-icon-next.png safari_pinned_tab：/images/logo.svg ＃ ANDROID_MANIFEST：/images/manifest.json ＃ ms_browserconfig：/images/browserconfig.xml 增加RSS订阅功能，详见3️⃣ 减少两侧留白，详见3️⃣ 阅读百分比，详见3️⃣ 访客数和访问量统计busuanzi (不准确，我没弄) 底部是否显示hexo /NexT 版本号 和 “驱动支持”，详见3️⃣ Copyright 后面的❤️修改 增加动态设置和颜色设置，详见3️⃣ 显示右上GitHub标识github_banner 代码页面增加copy按钮，详见3️⃣ 在标签页显示标签云 tagcloud 本地搜索 ，详见3️⃣ 图床盘点一下免费好用的图床 （我还没用） 友情链接 打开 themes/next/_config.yml 文件,搜索关键字 Blog rolls 博文置顶Hexo博客彻底解决置顶问题 （我还没做） ❌ 删除部分 删除在线聊天功能daoVoice 删除文章阴影和动态背景canvas 理由：太占资源了而且并不实用(包括看板娘/鼠标点击效果/爆炸效果/内插音乐播放器等)不建议设置。 🆕 新功能待发掘... 本文为原创内容，转载请注明出处。🙏]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>NexT</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《白银时代》读后感]]></title>
    <url>%2F%E6%96%87%E5%AD%A61%2F</url>
    <content type="text"><![CDATA[人的一切痛苦，本质上都是对自己无能的愤怒。 王小波 当代流传着这么一句话：“男生不可不读王小波，女生不可不读周国平。” 王小波的作品以其文采和哲思赢得了无数读者的青睐，无论花季还是老年，都能从他的文字中收获智慧和超然。 王小波，中国当代学者、作家。代表作品有《黄金时代》《白银时代》《青铜时代》《黑铁时代》等。他仅创作的一部电影剧本《东宫西宫》，就获得了阿根廷国际电影节最佳编剧奖，并且入围1997年戛纳国际电影节。 在王小波的众多作品中，最吸引我的，就是他的《白银时代》。 翻开王小波《白银时代》的第一页，大学二年级热力学课老师正在课室上讲道：“将来的世界是银子的”。 自此，王小波便以一个独特的视角，在白银时代这个虚拟时空里作了一个关于未来世界的黑色预言。 希腊神话里说，白银时代的人蒙神恩宠，终身不会衰老，也不会为生计所迫，他们没有痛苦没有忧虑，一直到死，相貌和心灵都像儿童。死掉以后，他们的幽灵还会在尘世上游荡。 然而他所表现的白银世界却与神话中的乌托邦理想国大相径庭甚至是截然相反。 这是个在两个时空下同时进行的故事，一个是大二的学生时代，一个是2020年步入写作公司的职业时代。在作者眼里，它们都是白银时代，在同质化基础上构建起来的一个压抑自我和人性的强权社会。 这是个师生恋的故事。主人公被刻画成了一个受虐者，被倒挂，被钉十字架，如耶稣受难日那天般被折磨。我们在阅读之余，不禁惊叹王小波的世界，那深不见底的内涵。 王小波变幻莫测的文风，体现了现实对人的折磨，但不苦闷，也不压抑，自然流畅的文字为人们解读了现实中不可言喻的道理。 在故事中，有一句话不断被重复——“世界是银色的”。我们可以想象一下，整个世界都是灰蒙蒙的银色，看不到未来，主人公在银色的世界里被镀成了一个银色的雕塑，压抑、沉闷。 他的白银时代一些人说看不懂，一会儿是“我”坐在写字楼里写文章，一会儿又回到了师生恋，王小波的文章总是在这虚虚实实真真假假中，把读者绕进去。 本文内容为转载，感谢阅读。🙏]]></content>
      <categories>
        <category>文学分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[处女篇]]></title>
    <url>%2F%E5%A4%84%E5%A5%B3%E7%AF%87%2F</url>
    <content type="text"><![CDATA[养成写博客的习惯 这将使你的人生变的非常有意义！ ❓ 为什么创建个人博客Record： 记录下自己的学习过程及心得 记录让人自律，自律让人自信 记录是对自己努力的一种认可 Share： 一名优秀的程序员必将具备开源精神 个人的工作与学习过程遇到过很多问题也是通过search blogs 解决的 个人经历与经验分享给朋友未尝不是一件美事 Exchange： My blogs should 具有讨论价值 文章应该具有思辨性 认识更多的小伙伴 交流中成长 Freedom： 远离鱼龙混杂的广告 浩瀚重复的blog资源 静下心回归写作本身 选择性汲取精华blog 🛠 怎样搭建个人博客 首先你需要一个GitHub账号 你需要在电脑安装git并且你需要熟悉一些DOS命令 在DOS窗口安装Hexo并使用NexT主题 最适合新手的 GitHub + Hexo 「大话」博客搭建教程 Hexo 官网：https://hexo.io/zh-cn/ 部署博客 NexT 主题官网：http://theme-next.iissnan.com/ 美化博客 ✍🏻 如何经营个人博客 文章质量决定文章高度 简洁轻快的博客UI 优秀的用户体验 版权意识与推广意识 本文为原创内容，转载请注明出处，感谢您的阅读🙏]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>begin</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java学习网站]]></title>
    <url>%2Fjava%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[java 学习网站速学堂 廖雪峰 菜鸟教程 其他GitHub中文帮助文档 jdk1.8中文版 UML图学习]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java11包装类]]></title>
    <url>%2Fjava11%E5%8C%85%E8%A3%85%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[包装类一、什么是包装类 包装类（Wrapper Class）： Java是一个面向对象的编程语言，但是Java中的八种基本数据类型却是不面向对象的，为了使用方便和解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八种基本数据类型对应的类统称为包装类(Wrapper Class)，包装类均位于java.lang包。 二、包装类的用途 为了使用方便Java中将8中基本数据类型进行了封装：除了Integer和Character类以后，其它六个类的类名和基本数据类型一直，只是类名的第一个字母大写即可。 boolean —&gt; Boolean char —&gt; Character byte—&gt; Byte short—&gt; Short long—&gt; Long int —&gt; Integer float—&gt; Float double—&gt; Double 对于包装类说，用途主要包含两种：a、作为 和基本数据类型对应的类 类型存在，方便涉及到对象的操作。b、包含每种基本数据类型的相关属性如最大值、最小值等，以及相关的操作方法。 三、包装类的实际使用（以int和integer为例） 1. int和integer类之间的转换在实际转换时，使用Integer类的构造方法和Integer类内部的intValue方法实现这些类型之间的相互转换： int n=5; Integer n1=new Integer(n); System.out.println(&quot;int类型转换为integer类：&quot;+n1); Integer i=new Integer(50); int i1 = i.intValue(); System.out.println(&quot;integer类转换为int类型：&quot;+i1); 2. Integer类内部的常用方法Integer类的主要方法有：parseInt方法和toString方法。 //parseInt方法： 数字字符串类型转成int类型 String ss=&quot;123&quot;; int ii = Integer.parseInt(ss); System.out.println(&quot;字符类型转成整型：&quot;+ii); //toString方法：int类型转成数字字符串类型 int ii2=123; String ss2 = Integer.toString(ii2); System.out.println(&quot;int类型转成数字字符串类型:&quot;+ss); JDK自从1.5版本以后，就引入了自动拆装箱的语法，也就是在进行基本数据类型和对应的包装类转换时，系统将自动进行，这将大大方便程序员的代码书写。自动装箱：将 基本数据类型 封装为对象类型，来符合java的面向对象的思想。自动拆箱：将对象重新转化为基本数据类型。 //5是基本数据类型，通过自动装箱变成对象类型。 //编译器执行了Integer iii = Integer.valueOf(5) Integer iii=5; //自动拆箱，实际上执行了 int iii2 = iii.intValue() int iii2=iii; System.out.println(iii2); valueOf（）源码分析： public static Integer valueOf(int i) &#123; assert IntegerCache.high&gt;= 127; if (i &gt;= IntegerCache.low&amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i+ (-IntegerCache.low)]; return new Integer(i);&#125; 说明：Integer iii=5;相当于编译器执行了Integer iii = Integer.valueOf(5)操作。这个方法就是返回一个 Integer 对象，只是在返回之前，看作了一个判断，判断当前 i 的值是否在 [-128,127] 区别，且 IntegerCache 中是否存在此对象，如果存在，则直接返回引用，否则，创建一个新的对象。 3.包装类的缓存值各个包装类缓存值范围 ： boolean：true和false byte：-128～127 char：0～127 short：-128～127 int：-128～127 long：-128～127 特别注意：对于float和double没有缓存。在对上述值进行装箱的时候（如：Character c1=127;or Integer i= Integer.valueOf(1); 这个不行哦：Integer i2=new Integer(1)；因为这是新建了一个对象出来。）,并不是创建一个新对象而是使用缓存中的对象，如果超出范围则需要新建立对象。 四、常见的面试题 1.Java中Int与Integer的区别？ 一、int 是基本类型，直接存数值；而integer引用数据类型。二、Int的声明不需要实例化，且变量声明后的初始值为0；Integer的是一个类，初始值为null，需要进行实例化，才能对变量数据进行处理。三、Integer类是int的包装类，实际开发中Integer被看成一个对象，可以进行数据转换等操作。 2.判断下面程序片段输出的结果： Integer num1 = 200;Integer num2 = 200; System.out.println(&quot;num1==num2: &quot;+(num1==num2)); Integer num3 = 100;Integer num4 = 100; System.out.println(&quot;num3==num4: &quot;+(num3==num4)); 输出结果：num1==num2:false 和num3==num4:true说明： 首先要明确equal方法与==的区别：equals() 比较的是两个对象的值（内容）是否相同。“==” 比较的是两个对象的引用（内存地址）是否相同，也用来比较两个基本数据类型的变量值是否相等。 java定义：在自动装箱时对于值从–128到127之间的值，它们被装箱为Integer对象后，会存在内存中被重用，始终只存在一个对象而如果超过了从–128到127之间的值，被装箱后的Integer对象并不会被重用，即相当于每次装箱时都新建一个 Integer对象；]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java10补充枚举]]></title>
    <url>%2Fjava10%E8%A1%A5%E5%85%85%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[枚举使用场景： ​ 当类的对象的个数是确定的（较少有限）时候，就可以考虑使用枚举类来表示，比如使用一组常量就可以重点考虑使用枚举类 jdk1.5之前使用自定义枚举类： 示例代码： package com.woniu.java;class Season &#123; // 1.属性私有，并且是final类型 private final String SEASONNAME;// 季节的名称 private final String SEASONDESC;// 季节的描述 // 2.定于私有化构造器 private Season(String seasonName, String seasonDesc) &#123; this.SEASONNAME = seasonName; this.SEASONDESC = seasonDesc; &#125; // 3.提供当前枚举的多个对象 public static final Season SPRING = new Season("春天", "春暖花开"); public static final Season SUMMER = new Season("夏天", "夏日炎炎"); public static final Season AUTUMN = new Season("秋天", "秋高气爽"); public static final Season WINTER = new Season("冬天", "白雪皑皑"); // 4.获取属性get方法 public String getSEASONNAME() &#123; return SEASONNAME; &#125; public String getSEASONDESC() &#123; return SEASONDESC; &#125; //重写toString方法 @Override public String toString() &#123; return "Season [SEASONNAME=" + SEASONNAME + ", SEASONDESC=" + SEASONDESC + "]"; &#125; &#125;public class EnumTest &#123; public static void main(String[] args) &#123; Season spring = Season.SPRING; System.out.println(spring); Season summer = Season.SUMMER; Season autumn = Season.AUTUMN; Season winter = Season.WINTER; &#125;&#125; jdk1.5之后使用enum枚举来定义 示例代码： package com.woniu.java;enum SeasonEnum &#123; //创建枚举类对象，多个用，号隔开 SPRING("春天", "春风又绿江南岸"), SUMMER("夏天", "映日荷花别样红"), AUTUMN("秋天", "秋水共长天一色"), WINTER("冬天", "窗含西岭千秋雪"); private final String seasonName; private final String seasonDesc; private SeasonEnum(String seasonName, String seasonDesc) &#123; this.seasonName = seasonName; this.seasonDesc = seasonDesc; &#125; public String getSeasonName() &#123; return seasonName; &#125; public String getSeasonDesc() &#123; return seasonDesc; &#125;&#125;public class EnumTest2 &#123; public static void main(String[] args) &#123; SeasonEnum spring = SeasonEnum.SPRING; System.out.println(spring); System.out.println(spring.getSeasonName()); &#125;&#125; 说明： 使用 enum 定义的枚举类默认继承了 java.lang.Enum类，因此不能再继承其他类 枚举类的构造器只能使用 private 权限修饰符 枚举类的所有实例必须在枚举类中显式列出（, 分隔 ; 结尾）列出的实例系统会自动添加 public static final 修饰 必须在枚举类的第一行声明枚举类对象 Enum 类 的主要方法 values() 方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值 valueOf(String str)可以把一个字符串转为对应的枚举类对象，要求字符串必须是枚举类对象的“名字 toString()：返回当前枚举类对象常量的名称 示例代码： //values()// SeasonEnum[] values = SeasonEnum.values();// for (int i = 0; i &lt; values.length; i++) &#123;// System.out.println(values[i]);// &#125; //valueOf SeasonEnum winter = SeasonEnum.valueOf("WINTER"); System.out.println(winter); //toString() String summer = SeasonEnum.SUMMER.toString(); System.out.println(summer); 注解JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持， 也就是Annotation(注解)，其实就是代码里的 特殊标记， 注解和修饰符类似可以修饰包，类，属性，方法，局部变量 在JavaEE中大面积使用，框架 = 注解 + 反射 + 设计模式 注解使用@符号来修饰 文档相关注解： @author：作者 @version：版本 @see：相关主题 @Since：从哪个版本开始 @param： 参数说明 @return：方法返回说明 @exception：异常说明 /*** @author shkstart* @version 1.0* @see Math.java*/public class JavadocTest &#123;/*** 程序的主方法，程序的入口* @param args String[] 命令行参数*/public static void main(String[] args) &#123;&#125;/*** 求圆面积的方法* @param radius double 半径值* @return double 圆的面积*/public static double getArea(double radius)&#123;return Math.PI * radius * radius;&#125;&#125; javaSE中三个基本注解 Override: 限定重写父类方法, 该注解只能用于方法 @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时 @SuppressWarnings: 抑制编译器警告 public class AnnotationTest&#123; public static void main(String[] args) &#123; @SuppressWarnings("unused") int a = 10; &#125; @Deprecated public void print()&#123; System.out.println("过时的方法"); &#125; @Override public String toString() &#123; return "重写的toString方法()"; &#125;&#125; 替换配置文件： @WebServlet("/login") //注解方式//替换如下xml配置文件&lt;servlet&gt;&lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;&lt;servlet-class&gt;com.servlet.LoginServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;&lt;url-pattern&gt;/login&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; ​ 自定义Annotation JDK 的元注解（ Annotation） 用于修饰其他 Annotation 定义 JDK5.0提供了4个标准的meta-annotation类型，分别是： Retention ：用于指定该 Annotation 的生命周期，内部包含一个包含一个 RetentionPolicy 类型 RetentionPolicy.SOURCE:在源文件中有效（即源文件保留） RetentionPolicy.CLASS:在class文件中有效（即class保留） RetentionPolicy.RUNTIME:在运行时有效（即运行时保留） Target：用于指定被修饰的 Annotation 能用于修饰哪些程序元素 Documented：修饰的 Annotation 类将被javadoc 工具提取成文档 Inherited：被它修饰的 Annotation 将具有 继承性 示例代码： package com.woniu.java2;import java.lang.annotation.Annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@interface MyAnnotation &#123; String value() default "woniu";&#125;@MyAnnotation(value = "123")public class AnnotationTest &#123; public static void main(String[] args) &#123; Class clazz = AnnotationTest.class; Annotation a = clazz.getAnnotation(MyAnnotation.class); MyAnnotation m = (MyAnnotation) a; String info = m.value(); System.out.println(info); &#125;&#125; jdk1.8中新添加注解 jdk1.8中新添加两个注解的改进 可重复的注解 可用于类型的注解 可重复注解 示例代码： 类型注解： JDK1.8之后，元注解@Target的参数类型ElementType枚举值多了两个： - ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中 - ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中示例代码：]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java09日期类]]></title>
    <url>%2Fjava09%E6%97%A5%E6%9C%9F%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[1、jdk8之前的日期、时间API计算世界时间的主要标准： UTC ： 世界标准时间， GMT：英国的格林威治时间，也是世界标准时间，本初子午线 CST：格林尼治时间 1.1 java.lang.System类 当前类提供currentTimeMillis（）方法来返回当前时间与1970年1月1号0分0秒之间的毫秒数之差，也称为时间戳。 示例代码： long millis = System.currentTimeMillis();System.out.println(millis); //订单号会用到 1.2 java.util.Date体系结构： 注意两Date java.util.Date 考虑两个方法： - 如何实例化 - 有什么方法可以调用 - 查看实现原理1、两个构造器的使用 2、两个方法的调用 实例代码： //1.构造器Date()Date date = new Date();System.out.println(date); //默认调用toString方法，并且被重写System.out.println(date.toString());System.out.println(date.getTime()); //获取毫秒数//2.根据毫秒数创建日期Date date2 = new Date(1563760979511L);System.out.println(date2); java.sql.Date 对应这数据库中的日期类型对象 //为了防止冲突，进行全路径创建java.sql.Date date = new java.sql.Date(1563761119253L);//将util.date转换为sql.datejava.sql.Date date2 = new java.sql.Date(new Date().getTime());System.out.println(date2); 1.3. java.text.SimpleDateForamt- simpleDateForm用来格式化和解析日期类型的具体类 - 格式化：日期 ---&gt; 文本（字符串） - 解析：文本（字符串） ---&gt; 日期//1创建格式化对象SimpleDateFormat sdf = new SimpleDateFormat();//格式化：日期---&gt;文本Date date = new Date();//System.out.println(date);String format = sdf.format(date);//System.out.println(format); //19-7-22 上午10:43//解析: 文本 ---&gt; 日期//String str = "2019/07/22"; //默认不识别String str = "19-7-22 上午10:43"; //默认格式Date parse = sdf.parse(str); //抛出异常System.out.println(parse); 可以指定格式化方式： 官网实例： 示例代码： //使用指定格式进行格式化处理//"yyyy-MM-dd'T'HH:mm:ss.SSSZ"SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); //考虑2019/07/22方式//格式化 String str = sdf.format(new Date());System.out.println(str);//解析String sources = "2019-07-22 10:56:00";Date date = sdf.parse(sources);System.out.println(date); 注意： - 字符串和构造器指定的格式必须相同，否则出现异常1.4.java.util.Calendar Calendar是一个抽象的基类，主要用于完成日期字段直接的互相操作功能 //实例化Calendar calendar = Calendar.getInstance();//getint day = calendar.get(Calendar.DAY_OF_MONTH);System.out.println(day);System.out.println(calendar.get(Calendar.DAY_OF_WEEK));//set//calendar.set(Calendar.DAY_OF_MONTH, 10); //改变本身信息//day = calendar.get(Calendar.DAY_OF_MONTH);//System.out.println(day);//addcalendar.add(Calendar.DAY_OF_MONTH, -3);day = calendar.get(Calendar.DAY_OF_MONTH);System.out.println(day);//getTime 日历类 ---&gt; DateDate date = calendar.getTime(); //更改过的dateSystem.out.println(date);//setTime date ---&gt; 日历类calendar.setTime(new Date()); //将时间改变回来System.out.println(calendar.get(Calendar.DAY_OF_MONTH)); 注意： 获取月份：一月是0、二月是1、三月是2、以此类推 12月是11 获取星期时：周日是1、周一是2、... 周六是7 2、JDK8之后的日期、时间API为什么使用新的Date： 可变性：相日期、时间类型应该设计为不可变的 格式化：格式化只对Date起作用，Calendar则没有 偏移量： 日期设定必须使用偏移量 示例代码： //Calendar.set(year + 1900, month, date) 使用偏移量Date date = new Date((2019-1900), (7-1), 22);System.out.println(new SimpleDateFormat("yyyy-MM-dd").format(date)); jdk8、提供了新的包： java.time :包含值对象的基本包 java.time.format: 格式化和解析日期和时间 .... 2.2、LocalDate、LocalTime、LocalDateTimejava8中的java.time包中提供了常用的时间和日期对象： LocalDate ： 本地日期 LocalTime：本地时间 LocalDateTime：本地时间和日期（最常用之一） //如实例化：方式一：now() LocalDate date = LocalDate.now(); System.out.println(date); LocalTime time = LocalTime.now(); System.out.println(time); LocalDateTime localDateTime = LocalDateTime.now(); System.out.println(localDateTime); //方式二：XXX.of()// LocalDate date2 = LocalDate.of(2019, 7, 22);// System.out.println(date2); //LocalDateTime.of(year, month, dayOfMonth, hour, minute) //getXXX获取相关属性 System.out.println(localDateTime.getYear()); System.out.println(localDateTime.getDayOfWeek()); //星期 System.out.println(localDateTime.getMonth()); //JULY System.out.println(localDateTime.getMonthValue()); //7 System.out.println(localDateTime.getDayOfMonth()); //withXXX 设置属性 --- 不可变性 LocalDateTime month = localDateTime.withDayOfMonth(3); //设置日期，返回新的对象 System.out.println("新：" + month); System.out.println("原: " + localDateTime); //puls LocalDateTime plusMonths = localDateTime.plusMonths(3); System.out.println("新：" + plusMonths); System.out.println("原: " + localDateTime); //minus LocalDateTime minusHours = localDateTime.minusHours(3); System.out.println("新： " + minusHours); System.out.println("原: " + localDateTime); 2.3.瞬时 Instant 时间线上的一个瞬时点，被用来记录应用程序中的时间戳（毫秒数），方便计算机识别 示例代码： //1.实例化 now()本初子午线时间Instant instant = Instant.now();//使用的是英国的格林威治时间时间，本初子午线时间System.out.println(instant);//2.atOffset设置偏移量OffsetDateTime atOffset = instant.atOffset(ZoneOffset.ofHours(8));System.out.println(atOffset);//3.距离1970年的毫秒数long milli = instant.toEpochMilli();System.out.println(milli);//1563776939702//4.使用毫秒数创建Instant对象Instant instant2 = Instant.ofEpochMilli(new Date().getTime());System.out.println(instant2); 2.4. 格式化/解析日期和时间 jdk1.8使用java.time.format.DateTimeFormatter提供了3中方式进行格式化： 预定义格式化 本地化相关的格式 自定义格式 实例代码： // 1、使用预定义的格式创建格式化对象DateTimeFormatter dtf = DateTimeFormatter.ISO_LOCAL_DATE_TIME;// 格式化：日期---》文本LocalDateTime now = LocalDateTime.now();String format = dtf.format(now);System.out.println(format);// 解析: 文本 ---》 日期TemporalAccessor parse = dtf.parse("2019-07-22T14:50:25.154");System.out.println(parse);// 2.本地化相关的格式// 方式一：ofLocalizedDateTime(FormatStyle.XXX)// LONG、MEDIUM、SHORTDateTimeFormatter dtf2 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);// 格式化String format2 = dtf2.format(now);System.out.println(format2);// 解析：TemporalAccessor parse2 = dtf2.parse("2019年7月22日 下午02时57分47秒");System.out.println(parse2);// 3、自定义格式DateTimeFormatter ofPattern = DateTimeFormatter.ofPattern("yyyy-MM-dd hh:mm:ss");// 格式化String format3 = ofPattern.format(now);System.out.println(format3);// 解析：TemporalAccessor parse3 = ofPattern.parse("2019-07-22 03:02:08");System.out.println(parse3); 3、Java比较器 引用数据类型（数组、对象）只能使用 == 或！= 来进行比较（地址的相等或不等），如果想比较大小则必须使用java比较器 java中比较器分为两种： - 自然排序：java.lang.Comparable - 定制排序：java.util.Comparator实例代码： //string类型实现了 Comparable&lt;String&gt;接口所以能够排序String[] strs = new String[] &#123; "ff", "cc", "dd", "aa", "ee" &#125;;Arrays.sort(strs); //为什么能够排序，实现的是默认自然排序System.out.println(Arrays.toString(strs)); Comparable排序： ​ String 、包装类等实现了comparable接口重写了compareTo(T o)方法，给出了比较两个对象的大小的方式，所以我们自定义的类只需要实现该接口重写相应的方法实现排序 重写compareTo(T o)方法的规则： 如果this对象（属性值） &gt; o(形参对象的属性值) ，则返回正数 如果this对象（属性值） &lt; O(形参对象的属性值)，则返回复数 如果this对象（属性值） = O(形参对象的属性值)，则返回零 实例代码： @SuppressWarnings("rawtypes")class Goods implements Comparable &#123; private String name; // 商品名称 private double price; // 商品价格 public Goods(String name, double price) &#123; super(); this.name = name; this.price = price; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return "Goods [name=" + name + ", price=" + price + "]"; &#125; @Override public int compareTo(Object o) &#123; // System.out.println("compareTo --- "); if (o instanceof Goods) &#123; Goods good = (Goods) o; // 设置比较标准 if (this.getPrice() &gt; good.getPrice()) &#123; return 1; //正序 // return -1; //倒序 &#125; else if (this.getPrice() &lt; good.getPrice()) &#123; return -1; // return 1; &#125; else &#123; //如果价格相等，按照字母排序 //return 0; return this.getName().compareTo(good.getName()); &#125; &#125; throw new RuntimeException("类型不匹配"); &#125;&#125; Goods[] goods = new Goods[4];goods[0] = new Goods("红楼梦", 30);goods[1] = new Goods("西游记", 80);goods[2] = new Goods("三国", 70);goods[3] = new Goods("水浒", 80);Arrays.sort(goods); //实现自然排序System.out.println(goods); // 数组的地址System.out.println(Arrays.toString(goods)); Comparator排序 使用场景： - 当元素的类型没有实现java.lang.Comparable接口或虽然实现了该接口但指定的排序规则和我们需要实现的不一样，我们就可以考虑使用Comparator排序使用规则： 实现接口，重写compare(Object o1, object o2) 方法，比较o1 和 o2的大小 大于零： o1 &gt; 02 等于零： o1 = o2 小于零： o1 &lt; o2 示例代码： String[] strs = new String[] &#123; "ff", "cc", "dd", "aa", "ee" &#125;;//接口的实现类Arrays.sort(strs, new Comparator&lt;String&gt;()&#123; //从大到小 --- 字典顺序的倒序 @Override public int compare(String o1, String o2) &#123; return -o1.compareTo(o2); &#125;&#125;);System.out.println(Arrays.toString(strs)); Goods[] goods = new Goods[4];goods[0] = new Goods("红楼梦", 30);goods[1] = new Goods("西游记", 80);goods[2] = new Goods("三国", 70);goods[3] = new Goods("水浒", 80);//价格倒序 字母倒序Arrays.sort(goods, new Comparator&lt;Goods&gt;()&#123; @Override public int compare(Goods o1, Goods o2) &#123; //价格倒叙 //方式一： if(o1.getPrice() &gt; o2.getPrice())&#123; return -1; //价格倒序 &#125;else if(o1.getPrice() &lt; o2.getPrice())&#123; return 1; //价格倒序 &#125;else &#123; //return 0; return -o1.getName().compareTo(o2.getName()); &#125; //方式二： //Double.compare(o1.getPrice(), o2.getPrice()); &#125; &#125;);System.out.println(Arrays.toString(goods));]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java08多线程]]></title>
    <url>%2Fjava08%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Java多线程1、程序、进程、线程 程序：完成特定任务，编写的一组特定的指令集合。 静态代码 ---- 静态 进程：正在运行的一个程序。有其自身的产生，运行、消亡的过程（生命周期） --- 动态 系统在运行时会为每个不同的程序分配不同的内存区域，进程作为资源的分配单位。 线程：进程的进一步细分，是程序内部的一条执行路径。 一个进程同一时间内执行多个线程，就是多线程。 每个进程有独立的运行栈和计数器。切换的开销少。 多个线程共享相同的内存单元/内存地址，从同一个堆中分配对象，访问相同的变量和对象。存在安全隐患 内存结构图（了解）： 多线程： 并行、并发 并行：多个cpu同时执行多个任务。 并发：一个cpu同时执行多个任务，时间片段 单核、多核 单核：执行多线程时，一个单位时间内只能执行一个线程，只是切换时间特别短，宏观看起来就是同时执行对个线程。 多核：多个内核单位时间内同时执行多个线程。 2、线程创建和使用（重点）多线的使用场景： - 程序需要同时执行多个任务- 程序需要实现一些特殊的等待任务，如：用户输入，文件的读写，网络操作，搜索等需要后台执行的程序时。 线程的创建和启动 两种方式： 继承java.lang.Thread 实现Runnable接口 多线程创建方式一：(继承) 步骤：1. 创建一个继承Thread的子类 重写Thread的Run()方法 创建Thread子类的对象 通过此对象调用start（）方法 示例代码：(输出0-99个数) package com.woniu.thread;//. 创建一个继承Thread的子类class MyThread extends Thread&#123; //2.重写Thread的Run()方法 @Override public void run() &#123; //线程完成的业务逻辑 //输出0-99个数 for (int i = 0; i &lt; 100; i++) &#123; System.out.println( Thread.currentThread().getName() + " ： " + i); &#125; &#125; &#125;public class ThreadTest &#123; //main方法运行后会开启一个主线程 public static void main(String[] args) &#123; //3.创建Thread子类的对象 --- 创建分线程 MyThread t1 = new MyThread(); //4.通过此对象调用start（）方法 t1.start(); //start最后调用run //不能直接调用run(),此刻没有实现多线程调用 //t1.run(); //此刻或抛出IllegalThreadStateException ,不能再次调用start方法，启动线程，必须重写创建线程 //t1.start(); new MyThread().start(); // //输出0-99个数// for (int i = 0; i &lt; 100; i++) &#123;// System.out.println("main：" + i);// &#125; System.out.println("------main-------"); &#125;&#125; 说明： 如果手动调用run（）方法，则是普通方法调用，没有启动多线程 run()方法由jvm调用，什么时候调用，执行过程的控制都有操作系统的CPU调度决定。 启动多线程必须调用start（）方法 一个线程对象只能调用一次start（）方法，如果重复调用则抛出llegalThreadStateException异常 练习： 创建两个分线程，一个输出100之内的偶数，一个输出100之内的奇数。 线程常用方法： 方法名称 说明 getName() 获取线程名称 run() 线程在被调度时执行方法 setName(String name) 设置线程名称 sleep(long millis) 让当前线程指定的毫秒数暂停 start() 启动线程 示例代码： package com.woniu.thread;class MyThread2 extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt;= 100; i++) &#123; if(i % 2 == 0)&#123; try &#123; Thread.sleep(10);// &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + ": " + i); &#125;// if(i % 20 == 0)&#123;// yield(); //释放执行权限，交给cpu，让cpu从新分配资源（切换线程），// //但有可能重新分配给自己// &#125; &#125; &#125;&#125;public class MethodTest &#123; public static void main(String[] args) &#123; MyThread2 t1 = new MyThread2(); //设置分线程名称 t1.setName("线程一 "); t1.start(); //设置主线程名称 Thread.currentThread().setName("主线程："); //主线程业务 for (int i = 0; i &lt; 100; i++) &#123; if(i % 2 != 0) &#123; System.out.println(Thread.currentThread().getName() + ": " + i); &#125; if(i == 20)&#123; try //注意：此刻主线程调用分线程t1 t1.join();//(让步)主线程将执行权限分给t1分线程，直达t1分线程执行完毕后再切换回来继续执行 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; System.out.println(t1.isAlive()); //线程消失 &#125;&#125; 线程调度： 调度策略 时间片：分时段执行 抢占式：高优先级可抢占低优先级的线程 调度方法 同优先级线程组成先进先出队列（先到先服务），使用时间片策略 对高优先级，使用优先调度的抢占式策略 优先级等级 MAX_PRIORITY ：10 MIN _PRIORITY ：1 NORM_PRIORITY ：5 package com.woniu.thread;class ThreadDemo extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; if (i % 2 == 0) &#123; System.out.println( Thread.currentThread().getName() + ":" + Thread.currentThread().getPriority() + ":" + i); &#125; &#125; &#125;&#125;public class PriorityTest &#123; public static void main(String[] args) &#123; // 创建子线程 ThreadDemo t1 = new ThreadDemo(); t1.setName("子线程"); // 设置优先级，只是概率高 t1.setPriority(Thread.MAX_PRIORITY); t1.start(); Thread.currentThread().setName("主线程"); Thread.currentThread().setPriority(Thread.MIN_PRIORITY); for (int i = 0; i &lt; 100; i++) &#123; if (i % 2 == 0) &#123; System.out.println( Thread.currentThread().getName() + ":" + Thread.currentThread().getPriority() + ":" + i); &#125; &#125; &#125;&#125; 演示代码：（三个窗口买票，总票数为100张） package com.woniu.thread;//三个窗口买票，总票数为100张class Window extends Thread &#123; //定义总票数 private static int ticket = 100; @Override public void run() &#123; while(true)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if(ticket &gt; 0)&#123; System.out.println(getName() + "： 买票， 票号为：" + ticket); ticket--; &#125;else &#123; break; &#125; &#125; &#125;&#125;public class WindowTest &#123; public static void main(String[] args) &#123; Window t1 = new Window(); Window t2 = new Window(); Window t3 = new Window(); t1.setName("1号窗口"); t2.setName("2号窗口"); t3.setName("3号窗口"); t1.start(); t2.start(); t3.start(); &#125;&#125; 问题： 每个窗口卖的票数都是100张，可更改为static的方式实现，三个线程卖100张票的情况，但依然出现重票现象。 关于资源共享的问题，可以使用Runnable方式实现。 多线程的创建方式二：（实现Runnable接口） 步骤： 创建一个实现Runnable接口的实现类 重写实现类中的run()方法 创建实现类对象 创建Thread对象，并使用实现类作为Thread构造器的入参对象 调用Thread对象的start（）方法 示例代码：（使用接口实现多线程） package com.woniu.runnable;//1创建一个实现Runnable接口的实现类class MyThared implements Runnable&#123; //2.重写实现类中的run()方法 @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + ": " + i); &#125; &#125; &#125;public class RunnableTest &#123; public static void main(String[] args) &#123; //3.创建实现类对象 MyThared m = new MyThared(); //4.创建Thread对象，并使用实现类作为Thread构造器的入参对象 Thread t = new Thread(m); //5.调用Thread对象的start（）方法 t.start(); Thread t2 = new Thread(m); t2.start(); &#125;&#125; 示例代码：（三个窗口买票，总票数为100张） package com.woniu.runnable;class Window implements Runnable&#123; //总票数 private int ticket = 100; @Override public void run() &#123; while(true)&#123; if(ticket &gt; 0)&#123; System.out.println(Thread.currentThread().getName() + "卖票， 票号为：" + ticket); ticket--; &#125;else &#123; break; &#125; &#125; &#125; &#125;public class WindowTest &#123; public static void main(String[] args) &#123; Window w = new Window(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName("窗口一"); t2.setName("窗口二"); t3.setName("窗口三"); t1.start(); t2.start(); t3.start(); &#125;&#125; 两种方式说明： ​ 相同： ​ 两种方式都需要重写run()方法，需要实现的业务代码都写在run方法中 实现接口的方便之处： ​ 避免的单继承的局限性 ​ 多个线程可以共享同一个接口中的对象，非常适合多线程共享资源的情况 ​ 开发中优先使用 3、线程生命周期（理解）JDK 中用Thread.State 类定义了 线程的几种 新建：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态 就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片此时它已具备了运行的条件，只是没分配到CPU资源 运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能 阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态 死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束 线程生命周期; 4、线程同步（重点）问题： - 多个线程执行的不确定性引起的结果不稳定- 多个线程对同一资源的共享，会造成操作的不完整性，破坏数据 示例代码： package com.woniu.runnable;class Window implements Runnable&#123; //总票数 private int ticket = 100; @Override public void run() &#123; while(true)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if(ticket &gt; 0)&#123; System.out.println(Thread.currentThread().getName() + "卖票， 票号为：" + ticket); ticket--; &#125;else &#123; break; &#125; &#125; &#125; &#125;public class WindowTest &#123; public static void main(String[] args) &#123; Window w = new Window(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName("窗口一"); t2.setName("窗口二"); t3.setName("窗口三"); t1.start(); t2.start(); t3.start(); &#125;&#125; 问题： 买票过程中出现了错票和重票---线程安全问题 当某个线程再操作车票的过程中，尚未完成，其他线程也参与进来，所以也操作车票。 当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有 执行完，另一个线程参与进来执行。导致共享数据的错误 如何解决： 对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行 当一个线程使用操作ticke的时候，其它线程先不参与进来，直到操作完成其他线程再参与进来，也就是说在多线程在操作同一个资源时要排队。 使用同步代码块或同步方法解决 Synchronized的使用： java对于多线程的安全问题提供了专业的解决方式：同步机制（锁） 使用方式： ​ 同步代码块： ​ synchronized(对象) { ​ //需要被同步的代码 ​ } 示例代码：（线程同步，同步代码块，使用Runnable接口） package com.woniu.runnable;class Window implements Runnable&#123; //总票数 private int ticket = 100; private Object obj = new Object(); @Override public void run() &#123; while(true)&#123;// try &#123;// Thread.sleep(100);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125; //注意线程同步必须使用同一把锁 //synchronized (obj) &#123; synchronized (this) &#123; if (ticket &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + "卖票， 票号为：" + ticket); ticket--; &#125; else &#123; break; &#125; &#125; &#125; &#125; &#125;public class WindowTest &#123; public static void main(String[] args) &#123; Window w = new Window(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName("窗口一"); t2.setName("窗口二"); t3.setName("窗口三"); t1.start(); t2.start(); t3.start(); &#125;&#125; 示例代码：（线程同步，同步代码块，使用继承Thread） package com.woniu.syn;class Window2 extends Thread &#123; // 总票数 private static int ticket = 100; private static Object obj = new Object(); @Override public void run() &#123; while (true) &#123; //synchronized (this) &#123; synchronized (Window2.class) &#123; //this代表t1,t2,t3,不能使用 if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "卖票， 票号为：" + ticket); ticket--; &#125; else &#123; break; &#125; &#125; &#125; &#125;&#125;public class WindowTest2 &#123; public static void main(String[] args) &#123; Window2 t1 = new Window2(); Window2 t2 = new Window2(); Window2 t3 = new Window2(); t1.setName("窗口一"); t2.setName("窗口二"); t3.setName("窗口三"); t1.start(); t2.start(); t3.start(); &#125;&#125; 说明： 操作共享的数据代码，即需要被同步的代码 共享数据：多个线程需要共同操作的变量，比如我们的ticket变量 同步监视器：俗称锁，任何一个类的对象都可以充当锁 多个线程必须用一把锁 使用接口的方式的多线程，可考虑使用this当“锁”，使用继承的方式可考虑使用当前class对象当“锁” 同步方式解决的线程安全问题 同步方式在操作代码时，只能有一个线程参与，其他线程只能等待，相当于一个单线程的过程，效率低 2.使用同步方法实现同步机制： 当同步的行为可以封装为一个方法时，就可以使用同步方法的方式 示例代码：（使用接口） package com.woniu.syn;class Window3 implements Runnable &#123; // 总票数 private int ticket = 100; @Override public void run() &#123; while (true) &#123; print(); &#125; &#125; //同步方法 private synchronized void print() &#123; //同步监视器(锁)？this if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "卖票， 票号为：" + ticket); ticket--; &#125; &#125;&#125;public class WindowTest3 &#123; public static void main(String[] args) &#123; Window3 w = new Window3(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName("窗口一"); t2.setName("窗口二"); t3.setName("窗口三"); t1.start(); t2.start(); t3.start(); &#125;&#125; 示例代码:（使用继承） package com.woniu.syn;class Window4 extends Thread &#123; // 总票数 private static int ticket = 100; @Override public void run() &#123; while (true) &#123; print(); &#125; &#125; private static synchronized void print()&#123; //锁是Window4.class if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "卖票， 票号为：" + ticket); ticket--; &#125; &#125;&#125;public class WindowTest4 &#123; public static void main(String[] args) &#123; Window4 t1 = new Window4(); Window4 t2 = new Window4(); Window4 t3 = new Window4(); t1.setName("窗口一"); t2.setName("窗口二"); t3.setName("窗口三"); t1.start(); t2.start(); t3.start(); &#125;&#125; 单例设计模式：（懒汉模式，线程安全） package com.woniu.designpatterns;/** * 单例模式(饿汉模式) * (懒汉模式) * @author Administrator * */public class Singleton &#123; //静态只有一份singleton //private static Singleton singleton = new Singleton(); private static Singleton singleton = null; //new Singleton(); private Singleton()&#123; &#125; //获取当前类的实例 public static Singleton getInstance()&#123; //改进： //方式一：// synchronized (Singleton.class) &#123; // if(singleton == null)&#123; // singleton = new Singleton();// &#125;// return singleton;// &#125; //方式二：效率高 if(singleton == null)&#123; synchronized (Singleton.class) &#123; if(singleton == null)&#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 死锁： 不同的线程分别占用对方需要的同步的资源不放弃，都在等待对象放弃自己需要的同步资源，就形成了线程的死锁， 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都出于阻塞状态，无法继续 package com.woniu.deadlock;public class DeadLockTest &#123; public static void main(String[] args) &#123; StringBuffer s1 = new StringBuffer(); StringBuffer s2 = new StringBuffer(); //分线程1 new Thread() &#123; @Override public void run() &#123; synchronized (s1) &#123; s1.append("a"); s2.append("1"); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (s2) &#123; s1.append("b"); s2.append("2"); System.out.println(s1); System.out.println(s2); &#125; &#125; &#125;; &#125;.start(); //分线程2 new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (s2) &#123; s1.append("c"); s2.append("3"); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (s1) &#123; s1.append("d"); s2.append("4"); System.out.println(s1); System.out.println(s2); &#125; &#125; &#125; &#125;).start(); &#125;&#125; 解决方案： ​ 专门的算法 ​ 尽量减少同步资源的定义 ​ 尽量避免嵌套同步 5、线程通信 线程执行时互相交换执行。 示例代码： package com.woniu.comm;//让两个线程交替打印数字class PrintCount implements Runnable&#123; private int num = 1; @Override public void run() &#123; while(true)&#123; synchronized (this) &#123; //notify(); //唤醒线程 notifyAll(); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + ": " + num); num++; if(num &gt;= 30)&#123; break; &#125; try &#123; wait(); //线程等待，释放锁，object类中的方法， &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;public class CommTest &#123; public static void main(String[] args) &#123; PrintCount count = new PrintCount(); Thread t1 = new Thread(count); Thread t2 = new Thread(count); Thread t3 = new Thread(count); t1.setName("A"); t2.setName("B"); t3.setName("C"); t1.start(); t2.start(); t3.start(); &#125;&#125; 说明： wait() ：执行到wait（）当前线程排队阻塞（等待），并释放同步监视器notify()：执行到notify（）唤醒正在排队的阻塞线程，优先级最高的先唤醒notifyAll (）：唤醒正在排队等待资源的所有线程结束等待 这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报java.lang.IllegalMonitorStateException异常 这三个方法必须是同一个同步监视器 这三个方法是定义在java.lang.Object对象当中的 经典例题：生产者/消费者问题 问题描述： 生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处获取一定数量的产品店员一次只能持有固定数量的产品如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。 分析问题： ​ 1、是否为多线程？是。生产者线程、消费者线程 2、是否有数据共享？有。店员手中的产品 3、如何解决线程安全？使用同步机制（锁） 4、是否涉及线程通信？ 是 package com.woniu.product;class Clerk &#123; private int productCount = 1; //添加产品 public synchronized void addProduct()&#123; if(productCount &lt; 20)&#123; productCount++; System.out.println(Thread.currentThread().getName() + ": 开始生产第" + productCount + "个产品"); notify(); &#125;else &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //消费产品 public synchronized void getProduct()&#123; if(productCount &gt; 0)&#123; System.out.println(Thread.currentThread().getName() + ": 消费者开始消费第" + productCount + "个产品"); productCount--; notify(); &#125;else &#123; //等待 try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;//生产者线程class Producer implements Runnable &#123; private Clerk clerk; public Producer(Clerk clerk) &#123; this.clerk = clerk; &#125; @Override public void run() &#123; //创建产品 System.out.println("生產者生产产品 ： "); while(true)&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; clerk.addProduct(); &#125; &#125; &#125;//消费者线程class Consumer implements Runnable &#123; private Clerk clerk; public Consumer(Clerk clerk) &#123; this.clerk = clerk; &#125; @Override public void run() &#123; //消费产品 System.out.println("消费者消费产品："); while(true)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; clerk.getProduct(); &#125; &#125; &#125;public class ProductTest &#123; public static void main(String[] args) &#123; Clerk c = new Clerk(); Thread t1 = new Thread(new Producer(c)); t1.setName("生产者"); Thread t2 = new Thread(new Consumer(c)); t2.setName("消费者"); t1.start(); t2.start(); &#125;&#125;]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java07IO流]]></title>
    <url>%2Fjava07IO%E6%B5%81%2F</url>
    <content type="text"><![CDATA[I/O流1、File类的使用 java.io.File类：文件或文件夹的抽象表示形式，与平台无关。 File能新建，删除、重命名文件和目录，但不能访问文件本身。如果需要访问文件内容，则需要输入/输出流 File对象可以作为参数传递给IO流的构造器 File对象可以不对应真实存在的文件或文件夹 File的构造器： 构造器 描述 File(String pathname) 根据路径获取File对象 File(String parent, String child) File(File parent, String child) 示例代码： File f1 = new File("hello.txt"); //相对路径，以当前的文件所在的工程为相对路径的起点f1 = new File("E:\\workspace\\java_io\\hello.txt"); //绝对路径System.out.println(f1);//hello.txtSystem.out.println(f1.exists()); //true//构造器2 \表示转义符File f2 = new File("E:\\workspace\\java_io","hello.txt");System.out.println(f2.exists());//true//构造器3File f3 = new File(new File("E:\\workspace\\java_io"),"hello2.txt");System.out.println(f3.exists()); //false 常用方法： File f1 = new File("hello.txt");File f2 = new File("java\\javaee\\hello.txt");System.out.println(f1.getAbsolutePath()); //获取完整的路径System.out.println(f1.getPath()); //相对路径System.out.println(f1.getParent()); //上级路径System.out.println(f1.length()); //文件的字节数System.out.println(new Date(f1.lastModified())); //修改时间System.out.println("---------------");System.out.println(f2.getAbsolutePath());System.out.println(f2.getPath());System.out.println(f2.getParent());System.out.println(f2.length()); 常用方法2： File f = new File("E:\\workspace");String[] list = f.list(); //遍历当前目录下的所有文件和文件夹for (int i = 0; i &lt; list.length; i++) &#123; String fileName = list[i]; System.out.println(fileName);&#125;System.out.println("-------------");File[] listFiles = f.listFiles();for (int i = 0; i &lt; listFiles.length; i++) &#123; File file = listFiles[i]; System.out.println(file);&#125; 2、IO流的原理和使用 I/O是Input/Output的缩写，用于处理设备之间的数据传输，如：读/写文件, 网络通信。 java.io包下提供了各种“流”类和接口 输入(input)：读取外部数据（硬盘、网络等外部存储设备）到程序（内存）中（读） 输出（output）：将程序（内存）数据输出到外部存储设备（硬盘、网络等）中（写） 2.1、流的分类 我们对IO流一般会从3个维度进行描述 根据流的方向：输出、输出 根据流的大小：字节、字符 根据流的角色：（功能越来越强大） 节点（文件流）， 处理流 四个抽象基类 字节流 字符流 输入流 InputStream Read 输出流 OutputStream Writer 流的体系： 这些所有的流都是这4个基类的实现类 3、节点流 文件流 缓冲流(处理流的一种) FileInputStream BufferedInputStream FileOutputStream BufferedOutputStream FileReader BufferedReader FileWriter BufferedWriter 字符流读文件： 示例代码：（） FileReader reader = null; try &#123; // 1.创建File类对象，指向操作的文件 File file = new File("hello.txt"); // 2.创建具体的流,读文本（字符流，输入） reader = new FileReader(file); // 3.读数据 read() : 返回读入的一个字符, 返回-1读取完毕// int data = reader.read();// while (data != -1) &#123;// System.out.println((char) data);// data = reader.read();// &#125; //方式二: int data; while( (data = reader.read()) != -1)&#123; System.out.println((char)(data)); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 不能自动回收gc try &#123; if (reader != null) &#123; reader.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 示例代码： FileReader r = null; try &#123; // 1.創建File对象 File file = new File("hello.txt"); // 2.创建流 r = new FileReader(file); // 3.读数据 char[] cs = new char[3]; //缓存的大小 int len; //读取的字符数 while ((len = r.read(cs)) != -1) &#123; //错误方式// for (int i = 0; i &lt; cs.length; i++) &#123;// System.out.print(cs[i] + " ");// &#125; //正确方式一// for (int i = 0; i &lt; len; i++) &#123;// System.out.print(cs[i] + " ");// &#125; //正确方式二 String str = new String(cs, 0, len); System.out.println(str); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125;finally &#123; r.close(); &#125; 总结： read（）理解：返回读入的一个字符，如果达到末尾，返回-1 读取的文件一定要存在，否则报异常FileNotFoundException 为了保证资源合理利用，必须使用try-catch-finally关闭资源 字符流的写： 示例代码： //1.创建File对象 File file = new File("hello2.txt"); //文本可以不存在 //2.获取字符输出流 默认false：覆盖 ， true：追加 FileWriter writer = new FileWriter(file); //3.写 writer.write("红红的太阳，蓝蓝的天"); writer.write("admin"); //4.关 writer.close(); //创建File File srcFile = new File("hello.txt"); File destFile = new File("hello3.txt"); //字符流不能读取和写入图片 --- 非文本数据 //File srcFile = new File("123.jpg"); //File destFile = new File("456.jpg"); //创建流 FileReader re = new FileReader(srcFile); FileWriter wr = new FileWriter(destFile); //数据读写操作 char[] cbuf = new char[5]; int len; //记录每次读取的字符个数 while((len = re.read(cbuf)) != -1)&#123; //读取的数据临时保存到cbuf缓存中 //写 --- 每次写len个字符 wr.write(cbuf, 0, len); &#125; //关闭资源 if(wr != null)&#123; wr.close(); &#125; if(re != null)&#123; re.close(); &#125; 总结： 输出操作，对应的File可以不存在，不会报错，会自动生成对应的文件 FileWriter(file ，false) ： 对原有文件进行覆盖（默认） FileWriter(file ，true)：对原有文件进行追加 字节流读文件 示例代码：（字符流读取信息） //1造文件 File f = new File("hello.txt"); //2造流 FileInputStream input = new FileInputStream(f); //3读文件 byte[] bs = new byte[3]; //缓存字节数 int len; //返回读取得字节总数，读取的数据放入bs缓存中 while((len = input.read(bs)) != -1)&#123; //中文显示默认2个字节保存 String str = new String(bs, 0, len); //将字节组装为string System.out.println(str); &#125; //关闭资源 input.close(); 示例代码：（复制图片） //1.创建File File srcFile = new File("123.jpg"); File destFile = new File("456.png"); //2.创流 FileInputStream inputStream = new FileInputStream(srcFile); FileOutputStream outputStream = new FileOutputStream(destFile); //3读写 byte[] buffer = new byte[1024]; int len; while((len = inputStream.read(buffer)) != -1)&#123; //写 outputStream.write(buffer, 0, len); &#125; //4.关 inputStream.close(); outputStream.close(); 总结： 文本文件（.txt, java,c.cpp等），使用字符流处理 非文本文件：使用字节流处理 （图片，视频...） 4、缓存流 为了提高数据的读取效率，javaAPI提供了带缓冲功能的流，在使用这些流类时，会创建一个内部缓冲区数组，缺省使用8192个字符（8kb）缓存区 示例代码： //1.创建File类// File f = new File("123.jpg");// File f2 = new File("789.jpg");// //2.造流// FileInputStream input = new FileInputStream(f);// FileOutputStream out = new FileOutputStream(f2); //3.包装 --- 可以嵌套 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(new File("123.jpg"))); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(new File("789.jpg"))); //4.操作 --- 读写 byte[] buffer = new byte[10]; int len; while(( len = bis.read(buffer)) != -1)&#123; bos.write(buffer, 0, len); &#125; //5关 --- 先关外部的包装类, 内部的也会关联关闭 bis.close(); bos.close(); 5、 转换流 转换流提供了在字节流和字符流之间的转换 很多时候我们使用转换流来处理文件乱码问题，实现编码和解码的功能 如果字节流中的数据都是字符类型时，转成字符流效率更高 名称 作用 方向 InputStreamReader 将InputStream转换为Reader 字节 ---》字符 OutputStreamWriter 将Writer转换为OutputStream 字符---》字节 示例代码： //1、创建输入流 FileInputStream inputStream = new FileInputStream("db.txt"); //2、转换 字节流转换为字符流 InputStreamReader reader = new InputStreamReader(inputStream); //使用系统默认编码格式 reader = new InputStreamReader(inputStream, "UTF-8"); //3、读取操作 char[] buffer = new char[3]; int len; while((len = reader.read(buffer)) != -1)&#123; String str = new String(buffer, 0, len); System.out.println(str); &#125; //4关闭资源 reader.close(); //内层关联关闭 示例代码： //1创建流 FileInputStream input = new FileInputStream("db.txt"); FileOutputStream out = new FileOutputStream("db_2.txt"); //2转换流 InputStreamReader reader = new InputStreamReader(input); OutputStreamWriter writer = new OutputStreamWriter(out); //3读写 char[] buffer = new char[10]; int len; while((len = reader.read(buffer)) != -1)&#123; writer.write(buffer, 0, len); &#125; //4.关闭 reader.close(); writer.close(); 总结： 解码：字节/字节数组 ---》 字符数组/字符串 编码：字符数组/字符串 ---》字节、字节数组 6. 对象序列化 序列化：用ObjectOutputStream类保存基本类型数据或对象。 反序列化：使用ObjectInputStream类读取基本类型数据或对象 不能序列化static和transient修饰的成员变量 对象序列化机制允许把内存中的对象转换成与平台无关的二进制流。从而把这种二进制数据保存在硬盘中。获取通过网络将这种二进制数据传输到另一个网络节点。当程序获取到这种二进制流，就可以恢复成原来java对象。 对象序列化需要实现Serializable接口 序列化的步骤： 创建ObjectOutputStream 调用ObjectOutputStream的writerObjet（）方法可输出序列化对象 操作flush 反序列化步骤： 创建ObjectInputStream 调用ObjectInputStrea的Readobject()方法读取流中的对象 示例代码： class Person implements Serializable&#123; private static final long serialVersionUID = 1L; private String name; private int age; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + "]"; &#125; &#125; //创建处理流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("object.dat")); //序列化 //oos.writeObject(new String("测试信息")); // oos.writeObject(new Person("admin",20)); oos.flush(); //创建处理流ObjectInputStream ois = new ObjectInputStream(new FileInputStream("object.dat"));//反序列化Person p = (Person) ois.readObject();System.out.println(p);]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java06异常]]></title>
    <url>%2Fjava06%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[异常为什么高级语言会出现异常： - 因为程序出错是不可避免的，所以为了提高程序的健壮性，所以所有的高级语言都添加了异常的处理方式，被称为异常处理机制- 注意开发过程中的逻辑错误和语法错误不是异常 1、异常概述java把异常分为两大类： Error ： jvm无法处理和解决的严重问题。（类似重大交通事故） Exception：可以处理 java.lang.Error 实例代码： //java.lang.StackOverflowError : 栈溢出test();//java.lang.OutOfMemoryError: 内存溢出Integer[] arr = new Integer[1024 * 1024 * 1024]; java.lang.Exception 偶然出现的编程错误导致的一般性问题，可以使用异常机制进行处理，目的是让程序能够处理“错误”，提高程序的健壮性，看起来比较智能。 处理方式： 1. 遇到错误终止程序 处理错误，给出提示，继续运行 捕捉错误的时机： - 编译时期：编译时出现的错误，需要事先强制处理错误（checked）- 运行时期：运行时出现的错误（unchecked） 异常体系 java.lang.Throwable java.lang.Error：不做处理 java.lang.Exception：处理 2、常见的异常类型面试常问：需要记住 编译时期异常：（checked） IOException FileNotFoundException ClassNotFoundException 运行时期异常：（unchecked，java.lang.RuntimeException） NullPointException ArrayIndexOutOfBoundsException ClassCastException NumberFormatException InputMismatchException ArithmeticException 示例代码： // //java.lang.NullPointerException// String str = null;// System.out.println(str.length());// // //ArrayIndexOutOfBoundsException// String[] arr = new String[4];// System.out.println(arr[5]); //ClassCastException// Object obj = new Date();// String str2 = (String)obj; //NumberFormatException // int num = Integer.parseInt("abc"); //InputMismatchException// Scanner input = new Scanner(System.in);// System.out.println("请输入一个数");// int res = input.nextInt();// input.close(); //ArithmeticException int res = 10 / 0; 3、处理异常3.1、异常处理模型：抓抛模型 抓取：进行异常处理 方式一：try-catch-finally 方式二：throws + 异常类型 抛出：程序在运行的过程中一但出现异常，就会在异常出现的地方生成异常对象，并将此抛出，其后代码不在运行。 3.2 、处理方式方式一： try-catch-finally（自己处理） 语法结构： try { ​ //可能出现异常的代码 } catch(异常类型 变量名称) { ​ //处理异常代码 } catch（异常类型 变量名称） { ​ //处理异常代码 } ... { }finally { //可选择 //一定执行的代码 } 示例代码： String str = "123";str = "abc";try &#123; int num = Integer.parseInt(str); //没有机会执行 Object obj = new Date(); String str2 = (String)obj; System.out.println("num = " + num);&#125;catch(NullPointerException e)&#123; System.out.println("NullPointerException --- ");&#125;catch(NumberFormatException e) &#123; //System.out.println(e.getMessage()); //异常对象信息// e.printStackTrace(); //异常堆栈信息 System.out.println("NumberFormatException----");&#125;catch(Exception e)&#123; System.out.println("Exception --- ");&#125;System.out.println("执行 ---------- "); 说明： - try将可能出现的异常代码包含起来，一但代码出现异常将会在出现异常的地方生成异常对象并抛给系统，之后跳转到catch区域- catch则可以根据是否匹配（对应的类型或子类）捕捉到异常对象，再进行异常代码的处理- 处理完异常代码逻辑跳出try-catch块执行剩余的代码，（可能不会执行所有的catch块）- 在try-catch声明的变量不能跳出该结构被找到，所以有时候需要在try-catch块之外- try-catch将编译时出现的异常推迟到运行时异常处理，但仍然可能出错，所以在开发中运行时异常我们一般不做处理。 演示代码：（finally） try &#123; int num1 = 10; int num2 = 0; int res = num1 / num2; &#125;catch(ArithmeticException e)&#123; System.out.println(e.getMessage()); //继续抛出异常 System.out.println(Integer.parseInt("abc")); &#125;finally &#123; System.out.println("一定会执行 --- "); &#125; 演示代码：（return执行） @Test public void test4()&#123; System.out.println(method()); &#125; //演示return也执行 public int method()&#123; try &#123; int[] nums = new int[2]; System.out.println(nums[3]); return 0; &#125;catch(IndexOutOfBoundsException e)&#123; e.printStackTrace(); return 1; //执行在finally之后 &#125;finally&#123; System.out.println("一定会执行 --- "); &#125; &#125; 演示代码：（资源释放） FileInputStream input = null;try &#123; //File类代表一个文件/文件夹 File file = new File("hello.txt"); //创建流，建立“管道”，将文本读取到内存 input = new FileInputStream(file); //读取hello.txt文件信息 int data = input.read(); while(data != -1)&#123; //判断文件内容是否存在 System.out.print((char)data); data = input.read(); &#125;&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125;finally &#123; //关闭资源 if(input != null)&#123; try &#123; input.close();//关闭资源 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 说明： finally声明的语句一定会被执行，即使catch中出现异常，或try-catch中有return语句也会被执行 通常jvm不能够及时回收的资源可放入finally语句中，比如：数据库连接，输入输出流等资源的释放 方式二：throws + 异常类型 （别的方法处理） public void test6() &#123; try &#123; method2(); //调用者处理异常 &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //声明抛出异常，谁调用谁处理 public void method2() throws IOException &#123; FileInputStream input = null; try &#123; // File类代表一个文件/文件夹 File file = new File("hello.txt"); // 创建流，建立“管道”，将文本读取到内存 input = new FileInputStream(file); // 读取hello.txt文件信息 int data = input.read(); while (data != -1) &#123; // 判断文件内容是否存在 System.out.print((char) data); data = input.read(); &#125; &#125; finally &#123; input.close();// 关闭资源 &#125; &#125; 说明： 写方法声明时可以说明此方法执行时会被抛出的异常 此方法没有真正处理异常，只给抛出调用者来处理 3.3. 开发中选择try-catch或throws注意事项public class OverrideTest &#123; public void display(SuperClass sup)&#123; try &#123; sup.method(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class SuperClass &#123; public void method() throws IOException &#123; &#125;&#125;class subClass extends SuperClass &#123; public void method() throws FileNotFoundException &#123; &#125;&#125; 说明： 如果父类中被重写的方法没有throws异常，则子类重写的方法也不能抛出异常，子类只能try-catch处理 子类重写的方法抛出的异常必须是父类的同类型或子类类型 4、 手动生成异常（throw）示例代码： public class StudentTest &#123; public static void main(String[] args) &#123; Student stu = new Student(); try &#123; stu.regist(-100); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Student&#123; private int id; public void regist(int id) throws Exception&#123; if(id &gt; 0)&#123; this.id = id; &#125;else &#123; //System.out.println("输出数据有误"); //手动抛出异常 throw new Exception("输出数据有误"); &#125; &#125;&#125; 5、 自定义异常示例代码： public class MyException extends Exception &#123; private static final long serialVersionUID = 1L; public MyException() &#123; super(); &#125; public MyException(String message) &#123; super(message); &#125;&#125; 用户自定义异常类都是RuntimeException的子类 自定义异常类通常需要编写几个重载的构造器 自定义异常类需要提供serialVersionUID 自定义的异常通过throw抛出 总结：]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java05集合]]></title>
    <url>%2Fjava05%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[集合1、集合框架概述 java中为了对多个对象进行操作，就需要对多个对象进行存储，针对Array的弊端，Java集合就创建一个“容器”，可以动态的把多个对象的引用放入容器中。 java集合类就是对多个对象进行存储的操作类，存储的类型可以是单个对象，也可以是关联对象。 注意Java集合中存储的对象在内存中，如果存储在硬盘中的叫做“持久化操作” Java集合分为两种不同的体系： Collection：单值接口操作 List：接口：元素有序，可重复 ---“动态”数组 ArrayList、LinkedList、Vector Set：接口：元素无序，不可重复 --- “高中集合” HashSet、LinkedHashSet、TreeSet Map：键值操作接口、有key---value组成 --- “高中函数y = f（x）” HashMap、LinkedHashMap、TreeMap、Hashtable、Properties 2、Collection接口 Collection接口不提供任何实现类，而是提供更加具体的子接口 在JDK5之前，集合会丢失容器中所放入的对象的类型，会把所有放入的对象都当成Object类型处理，从1.5之后增加了泛型，则Java集合可以记住容器中的对象的数据类型。 2.1、collection接口体系： 2.2、常用方法：（API）演示代码：（） //通过ArrayList创建对象Collection coll = new ArrayList();//add(E e) //Object e：添加元素coll.add("AA");coll.add("BB");coll.add(123); //自动装箱coll.add(new Date());//size() ：获取集合中元素的个数System.out.println(coll);System.out.println("集合中元素个数： " + coll.size()); //4//将coll2中的所有元素添加到指定集合中//addAll(Collection&lt;? extends E&gt; c)Collection coll2 = new ArrayList();coll2.add(456);coll2.add("cc");coll.addAll(coll2);System.out.println(coll);System.out.println("集合中元素个数： " + coll.size()); //6// clear() ： 清空集合中的元素coll.clear();System.out.println(coll);System.out.println("集合中元素个数： " + coll.size()); //0//isEmpty():判断当前集合是否为空System.out.println(coll.isEmpty()); 实例代码：（contains(Object o)、containsAll(Collection&lt;?&gt; c)） Collection coll = new ArrayList();coll.add(123);coll.add(456);coll.add(new String("Tom"));coll.add(false);Person p = new Person("小王", 20);coll.add(p);// 1、contains(Object o) : 判断当前集合中是否包含指定的元素,判断对象相等会调用对象所在类的equals()方法// boolean contains = coll.contains(123);// System.out.println(contains);// boolean contains2 = coll.contains(new String("Tom"));// 添加p對// System.out.println(contains2); // true// boolean contains3 = coll.contains(p);// System.out.println(contains3); // trueboolean contains4 = coll.contains(new Person("小王", 20));System.out.println(contains4); // false: 调用的是父类（object的equals方法使用是==比较） // true : 重写父类的equals方法：属性相同就相同//2、containsAll(Collection&lt;?&gt; c) :判断coll2集合中的所有元素是否在某个集合中存在Collection coll2 = Arrays.asList(123,456);System.out.println(coll.containsAll(coll2)); 在Collection接口中的添加object类型的对象时，要求所在的类重写equals方法 集合在判断相同元素时会调用所在类的equals方法判断是否相同 示例代码：(remove(Object o),removeAll(Collection&lt;?&gt; c)) Collection coll = new ArrayList();coll.add(123);coll.add(456);coll.add(new String("Tom"));coll.add(false);Person p = new Person("小王", 20);coll.add(p);coll.remove(123);System.out.println(coll);//remove(Object o)coll.remove(new Person("小王", 20));System.out.println(coll);//removeAll(Collection&lt;?&gt; c)Collection coll2 = Arrays.asList(123,456);coll.removeAll(coll2);System.out.println(coll); 示例代码：(equals(Object o),)retainAll(Collection&lt;?&gt; c) Collection coll = new ArrayList();coll.add(123);coll.add(456);coll.add(new String("Tom"));coll.add(false);Person p = new Person("小王", 20);coll.add(p);// System.out.println(coll);// //retainAll(Collection&lt;?&gt; c):获取交集// Collection coll2 = Arrays.asList(123,456);// coll.retainAll(coll2);// System.out.println(coll);//equals(Object o)Collection coll2 = new ArrayList();coll2.add(123);coll2.add(456);coll2.add(new String("Tom"));coll2.add(false);Person p2 = new Person("小王", 20);coll2.add(p2);//传递的集合和本身的集合要完全相同，返回tureboolean res = coll.equals(coll2); //判断集合中的元素是否完全相同System.out.println(res); 示例代码： Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new String("Tom")); coll.add(false); Person p = new Person("小王", 20); coll.add(p); //hashCode()：返回当前对象的哈希值 System.out.println(coll.hashCode()); //? //集合 ---&gt; 数组 Object[] objs = coll.toArray(); for (int i = 0; i &lt; objs.length; i++) &#123; System.out.println(objs[i]); &#125; //扩展: 数组 ---&gt;集合 List&lt;String&gt; list = Arrays.asList(new String[]&#123;"a","b","c"&#125;); System.out.println(list); // size() System.out.println(coll.size()); 3、Iterator迭代器接口 Iterator对象称为迭代器（设计模式），主要用于遍历Collection集合中的元素 迭代器模式是为容器而生。 Collection接口继承了java.lang.Iterable接口 Iterator仅用于遍历集合，本身不提供承装对象的能力，如果需要创建Iterator对象，则必须有需要迭代的集合 集合对象每次调用iterator（）方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前 迭代器执行原理: 示例代码：(使用迭代器变量元素) Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new String("Tom")); coll.add(new String("Jac")); coll.add(false); //获取迭代器对象 Iterator iterator = coll.iterator(); //方式一： System.out.println(iterator.next()); System.out.println(iterator.next()); System.out.println(iterator.next()); System.out.println(iterator.next()); System.out.println(iterator.next()); System.out.println(iterator.next()); //没有元素抛出NoSuchElementException //方式二： //iterator.hasNext() ：判断是否有下一个元素 while(iterator.hasNext())&#123; //next：1、将指针下移，2、将下移后当前位置中的元素返回 System.out.println(iterator.next()); &#125; 示例代码：（深刻理解迭代器） Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new String("Tom")); coll.add(new String("Jack")); coll.add(false); //错误的方式// Iterator iterator = coll.iterator();// while(iterator.next() != null)&#123; //每次next都有移动指针// System.out.println(iterator.next());// &#125; //错误方式 ：每次iterator都会获取新的迭代器 while(coll.iterator().hasNext())&#123; System.out.println(coll.iterator().next()); &#125; 示例代码：（iterator中的remove） Collection coll = new ArrayList();coll.add(123);coll.add(456);coll.add(new String("Tom"));coll.add(new String("Jack"));coll.add(false);//删除TomIterator iterator = coll.iterator();while(iterator.hasNext())&#123; //iterator.remove(); //报错：IllegalStateException Object object = iterator.next(); if("Tom".equals(object))&#123; iterator.remove(); //iterator.remove();报错 &#125;&#125;System.out.println(coll); Iterator可以删除集合中的元素，但是在遍历过程中通过迭代器对象的remove()方法不是集合中的remove方法 如果还未调用next（）方法或多次调用remove方法都会报错 使用foreach循环遍历集合元素 jdk1.5之后提供了foreach循环迭代访问Collection和数组 foreach底层使用的迭代器方式 示例代码： Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new String("Tom")); coll.add(new String("Jack")); coll.add(false); //for(数据类型 变量：数组/集合) for(Object obj : coll)&#123; System.out.println(obj); &#125; int[] arr = new int[]&#123;1,2,3,4,5&#125;; //方式一： for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; //方式二：增强for循环 for(int i : arr)&#123; System.out.println(i); &#125; 思考题： String[] arr = new String[] &#123; "mm", "mm", "mm" &#125;;// 方式一：// for (int i = 0; i &lt; arr.length; i++) &#123;// arr[i] = "GG";// &#125;// 方式二：for (String str : arr) &#123; str = "GG"; //&#125;for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]);&#125; 4、List接口4.1、List概述 List集合有序，可重复。可看成“动态”数组，代替原来的数组 核心实现类： ArrayList、 LinkedList Vector 核心实现类特点：（面试内容） ArrayList：作为List接口的主要实现类、线程不安全、效率高。底层使用Object[]数组实现存储 LinkedList：底层使用双向链表存储数据，如果频繁添加，删除，插入元素则效率较高 Vector：古老的实现类、甚至出现在List接口之前，线程安全。效率低。底层使用Object[]数组实现存储 4.2、源码分析ArrayList源码： /*** Constructs an empty list with an initial capacity of ten.默认构造器器*/public ArrayList() &#123;this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;//内部默认创建object[]数组保存数据/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */transient Object[] elementData; // non-private to simplify nested class access//jdk1.8初始状态创建了空&#123;&#125;数组/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;//向集合中添加元素/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; //添加调用的方法 ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; //参数 1 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); //获取10 &#125; //调用扩容方法 ensureExplicitCapacity(minCapacity);&#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) //扩容方法 grow(minCapacity); &#125;//扩容的执行算法/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; ArrayList底层使用Object[]数组来存储数据， add()添加元素、底层才初始数组长度，初始化数组的长度为10 每次扩充容量为1.5倍 LinkedList源码： /** * Pointer to first node. * Invariant: (first == null &amp;&amp; last == null) || * (first.prev == null &amp;&amp; first.item != null) */ transient Node&lt;E&gt; first; //第一个节点 /** * Pointer to last node. * Invariant: (first == null &amp;&amp; last == null) || * (last.next == null &amp;&amp; last.item != null) */ transient Node&lt;E&gt; last; //最后一个节点 private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; //下一个节点 Node&lt;E&gt; prev; //上一个节点 //element：内容 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125;//添加元素的算法/** * Links e as last element. */ void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; &#125; LinkedList创建对象时，内部声明了Node类型的fist属性和last属性，默认为null add（）添加，将内容添加到新建的node节点中，再讲新建的node和原来的建立关联 其中node创建方式体现了双向链表的结构 Vector分析： 创建Vector对象时，底层都使用了长度为10的数组，再扩容方式上和List一样，，默认每次扩容2倍 面试题： ArrayList、LinkedList、Vector的异同，谈谈你的理解 4.3、常用方法(collection之外的方法)示例代码： //ArrayList list = new ArrayList();list.add(123);list.add(456);list.add("abc");list.add(123);System.out.println(list);//在指定位置添加元素list.add(1, "bbb");System.out.println(list);//获取指定位置的元素Object obj = list.get(5); //不能超出下标最大值System.out.println(obj); 示例代码： ArrayList list = new ArrayList(); list.add(123); list.add(456); list.add("abc"); list.add(123); list.add(new Person("admin", 20)); // //获取集合中首次出现的元素的位置// int i = list.indexOf(123);// System.out.println(i);// //获取集合中最后一次出现的元素的位置// int lastIndexOf = list.lastIndexOf(123);// System.out.println(lastIndexOf);// // //返回删除的对象// Object remove = list.remove(3);// System.out.println(remove);// // boolean remove2 = list.remove("abc");// System.out.println(remove2);// System.out.println(list);// // boolean remove3 = list.remove(new Person("admin", 20));// System.out.println(remove3);// System.out.println(list); //修改的效果 list.set(1, "cc"); System.out.println(list); //获取指定区间的元素[ ) List subList = list.subList(2, 4); System.out.println(subList); System.out.println(list); 总结： 增加：add(object obj)、 删：remove(int index)、remove(Object obj) 改：set（int index, object obj） 查：get(int index) 插入：add(int index, Object obj) 长度：size() 遍历： Iterator：迭代器 增强for循环 普通for 循环 面试题： //删除时注意下标和对象的区别@Test public void test4()&#123; List list = new ArrayList(); list.add(1); list.add(2); //删除 list.add(3); updateList(list); System.out.println(list); &#125; private void updateList(List list)&#123; //list.remove(2); //下标2 list.remove(new Integer(2)); &#125; 5、Set接口 set：存储无序的，不可重复的数据 核心实现类： HashSet: LinkedHashSet（子类） TreeSet 核心实现类特点： HashSet：所为set接口的主要实现类，线程不安全的，可以存储null值 LinkedHashSet：作为hashSet的子类，遍历数据时，可以按照添加的顺序遍历，对于操作频繁的元素，可以考虑使用，提供效率。LinkedHashSet的存储效率高于HashSet TreeSet：可以按照添加对象的属性进行排序。要求添加的元素为同一类型 实现原理： 添加的过程描述如： 当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法 来得到该对象的 hashCode 值，然后根据 hashCode 值，通过某种散列函数决定该对象 在 HashSet 底层数组中的存储位置。（这个散列函数会与底层数组的长度相计算得到在 数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布， 该散列函数设计的越好） 如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果 为true，添加失败；如果为false，那么会保存该元素，但是该数组的位置已经有元素了， 那么会通过链表的方式继续链接 如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相 等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功 理解无序性，不可重复： 无序性：表示存储的数据在底层的数组中并非按照数组的索引顺序添加，而是根据数据的哈希值决定 不可重复：为了保证元素的不可重写，我们需要重写hashcode和equals方法 Set set = new HashSet();set.add(456);set.add(123);set.add(123); //重复的不能添加set.add("aa");//set.add("aa");// set.add(new String("abc"));// set.add(new String("abc")); //string重写hashcode和equeals//需要重写hashcode和equeals方法保证元素唯一性set.add(new Person("tom", 20)); set.add(new Person("tom", 20));System.out.println(set); 总结：（面试） HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类 Set接口是Collection的子接口，set接口没有提供额外的方法 Set 判断两个对象是否相同不是使用 == 运算符，而是根据 equals() 方法 HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取、查找、删除性能 HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等 对于存放在Set容器中的对象，对应的类一定要重写equals() 和hashCode(Objectobj) 方法，以实现对象相等规则 。即： “相等的对象必须具有相等的散列码“ LinkedHashSet LinkedHashSet 是 HashSet 的子类 LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的 LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能 LinkedHashSet 不允许集合元素重复 TreeSet TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态 TreeSet底层使用 红黑树结构存储数据 判断两个对象是否相等的唯一标准： 自然排序使用： compareTo(Object obj) ==0判断相等，不再使用equals（）方法 定制排序使用：compare(Object o1, Object o2)判断相等， 不再使用equals（）方法 当需要把一个对象放入 TreeSet 中，重写该对象对应的 equals() 方法时，应保证该方法与compareTo(Object obj) 方法有一致的结果：如果两个对象通过equals() 方法比较返回 true，则通过 compareTo(Object obj) 方法比较应返回 0 //定制排序 Comparator&lt;Person&gt; com = new Comparator&lt;Person&gt;() &#123; @Override public int compare(Person o1, Person o2) &#123; //姓名 a -- z //return o1.getName().compareTo(o2.getName()); // z--a 当姓名相同时，判断年龄 int res = o1.getName().compareTo(o2.getName()); if(res == 0)&#123; return -Integer.compare(o1.getAge(), o2.getAge()); &#125; return -res; &#125; &#125;; TreeSet&lt;Person&gt; set = new TreeSet&lt;Person&gt;(com); set.add(new Person("a", 12)); set.add(new Person("b", 20)); set.add(new Person("c", 24)); set.add(new Person("d", 26)); //姓名相同，年龄不同为不同对象，需要添加到容器中，判断标准为compareTo set.add(new Person("e", 10)); set.add(new Person("e", 33)); //set.add("abc"); System.out.println(set); 6、Map接口- map：双列数据、存储key-value对数据 核心实现类： HashMap LinkedHashMap(子类) TreeMap Hashtable Properties（子类） 实现类特点： - HashMap：作为Map接口的主要实现类，线程不安全的，效率高。存储null的key和value，底层使用数组+链表（jdk7）， 数组+链表+红黑树（jdk8）- LinkedHashMap：实现了遍历map集合中元素的顺序和添加的顺序一直。以为在原有的HashMap的底层结构中添加了一对指针，指向前一个和后一个元素。所以对于频繁的操作，此执行效率高于HashMap- TreeMap：可以按照key-value对进行排序，实现排序遍历，此时考虑key的自然排序和定制排序的使用- Hashtable：作为古老的实现类，线程安全的，效率低，不能存储null的key或value- Properties：常用来作为配置文件，key和value都是String类型 6.1 Map结构的理解map结构的理解： Map中的key是无序的，不能重复的。使用set存储所有的key ---- &gt;key所在的类必须重写equals和hashcode方法 Map中的value是无序的，可重复的，使用collection存储所有的value ---&gt; value所在的类重写equals()方法 一个键值对： key-value构成了一个Entry对象 Map中的Entry是无序的，不可重复的，使用set存储所有的entry 6.2 HashMap的底层实现原理JDK8：HashMap使用的是数组+链表+红黑树实现 JDK7：HashMap使用的是数组+链表 源码： 6.3、LinkedHashMap 在HashMap的存储结构的基础上，使用了一对双向链表来记录添加的元素顺序 迭代顺序和添加顺序一致 常用方法： Map map = new HashMap();//添加map.put(123, "AA");map.put(456, "BB");map.put(789, "CC");//修改map.put(123, "dd");//Map map1 = new HashMap();map1.put("cc", 123);map1.put("dd", 456);map.putAll(map1);//removeObject obj = map.remove("cc");System.out.println(obj);//clearmap.clear();System.out.println(map); Map map = new HashMap();map.put("AA", 123);map.put(45, 123);map.put("bb", 67);//get（）Object value = map.get("AA");System.out.println(value);//判断key是否存在boolean key = map.containsKey("bb");System.out.println(key);//判断valueboolean containsValue = map.containsValue(67);System.out.println(containsValue);//Empty：内容空 null：没有地址map.clear(); System.out.println(map.isEmpty()); Map map = new HashMap();map.put("AA", 123);map.put(45, 123);map.put("bb", 67);//遍历所有的keySet keySet = map.keySet();Iterator iterator = keySet.iterator();while(iterator.hasNext())&#123; Object next = iterator.next(); System.out.print(next);&#125;System.out.println("\n---------");//遍历所有的valueCollection values = map.values();for(Object obj:values)&#123; System.out.print(obj);&#125;System.out.println("\n---------");//方式一：entrySet Set entrySet = map.entrySet();Iterator iterator2 = entrySet.iterator();while(iterator2.hasNext())&#123; Object next = iterator2.next(); //entry/node Entry entry = (Entry)next; System.out.println(entry.getKey() + "---" + entry.getValue());&#125;System.out.println("\n---------");//方式二:Set keySet2 = map.keySet(); //所有的keyIterator iterator3 = keySet2.iterator(); while(iterator3.hasNext())&#123;//遍历所有key Object key = iterator3.next(); //key Object value = map.get(key); //根据key获取value System.out.println(key + "---" + value);&#125; 总结： 添加：put（Object key, Object vlaue） 修改：put（Object key, Object vlaue） 删除：remove(Object key) 查询：get（object key） 长度：size（） 遍历： keySet () / values() / entrySet() ---key-value = entry 6.4 TreeMap TreeMap可以实现所有的kev-value处于有序状态 TreeMap底层使用红黑树数据结构存储 TreeMap的key的排序： 自然排序：TreeMap的所有的key必须实现Comparable接口，而且所有的key必须为同一类对象，否则抛出ClassCastException异常 定制排序：创建TreeMap时，传入一个Compartor接口的实现类，该对象负责对TreeMap中的所有key进行排序 TreeMap判断两个key相等的标准：两个key通过compareTo()或compare() == 0 演示代码： class Person implements Comparable&lt;Person&gt;&#123; private String name; private int age; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + "]"; &#125; @Override public int compareTo(Person o) &#123; //姓名自然顺序 0 , 1 -1 return this.getName().compareTo(o.getName()); //return this.getName() - o.getName(); &#125;&#125; TreeMap map = new TreeMap();new String();//方式一：// map.put("c", 3);// map.put("b", 3);// map.put("d", 3);// map.put("e", 3);// map.put("a", 3);map.put(new Person("a",20), 90);map.put(new Person("c",20), 90);map.put(new Person("d",20), 90);map.put(new Person("b",20), 90);map.put(new Person("f",20), 90);System.out.println(map); TreeMap map = new TreeMap(new Comparator&lt;Person&gt;() &#123;@Overridepublic int compare(Person o1, Person o2) &#123; return -o1.getName().compareTo(o2.getName());&#125;&#125;);map.put(new Person("a",20), 90);map.put(new Person("c",20), 90);map.put(new Person("d",20), 90);map.put(new Person("b",20), 90);map.put(new Person("f",20), 90);System.out.println(map); 6.5 Properties Properties该对象是属性文件，常用来保存配置信息 属性文件中的内容都为String类型 示例代码： FileInputStream input = null; try &#123; //System.out.println(new File("/java_collection/src/db.properties").getPath()); //创建文件输入流 input = new FileInputStream("db.properties"); //创建配置文件对象 Properties pro = new Properties(); //加载配置文件信息 pro.load(input); //配置信息加载到pro对象中 //获取配置文件对象中保存的数据 String user = pro.getProperty("user"); String password = pro.getProperty("password"); System.out.println(user + "---" + password); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(input != null)&#123; try &#123; input.close(); input = null; //gc &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 7、Collections工具类 Collections是操作Set、List、Map集合的工具类 Collection中提供了一系列的静态方法对集合中的元素进行排序、查询、修改等操作，还提供了对集合中对象设置不可变性，同步等方法 List list = new ArrayList();list.add(123);list.add(23);list.add(45);list.add(33);list.add(78);list.add(33);//6System.out.println(list);//反转//Collections.reverse(list);//随机排序//Collections.shuffle(list);//自然排序//Collections.sort(list);//交换//Collections.swap(list, 1, 2);//返回指定集合中指定的元素出现的次数//int i = Collections.frequency(list, 33);//System.out.println(i);//System.out.println(list);//容器初始大小为6，元素个数为零 size() == 0//List dest = new ArrayList(6);//copyList dest = Arrays.asList(new Object[list.size()]);Collections.copy(dest, list);System.out.println(dest);//返回线程安全的listList list2 = Collections.synchronizedList(list);]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java04字符串]]></title>
    <url>%2Fjava04%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[字符串字符串相关类 String类：代表一字符串，Java中所有的字符串字面量（如“abc”）都作为次类的实例实现 string是一个final类，代表不可变的字符序列 字符串是常量，用双引号引起来，，它的值在赋值之后不能改变 String对象的字符内容是存储在一个字符数组value[]中的 源码实现如下： //string是不可变类public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; //保持字符串内容 /** Cache the hash code for the string */ private int hash; // Default to 0 /** use serialVersionUID from JDK 1.0.2 for interoperability */ private static final long serialVersionUID = -6849794470754667710L; 字面量的定义方式 示例代码： String str = "abc";String str2 = "abc";//System.out.println(str.equals(str2)); //trueSystem.out.println(str == str2);//true 以为常量池中有相同的数据，所以java会把str的地址赋值为str2str = "123"; //因为字符串的不可变性，java会创建一个新的地址赋值给strSystem.out.println(str == str2); //false//解释如下图 String str = &quot;abc&quot; 于 String str = new String(&quot;abc&quot;) 区别 字符串常量存储在常量池中，目的是共享信息 new字符串对象存储在堆中 示例代码： String str1 = "abc";String str3 = new String("abc"); //创建对象，放入堆中String str4 = new String("abc"); //创建对象放入堆中System.out.println(str1 == str3); //falseSystem.out.println(str3 == str4); //falseSystem.out.println(str1.equals(str3)); //true 因为string类重写object的equeals方法，故只判断内容相同//itern方法返回常量池中保存的地址System.out.println(str1 == str3.intern()); //true 因为str和str3内容相同，常量池中只保存一份 常量于常量拼接的结果在常量池中，且常量池中不会存在相同的内容 只要其中有一个是变量，结果就在堆中 如果拼接的结果调用intern()方法，则返回值就在常量池中 String str1 = "hello";String str2 = "world";String str3 = "hello" + "world";String str4 = str1 + "world";String str5 = str1 + str2;String str6 = (str1 + str2).intern();System.out.println(str3 == str4); //falseSystem.out.println(str3 == str5); //falseSystem.out.println(str4 == str5); //falseSystem.out.println(str3 == str6);// true 进一步理解string的不可变性： class Person&#123; public String name; public int age; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; &#125;Person p1 = new Person("小明",20);Person p2 = new Person("小明",20);System.out.println(p1 == p2); //falseSystem.out.println(p1.name == p2.name); //true 不同对象中的string属性保存在同一个常量池中 理解视图： 思考题： package com.woniu.demo01;public class StringTest2 &#123; String str = new String("good"); char[] ch = &#123;'t','e','s','t'&#125;; int i =10; public void change(String str, char[] ch , int i)&#123; //System.out.println(i + "-----"); //System.out.println(str + "------"); str = "test ok";// //System.out.println(str + "========"); ch[0] = 'b'; i = 100; &#125; public static void main(String[] args) &#123; StringTest2 test = new StringTest2(); test.change(test.str, test.ch,test.i); System.out.println(test.str); //good System.out.println(test.ch); //best System.out.println(test.i); //10 &#125;&#125; 补充：参数传递 参数传递本质上都是值传递，将变量存储的内容复制一份给方法调用的形参 值类型数据：变量保存的是数据本身，所以传递是复制数据本身 引用类型：变量保存的是引用（地址），所以传递的是地址，如果方法内部对传递的数据进行修改，会影响到原来的数据。 ​ 理解图示： String常用方法： 返回值Modifier and Type 方法名 int length() ：获取字符串的长度 char charAt(int index):获取字符串中的一个字符 int indexOf(String str) ：返回传入的字符串出现的首位置 boolean startsWith(String prefix) ： 返回原字符串是否为传入的字符串开头 boolean endsWith(String suffix):是否为以指的的字符串结尾 string toLowerCase()：返回原来的字符串小写 string toUpperCase()：返回原来的字符串大写 string substring(int beginIndex) :从指定下标到结束 string substring(int beginIndex, int endIndex) : 包含开始，不包含结束 作业： 1、验证邮箱的正确行： - 必须包含点（.）和@符号- 点（.）必须在@符号之后- @只能出现一次- @和点直接必须有字符- 不能使用中文 2、过滤不文明词汇 ​ “中国足球真TM烂，TM的。TM的烂” 字符串和基本类型转换 基本类型---&gt;字符串， 可以用一个空的“”号相加 字符---&gt;基本类型： 包装类.parseXXX(&quot;&quot;) StringBuider 和stringBuffer的区别 StringBuffer： 查看源码： abstract class AbstractStringBuilder implements Appendable, CharSequence &#123; /** * The value is used for character storage. */ char[] value; //可变字符序列 /** * The count is the number of characters used. */ int count; //字符串长度 /** 默认初始值大小 /** * Constructs a string buffer with no characters in it and an * initial capacity of 16 characters. */ public StringBuffer() &#123; super(16); //调用父类方法创建stringBuffer字符串 &#125;/** * Creates an AbstractStringBuilder of the specified capacity. */ AbstractStringBuilder(int capacity) &#123; value = new char[capacity]; //创建大小为16的字符数组 &#125; 注意： - StringBuffer初始大小为16个字符，如果我们的操作的字符大于16个建议创建时给初始大小- 可变字符序列- 线程安全，效率低 面试题：string、stringBuffer、StringBuilder的区别 string（JDK1.0） : 不可变序列 StringBuffer（JDK1.0）：可变序列，效率低，线程安全 StringBuilder（JDK1.5）：可变序列，效率高，线程不安全 查看三者之间的效率： package com.woniu.demo02;public class StringEfficiencyTest &#123; public static void main(String[] args) &#123; long startTime = 0L; long endTime = 0L; String text = ""; StringBuffer buffer = new StringBuffer(""); StringBuilder builder = new StringBuilder(""); // 开始对比 startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) &#123; buffer.append(String.valueOf(i)); &#125; endTime = System.currentTimeMillis(); System.out.println("StringBuffer的执行时间：" + (endTime - startTime)); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) &#123; builder.append(String.valueOf(i)); &#125; endTime = System.currentTimeMillis(); System.out.println("StringBuilder的执行时间：" + (endTime - startTime)); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) &#123; text = text + i; &#125; endTime = System.currentTimeMillis(); System.out.println("String的执行时间：" + (endTime - startTime)); &#125;&#125; ==和equals == 是操作符、equals是方法 ==： 基本类型：== 只要值相等返回true 引用类型：== 判断是否为变量中为同一地址，相同返回ture equals： - 所有的类都继承了父类（java.lang.Object）中的equals方法- object中的equals和==本质上是相同的结果 特例： 当使用equels方法进行比较时，对File ，String、Data及包装类，来说比较的是内容，而不考虑是否为同一个引用 当自定义对象是，我们可以考虑重写Object中继承的equals方法，用于比较对象的“内容”是否相同 源码： */ public boolean equals(Object obj) &#123; return (this == obj); //比较的还是地址 &#125; 总结：面试题： == 和equals区别 1、== 即可以比较基本类型也可以比较引用类型，对于基本类型比较的就是值，对于引用类型比较的内存地址 2、equlas、它是Object类中的方法，如果该方法没有被重写则默认使用==. 我们经常使用的string等类。equals方法被重写，比较的是“内容”。 3、通常情况下，我们重写equals方法，会比较类中的相应属性是否相等 Sting常用转换基本类型--&gt;字符串： 使用包装类的 toString() 方法 int c=10;String str1=Integer.toString(c);System.out.println("toString 方法转化的字符串："+str); 使用String类的 valueOf() 方法 String str2=String.valueOf(c);System.out.println("使用String类的valueOf（）方法转化的字符串"+str2); 用一个空字符串加上基本类型，得到的就是基本类型数据对应的字符串 String str3=c+"";System.out.println("使用控制符串添加的到的字符串："+str3); 字符串--&gt;基本类型： 调用包装类的 parseXxx 静态方法 String str="8";int d=Integer.parseInt(str);System.out.println("调用包装类的parse转化："+d); 调用包装类的 valueOf() 方法转换为基本类型的包装类，会自动拆箱 int e=Integer.valueOf(str);System.out.println("调用valueOf方法转化："+e); 数组 --&gt; 字符串 字符数组--&gt;字符串 String 类的构造器：String(char value[])、String(char value[], int offffset, int count) //调用String(char value[])构造器char[] c =&#123;'中','国','3','4','5'&#125;;System.out.println(new String(c));//中国345//调用String(char value[], int offffset, int count)System.out.println(new String(c,1,3));//国34//遍历String[] arr = &#123; "0", "1", "2", "3", "4", "5" &#125;;StringBuffer str5 = new StringBuffer();for (String s : arr) &#123; str5.append(s);&#125;System.out.println(str5.toString()); // 012345 字节数组---&gt;字符串 //调用String(byte bytes[])构造器byte[] b = &#123;'a','1','b'&#125;;System.out.println(new String(b));//a1b//String(byte bytes[], int offffset, int length)System.out.println(new String(b,1,2));//1b 字符串 --&gt; 数组 字符串--&gt;字符数组 //1.char[] toCharArray() String str1 = "hello"; System.out.println(str1.toCharArray());//hello//2.getChars(char dst[], int dstBegin) String str1 = "hello"; str1.getChars(0, 5, str1, 0);//报错//3.getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) //4.当字符串中含有特定字符需要转义符 // 字符串转数组 java.lang.String String str = "0,1,2,3,4,5"; String[] arr = str.split(","); // 用,分割 System.out.println(Arrays.toString(arr)); // [0, 1, 2, 3, 4, 5] 字符串---&gt;字节数组 byte[] getBytes()：使用平台的默认字符集将此 String 编码为byte 序列，并将结果存储到一 个新的 byte 数组中 String str = "中"; System.out.println(str.getBytes("ISO8859-1").length);// -128~127 System.out.println(str.getBytes("GBK").length); System.out.println(str.getBytes("UTF-8").length); System.out.println(new String(str.getBytes("ISO8859-1"), "ISO8859-1"));// 乱码，表示不了中文 System.out.println(new String(str.getBytes("GBK"), "GBK")); System.out.println(new String(str.getBytes("UTF-8"), "UTF-8")); byte[] getBytes(String charsetName)：使用指定的字符集将此 String 编码到 byte 序列，并 将结果存储到新的 byte 数组 Stringbuffer 、Stringbuilder 、String区别String程序运行时会额外创建一个对象，保存String的字符串。当频繁操作字符串时，就会额外产生很多临时变量。StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。至于 StringBuilder 和StringBuffer ，它们基本相似，不同之处，StringBuffer 是线程安全的，而 StringBuilder 则没有实现线程安全功能（不能同步访问），所以性能略高。因此一般情况下，如果需要创建一个内容可变的字符串对象，应优先考虑使用 StringBuilder 类。]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java03面向对象]]></title>
    <url>%2Fjava03%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[面向对象（Oriented Object）定义 OOP（面向对象编程）、OOD(面向对象设计)、OOA（面向对象的分析） Object Oriented Programming 是相对于面向过程而言的，过程其实就是函数，对象是将函数和属性进行了封装。 抽象会使复杂的问题简单化， 从以前执行者变成指挥者， 面向对象更符合人类思维，面向过程符合机器思想。 面向对象和面向过程区别 面向过程：事物比较简单，可以用线性的思维去解决。 面向对象：事物比较复杂，使用简单的线性思维无法解决。 共同点：都是解决实际问题的一种思维方式。解决复杂问题，通过面向对象方式便于我们从宏观上把握事物之间复杂的关系，方便我们分析整个系统；具体到微观操作，仍然使用面向过程方式来处理。 重要概念（重点）对象 定义：接收消息的实体，一切皆为对象，对象都有属性和行为，对象都属于某个类，每个对象都独一无二。 属性：对象的特征，一般是名词 行为：对象可以做的事情，一般是动词 类 定义：具有相同属性和行为的对象的集合。类是模子，确定对象将会拥有的属性和行为。 要素： ​ 创建对象的蓝图和模板 ​ 类的属性：数据抽象 ​ 类的方法：行为抽象 ​ 构造器（构造方法） 接口 定义：抽象方法和常量值定义的集合 修饰符 interface 接口名称 &#123;​ 常量；​ 方法；&#125;接口中定义的属性，默认为：public static final接口中定义的方法：默认为: public abstract 接口中没有构造器 作用： 修饰符 class 类名 extends 父类 implements 接口1， 接口2 ,... 接口的主要作用就是被实现类实现，一个类可以实现多个接口 接口也可以继承其他接口 实现类必须实现接口中的所有方法，否则仍为抽象类 接口和实现类直接存在多态性 jdk1.8中的接口 jdk1.8中接口添加了静态方法和默认方法 接口中定义的静态方法只能被接口调用 接口的实现类对象可以调用默认方法 如果实现类中的方法重写了接口中的默认方法，则实现类调用重写方法 如果子类（实现类）所继承的父类和接口中的默认方法重名，并且子类没有重写，在调用是则使用类优先原则，默认调用的是父类的方法 public interface A &#123; // 抽象方法，静态属性 // 1.8之后 接口可以添加 静态方法，默认方法 public static void method1() &#123; System.out.println("A method1 ---- "); &#125; public default void method2() &#123; System.out.println("A method2 ---- "); &#125; default void method3() &#123; System.out.println("A method3 ---- "); &#125;&#125; 常见的接口用法 单方法接口(函数式接口)：Lambda表达式、@FunctionalInterface 标识性接口 普通接口 常量接口（接口最不正确的用法） 成员 定义在类中。成员有两种： 成员变量：其实对应的就是事物的属性。 成员函数：其实对应的就是事物的行为。 局部变量和成员变量的区别： 成员变量直接定义在类中。 局部变量定义在方法中，参数上，语句中。 成员变量在这个类中有效。 局部变量只在自己所属的大括号内有效，大括号结束，局部变量失去作用域。 成员变量定义在堆内存中，随着对象的产生而存在，消失而消失。 局部变量存在于栈内存中，随着所属区域的运行而存在，结束而释放。 构造方法​ /每一个类有一个默认的隐式的无参数的构造方法/​ *特征1：名称和类名一样​ *特征2：无返回值类型​ *特征3：创建对象的时候调用​ *特征4：构造方法一般用来给属性赋初始值（set方法侧重于修改属性值）​ *特征5：如果一个类中写了带参数的构造方法，那么默认的隐式的无参数的构造 方法就会消失 构造代码块和构造方法的区别 构造代码块：是给所有的对象进行初始化 ，只要对象一建立就会调用这个代码块。 构造方法：是给与之对应的对象进行初始化。 方法重载（Overload）定义：在一个类中，方法名称一样，方法参数不一样（参数类型，参数个数，参数类型的顺序） 注意： 同一个类，同一个方法名。 不同：参数列表不同（类型，个数，顺序不同） 只有返回值不同，不构成方法的重载。 方法重写 （Override）定义：在子类中可以根据需要对从父类中继承来的方法进行重写。（访问修饰符 、返回值、方法名(参数列表) throws 异常 {方法体}） 注意： 重写方法必须和被重写方法具有相同方法名称、参数列表和返回类型。 子类重写的返回值，不能大于父类被重写的返回值类型 如果父类返回值类型为void， 则子类必须为void 如果父类返回值类型为A，则子类必须返回为A或A的间接或直接子类 子类重写的访问修饰符（权限），不能小于父类被重写的方法访问权限 特殊情况：子类不能重写父类中声明为private权限的方法 子类方法抛出的异常不能大于父类被重写方法的异常 this关键字This：代表对象。就是所在函数所属对象的引用。哪个对象调用了this所在的函数，this就代表哪个对象。 this是方法（除静态方法外）中存在的隐式参数，所以在方法中使用this。 普通方法中，this总是指向调用该方法的对象。this.xx; （调用的是成员属性和成员方法） 构造方法中，this总是指向正要初始化的对象。this(...); （调用本类对应参数的构造函数） 注意： （1）this调用构造函数，必须定义在构造函数的第一行。否则编译失败。 （2）this不能用于static修饰的方法。 super关键字用来在子类中调用父类的属性和方法，可以修饰属性，方法、构造器 abstract关键字static关键字static表示静态内容 static可以修饰： 属性 方法 静态块 使用static修饰的内容，就可以和类相关联，类存在，static修饰的就存在 我们可以使用类名的方式去访问： 类名.属性名 类名.方法名称 实例对象能够访问实例属性和方法，静态属性和方法 使用场景： 当想让所有的实例对象访问同一个资源时，就可以修饰为静态 Java面向对象语言的三大特点继承 说明 继承是通过关键字extends（扩展）实现 通过继承子类中无需再声明父类中已存在的属性和方法，提高了代码的复用性 子类和父类的关系不同于子集和集合的关系，子类的功能可以更丰富，子类可以扩展父类没有的功能 A继承B则B就获取到A中所有的属性和方法，包括私有的，只是因为封装的问题子类中不能直接访问，可以间接方法 java中继承的一些规定： 一个类可以被多个类继承 Java中继承为单继承性，只能有一个父类，子类下可以再有子类，所以就有了间接继承和直接继承关系 子类继承了父类后，就可以获取到直接父类和间接父类的所有属性和方法 特殊说明： 1. 如果我们没有声明任何父类，则这个类默认继承java.lang.Object2. 所有的类都间接或直接继承java.lang.Object, 所有的都会有Object的属性和方法 注意 在创建子类对象之前系统会默认创建父类对象 父类中私有属性是能够被继承，只是访问权限问题不能直接访问 如果子类想用父类的属性和方法，则使用super关键字 super可以使用构造器、属性、方法三种场合 子类继承父类，可以得到父类的全部属性和方法（除了父类的构造方法）。 Java中只有单继承，没有多继承。多继承会引起混乱，使得继承链过于复杂，系统难于维护。 Java中的多继承，可以通过接口来实现。 封装​ 隐藏一切可隐藏的实现细节提供简单的编程接口 ​ 私有属性，公有方法。好处：将变化隔离； ​ 便于使用；提高重用性，安全性。 多态​ 方法重写：子类对父类的方法给出自己的实现版本。 ​ 对象造型：用父类型的引用去引用子类对象。]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java02基础]]></title>
    <url>%2Fjava02%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[方法 定义：方法就是一段用来完成特定功能的代码片段，类似于其它语言的函数。方法用于定义该类或该类的实例的行为特征和功能实现。 方法是类和对象行为特征的抽象。方法很类似于面向过程中的函数。面向过程中，函数是最基本单位，整个程序由一个个函数调用组成。面向对象中，整个程序的基本单位是类，方法是从属于类和对象的。 对象名.方法名(实参列表)方法的详细说明 形式参数：在方法声明时用于接收外界传入的数据。实参：调用方法时实际传给方法的数据。 返回值：方法在执行完毕后返还给调用它的环境的数据。 返回值类型：事先约定的返回值的数据类型，如无返回值，必须显示指定为为void。 数组 声明一个数组： int a[];//指定数据类型 int []a; int a[]=new int[4]//声明的同时分配空间 int a[]=new int[]{1,6,4,10}//声明的同时分配空间并赋值 int a[]={1,6,4,10}//声明的同时分配空间并赋值 二维数组 声明 int a [][]=&#123;&#123;1,2,3&#125;,&#123;1,2,3&#125;,&#123;1,2,3&#125;&#125;a.length=3 a[0]=&#123;1,2,3&#125;a[0].length=1 - 输出： ```java int a[][]=new int [3] []; a[0]=new int[3]; a[1]=new int[4]; a[2]=new int[2]; 以上都属于开辟空间 赋值: a[0] [0]=1; 进制转换二进制转十进制Integer.parseInt(&quot;0110&quot;, 2);八进制转十进制Integer.parseInt(&quot;17&quot;, 8);十六进制转十进制Integer.parseInt(&quot;17&quot;, 16);十进制转成二进制Integer.toBinaryString(int i);十进制转成八进制Integer.toOctalString(int i);十进制转成十六进制Integer.toHexString(int i); 获取随机数 方法一(数据类型)(最小值+Math.random()(最大值-最小值+1))例:(int)(1+Math.random()(10-1+1))从1到10的int型随数 方法二获得随机数for (int i=0;i&lt;30;i++){System.out.println((int)(1+Math.random()10));}(int)(1+Math.random()10)通过java.Math包的random方法得到1-10的int随机数公式是:最小值---最大值（整数）的随机数（类型）最小值+Math.random()*最大值 方法三Random ra =new Random();for (int i=0;i&lt;30;i++){System.out.println(ra.nextInt(10)+1);}通过java.util包中的Random类的nextInt方法来得到1-10的int随机数]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java01基础]]></title>
    <url>%2Fjava01%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[java简介 界面：HTML CSS JAVASCRIPT JQUERY BOOTSTRAP VUE 服务器端技术：JAVA JAVAWEB 数据库（mysql oracle） JAVA:在大家要开发的项目中是一种服务器端技术，完成业务逻辑的处理，比如验证用户名密码是否正确。 B/S :浏览器/服务器,一种项目结构 JAVA之父 JAMES GOSLING HOTJAVA 根据开发项目类型JAVA 分为三种类型： JAVASE :标准版 桌面应用程序JAVAEE :企业版 开发B/S结构的项目JAVAME ：小型版 嵌入式 一般的高级语言的运行过程 .c /.cpp 源代码————&gt;编译----&gt;.exe可执行程序（针对特定操作系统） .java-----&gt;编译-----&gt;.class(字节码文件，在操作系统不能直接运行，可以跨平台)------&gt;解释（不同平台有不同的解释器JVM Java虚拟机）----&gt;看到程序的运行结果 JVM：JAVA虚拟机 解释字节码程序 管理Java程序在运行过程所占用的内存空间 JRE：Java运行环境 JRE（JVM是其一部分） JDK：JAVA开发工具包 bin目录：存放可执行文件； ib目录：存放Java的类库文件； include目录：存放用于本地方法的文件； demo目录：存放演示程序； jre目录：存放Java运行环境文件； 学会使用Java API文档 Java中已经定义好的类、接口数不胜数，不可能完完全全把这些类及其这些类的方法记住。但API文档能够帮助解决这样的问题。在学习Java的过程中和别人交流是很重要的，有助于提高自己的技术知识。 Java API文档是一种非常有用的文档，描述许多Java的内置功能，其中包含类、包、接口等帮助。 Java数据结构 标识符命名规则： 1.类名称（首字母大写）2.方法名称3.变量名称（一般首字母小写）字母、_、$ 双单词采用驼峰法 八种基本数据类型 整数型：byte（1字节）-128〜127 short（2） -2^15〜2^15-1 -32768〜32767 int（4） 21 4748 3647//java中任何整数默认int型 long（8字节） //d=214748xxxl 超过int型最大值要加l 浮点型：float e=3.14f （4字节） //浮点数不能做精确运算 double f=3.14 （8字节） 字符型：char j=&#39;中&#39;; （2字节）0〜65536//单引号只能且放一个字符（没有符号位）可以表示一个汉字 波尔型：Boolean（1字节） //变量能表示ture false 字符串数据类型： 不属于8种基本类型例如 String s=&quot;abc&quot; abc是字符串 s.length=3 数据类型转换 强制类型转换大数据向小数据放 // short d=128; 错误方式小数向整数放 //byte c=(byte)d;正确方式转换过程中都可能发生精度损失，因为转换过程中采用的原理是高位截断， 剩下的位数可能表示的数字跟原来就不一致了。 short s=1; s+=1; //等价于 s=(short)(s+1) 需要强制转换 精度损失：以下情况可能会发生精度损失，因为等号右边按照Int型运算，不够存放算术运算结果// long a=24246010001000;// long a=24246010001000l; 自动提升转换 1.可以将一个char型变量赋值给int型或者long型，不能byte和short2.不能将一个整型的变量赋值给char3.可以将一个整型的字面量赋值给char (0-65535)a+1&lt;a 在高位截短的情况下可能发生4.常量 只能赋一次值 例：final int a=10; 运算符 算数运算符%取余++自加 // a++先参与后自加 ++a先自加后参与--自减 关系运算符&lt; &gt; &lt;= &gt;= == != 逻辑运算符&amp;&amp; 与 (&quot;A&amp;&amp;B&quot; A部分为false则B部分不执行输出false)|| 或(&quot;A||B&quot; A部分为ture则B部分不执行输出ture)!（op1） 非（一元运算符 包括++ --）&amp; 、|(也是逻辑与和逻辑或，不存在短路效应) 位运算符位运算符用来对二进制数进行测试、置位或移位等操作，操作数只能为整型或字符型数据〜a //按位取反a&amp;ba|ba^ba&gt;&gt;2 A左移2位A&lt;&lt;2 A右移2位A &gt;&gt;&gt;3 A无符号右移3位（注意 赋值运算符 =和条件运算符max=a&gt;b?a:b;）注意：0b10 表示十进制2 010 表示十进制8 0x10 表示十进制16 Java控制语句 多重if 结构 判断某个数是否落在某个区间 public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); // 从控制台输入 int jf = sc.nextInt(); if (jf &lt; 2000) System.out.println("0.9折"); else if (jf &gt;= 2000 &amp;&amp; jf &lt; 4000) System.out.println("0.8折"); else if (jf &gt;= 4000 &amp;&amp; jf &lt; 8000) System.out.println("0.7折"); else System.out.println("0.6折");&#125; Switch Switch（表达式）&#123; case 常量1: 语句// break； case 常量2: 语句// break； default: 语句// while while(布尔ture/false表达式) //循环条件，只要表达式为ture就一直执行下去 while(answer.equals(&quot;y&quot;)){ syso(&quot;早上。。中午。。晚上。。&quot;)； syso(&quot;表演的怎么样？请回答（y/n）:&quot;); answer=input.next(); //循环输入回答 } syso(&quot;圆满完成！&quot;)//只有当回答是y 时才跳出循环 循环结构do while do&#123;循环操作 //至少执行一次操作&#125;while(布尔ture/false表达式)； //循环条件，只要表达式为ture就一直执行 for循环 初始化；布尔表达式；更新 for (int=0; i&lt;100; i++)&#123; sysyo("我最棒")；//循环体&#125;for（；；）&#123; if（布尔表达式）&#123; break/continue； &#125;&#125; 最先执行初始化。可以声明一种类型，但可以初始化一个或多个循环控制变量，也可以是空语句。 然后检测布尔表达式。ture循环体被执行，false循环体终止，开始执行循环体后面的语句。 执行一次循环后，更新循环控制变量。 再次检测布尔表达式。执行上面的过程。 嵌套for循环 public static void lest2()&#123; Scanner sc=new Scanner(System.in); System.out.println("请输入行数n"); int n=sc.nextInt(); for (int i = 0; i &lt;n; i++) &#123; for (int j = 0; j &lt; n-i-1; j++) &#123; System.out.print(" "); // 不加ln默认不换行！！ &#125; for (int j = 0; j &lt; 2*i+1;j++) &#123; System.out.print("*"); &#125; System.out.println(""); &#125; &#125;]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客美化]]></title>
    <url>%2F%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[NexT主题美化 ☑️ NexT.v7.2.0 自带功能集合 1️⃣ NexT网站配置源码 ：主要看站点配置文件_config.yml 2️⃣ NexT主题配置源码：主要看主题配置文件_config.yml 3️⃣Next主题官方博客: 绝大部分配置这里都可以找到 ❗️ 本博客具体实现功能如下： 设置站点名称/昵称/简介 设置菜单menu 设置头像avatar 博客评论功能valine,需注册leancloud 设置社交链接&amp;图标social&amp; social_icons 图标大全：Font Awesome 设置网站图标favicon,把头像设置成.png文件放到image文件夹下，在代码里替换掉image/后面的XXXX.png；logo.svg也可以用png替换（本人测试成功） favicon： small：/ images / favicon-16x16-next.png medium：/images/favicon-32x32-next.png apple_touch_icon：/images/apple-touch-icon-next.png safari_pinned_tab：/images/logo.svg ＃ ANDROID_MANIFEST：/images/manifest.json ＃ ms_browserconfig：/images/browserconfig.xml 增加RSS订阅功能，详见3️⃣ 减少两侧留白，详见3️⃣ 阅读百分比，详见3️⃣ 访客数和访问量统计busuanzi (不准确，我没弄) 底部是否显示hexo /NexT 版本号 和 “驱动支持”，详见3️⃣ Copyright 后面的❤️修改 增加动态设置和颜色设置，详见3️⃣ 显示右上GitHub标识github_banner 代码页面增加copy按钮，详见3️⃣ 在标签页显示标签云 tagcloud 本地搜索 ，详见3️⃣ 图床盘点一下免费好用的图床 （我还没用） 友情链接 打开 themes/next/_config.yml 文件,搜索关键字 Blog rolls 博文置顶Hexo博客彻底解决置顶问题 （我还没做） ❌ 删除部分 删除在线聊天功能daoVoice 删除文章阴影和动态背景canvas 理由：太占资源了而且并不实用(包括看板娘/鼠标点击效果/爆炸效果/内插音乐播放器等)不建议设置。 🆕 新功能待发掘... 本文为原创内容，转载请注明出处。🙏]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>NexT</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《白银时代》读后感]]></title>
    <url>%2F%E6%96%87%E5%AD%A61%2F</url>
    <content type="text"><![CDATA[人的一切痛苦，本质上都是对自己无能的愤怒。 王小波 当代流传着这么一句话：“男生不可不读王小波，女生不可不读周国平。” 王小波的作品以其文采和哲思赢得了无数读者的青睐，无论花季还是老年，都能从他的文字中收获智慧和超然。 王小波，中国当代学者、作家。代表作品有《黄金时代》《白银时代》《青铜时代》《黑铁时代》等。他仅创作的一部电影剧本《东宫西宫》，就获得了阿根廷国际电影节最佳编剧奖，并且入围1997年戛纳国际电影节。 在王小波的众多作品中，最吸引我的，就是他的《白银时代》。 翻开王小波《白银时代》的第一页，大学二年级热力学课老师正在课室上讲道：“将来的世界是银子的”。 自此，王小波便以一个独特的视角，在白银时代这个虚拟时空里作了一个关于未来世界的黑色预言。 希腊神话里说，白银时代的人蒙神恩宠，终身不会衰老，也不会为生计所迫，他们没有痛苦没有忧虑，一直到死，相貌和心灵都像儿童。死掉以后，他们的幽灵还会在尘世上游荡。 然而他所表现的白银世界却与神话中的乌托邦理想国大相径庭甚至是截然相反。 这是个在两个时空下同时进行的故事，一个是大二的学生时代，一个是2020年步入写作公司的职业时代。在作者眼里，它们都是白银时代，在同质化基础上构建起来的一个压抑自我和人性的强权社会。 这是个师生恋的故事。主人公被刻画成了一个受虐者，被倒挂，被钉十字架，如耶稣受难日那天般被折磨。我们在阅读之余，不禁惊叹王小波的世界，那深不见底的内涵。 王小波变幻莫测的文风，体现了现实对人的折磨，但不苦闷，也不压抑，自然流畅的文字为人们解读了现实中不可言喻的道理。 在故事中，有一句话不断被重复——“世界是银色的”。我们可以想象一下，整个世界都是灰蒙蒙的银色，看不到未来，主人公在银色的世界里被镀成了一个银色的雕塑，压抑、沉闷。 他的白银时代一些人说看不懂，一会儿是“我”坐在写字楼里写文章，一会儿又回到了师生恋，王小波的文章总是在这虚虚实实真真假假中，把读者绕进去。 本文内容为转载，感谢阅读。🙏]]></content>
      <categories>
        <category>文学分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[处女篇]]></title>
    <url>%2F%E5%A4%84%E5%A5%B3%E7%AF%87%2F</url>
    <content type="text"><![CDATA[养成写博客的习惯 这将使你的人生变的非常有意义！ ❓ 为什么创建个人博客Record： 记录下自己的学习过程及心得 记录让人自律，自律让人自信 记录是对自己努力的一种认可 Share： 一名优秀的程序员必将具备开源精神 个人的工作与学习过程遇到过很多问题也是通过search blogs 解决的 个人经历与经验分享给朋友未尝不是一件美事 Exchange： My blogs should 具有讨论价值 文章应该具有思辨性 认识更多的小伙伴 交流中成长 Freedom： 远离鱼龙混杂的广告 浩瀚重复的blog资源 静下心回归写作本身 选择性汲取精华blog 🛠 怎样搭建个人博客 首先你需要一个GitHub账号 你需要在电脑安装git并且你需要熟悉一些DOS命令 在DOS窗口安装Hexo并使用NexT主题 最适合新手的 GitHub + Hexo 「大话」博客搭建教程 Hexo 官网：https://hexo.io/zh-cn/ 部署博客 NexT 主题官网：http://theme-next.iissnan.com/ 美化博客 ✍🏻 如何经营个人博客 文章质量决定文章高度 简洁轻快的博客UI 优秀的用户体验 版权意识与推广意识 本文为原创内容，转载请注明出处，感谢您的阅读🙏]]></content>
      <categories>
        <category>人生感悟</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>begin</tag>
      </tags>
  </entry>
</search>

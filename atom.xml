<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RudyWei&#39;s</title>
  
  <subtitle>Personal Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://theme-next.org/"/>
  <updated>2019-08-10T12:28:21.079Z</updated>
  <id>https://theme-next.org/</id>
  
  <author>
    <name>RudyWei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java学习网站</title>
    <link href="https://theme-next.org/java%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99/"/>
    <id>https://theme-next.org/java学习网站/</id>
    <published>2019-08-10T07:38:23.000Z</published>
    <updated>2019-08-10T12:28:21.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java-学习网站"><a href="#java-学习网站" class="headerlink" title="java 学习网站"></a>java 学习网站</h2><p><a href="https://www.sxt.cn/Java_jQuery_in_action/History_Direction.html" target="_blank" rel="noopener">速学堂</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744" target="_blank" rel="noopener">廖雪峰</a></p><p><a href="https://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://help.github.com/cn" target="_blank" rel="noopener">GitHub中文帮助文档</a></p><p><a href="http://www.matools.com/api/java8" target="_blank" rel="noopener">jdk1.8中文版</a></p><p><a href="https://www.cnblogs.com/jiangds/p/6596595.html" target="_blank" rel="noopener">UML图学习</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java-学习网站&quot;&gt;&lt;a href=&quot;#java-学习网站&quot; class=&quot;headerlink&quot; title=&quot;java 学习网站&quot;&gt;&lt;/a&gt;java 学习网站&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.sxt.cn/Java_jQuery_in
      
    
    </summary>
    
      <category term="技术分享" scheme="https://theme-next.org/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="javase" scheme="https://theme-next.org/tags/javase/"/>
    
  </entry>
  
  <entry>
    <title>java11包装类</title>
    <link href="https://theme-next.org/java11%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <id>https://theme-next.org/java11包装类/</id>
    <published>2019-08-09T23:00:00.000Z</published>
    <updated>2019-08-10T12:30:34.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><p>一、什么是包装类</p><p>包装类（Wrapper Class）： Java是一个面向对象的编程语言，但是Java中的八种基本数据类型却是不面向对象的，为了使用方便和解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八种基本数据类型对应的类统称为包装类(Wrapper Class)，包装类均位于java.lang包。</p><p>二、包装类的用途</p><ol><li>为了使用方便Java中将8中基本数据类型进行了封装：除了Integer和Character类以后，其它六个类的类名和基本数据类型一直，只是类名的第一个字母大写即可。<ul><li>boolean —&gt; Boolean</li><li>char —&gt; Character</li><li>byte—&gt; Byte</li><li>short—&gt; Short</li><li>long—&gt; Long</li><li>int —&gt; Integer</li><li>float—&gt; Float</li><li>double—&gt; Double</li></ul></li><li>对于包装类说，用途主要包含两种：<br>a、作为 和基本数据类型对应的类 类型存在，方便涉及到对象的操作。<br>b、包含每种基本数据类型的相关属性如最大值、最小值等，以及相关的操作方法。</li></ol><p>三、包装类的实际使用（以int和integer为例）</p><p><strong>1. int和integer类之间的转换</strong><br>在实际转换时，使用Integer类的<strong>构造方法</strong>和Integer类内部的<strong>intValue方法</strong>实现这些类型之间的相互转换：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int n=5;        </span><br><span class="line">Integer n1=new Integer(n);        </span><br><span class="line">System.out.println(&quot;int类型转换为integer类：&quot;+n1);  </span><br><span class="line">Integer i=new Integer(50);        </span><br><span class="line">int i1 = i.intValue();        </span><br><span class="line">System.out.println(&quot;integer类转换为int类型：&quot;+i1);</span><br></pre></td></tr></table></figure><p><strong>2. Integer类内部的常用方法</strong><br>Integer类的主要方法有：parseInt方法和toString方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//parseInt方法： 数字字符串类型转成int类型        </span><br><span class="line">    String ss=&quot;123&quot;;        </span><br><span class="line">    int ii = Integer.parseInt(ss);        </span><br><span class="line">    System.out.println(&quot;字符类型转成整型：&quot;+ii);        </span><br><span class="line">//toString方法：int类型转成数字字符串类型        </span><br><span class="line">    int ii2=123;        </span><br><span class="line">    String ss2 = Integer.toString(ii2);        </span><br><span class="line">    System.out.println(&quot;int类型转成数字字符串类型:&quot;+ss);</span><br></pre></td></tr></table></figure><p>JDK自从1.5版本以后，就引入了<strong>自动拆装箱</strong>的语法，也就是在进行基本数据类型和对应的包装类转换时，系统将自动进行，这将大大方便程序员的代码书写。<br><strong>自动装箱</strong>：将 基本数据类型 封装为对象类型，来符合java的面向对象的思想。<br><strong>自动拆箱</strong>：将对象重新转化为基本数据类型。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//5是基本数据类型，通过自动装箱变成对象类型。        </span><br><span class="line">//编译器执行了</span><br><span class="line">Integer iii = Integer.valueOf(5)        </span><br><span class="line">Integer iii=5;        //自动拆箱，实际上执行了 </span><br><span class="line">int iii2 = iii.intValue()        </span><br><span class="line">int iii2=iii;        </span><br><span class="line">System.out.println(iii2);</span><br></pre></td></tr></table></figure><p>valueOf（）源码分析：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;     </span><br><span class="line">    assert IntegerCache.high&gt;= 127;     </span><br><span class="line">    if (i &gt;= IntegerCache.low&amp;&amp; i &lt;= IntegerCache.high)    </span><br><span class="line">    return IntegerCache.cache[i+ (-IntegerCache.low)];     </span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：Integer iii=5;相当于编译器执行了Integer iii = Integer.valueOf(5)操作。这个方法就是返回一个 Integer 对象，只是在返回之前，看作了一个判断，判断当前 i 的值是否在 [-128,127] 区别，且 IntegerCache 中是否存在此对象，如果存在，则直接返回引用，否则，创建一个新的对象。</p><p><strong>3.包装类的缓存值</strong><br>各个包装类缓存值范围 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean：true和false </span><br><span class="line">byte：-128～127 </span><br><span class="line">char：0～127 </span><br><span class="line">short：-128～127 </span><br><span class="line">int：-128～127 </span><br><span class="line">long：-128～127</span><br></pre></td></tr></table></figure><p>特别注意：对于float和double没有缓存。<br>在对上述值进行装箱的时候（如：Character c1=127;or Integer i= Integer.valueOf(1); 这个不行哦：Integer i2=new Integer(1)；因为这是新建了一个对象出来。）,并不是创建一个新对象而是使用缓存中的对象，如果超出范围则需要新建立对象。</p><p>四、常见的面试题</p><p><strong>1.Java中Int与Integer的区别？</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一、int 是基本类型，直接存数值；而integer引用数据类型。</span><br><span class="line">二、Int的声明不需要实例化，且变量声明后的初始值为0；Integer的是一个类，初始值为null，需要进行实例化，才能对变量数据进行处理。</span><br><span class="line">三、Integer类是int的包装类，实际开发中Integer被看成一个对象，可以进行数据转换等操作。</span><br></pre></td></tr></table></figure><p><strong>2.判断下面程序片段输出的结果：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Integer num1 = 200;</span><br><span class="line">Integer num2 = 200;                   </span><br><span class="line">System.out.println(&quot;num1==num2: &quot;+(num1==num2));                               Integer num3 = 100;</span><br><span class="line">Integer num4 = 100;          </span><br><span class="line">System.out.println(&quot;num3==num4: &quot;+(num3==num4));</span><br></pre></td></tr></table></figure><p>输出结果：num1==num2:false 和num3==num4:true<br>说明：</p><ul><li>首先要明确equal方法与==的区别：<br>equals() 比较的是两个对象的值（内容）是否相同。<br>“==” 比较的是两个对象的引用（内存地址）是否相同，也用来比较两个基本数据类型的变量值是否相等。</li><li>java定义：在自动装箱时对于值从–128到127之间的值，它们被装箱为Integer对象后，会存在内存中被重用，始终只存在一个对象而如果超过了从–128到127之间的值，被装箱后的Integer对象并不会被重用，即相当于每次装箱时都新建一个 Integer对象；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;包装类&quot;&gt;&lt;a href=&quot;#包装类&quot; class=&quot;headerlink&quot; title=&quot;包装类&quot;&gt;&lt;/a&gt;包装类&lt;/h1&gt;&lt;p&gt;一、什么是包装类&lt;/p&gt;
&lt;p&gt;包装类（Wrapper Class）： Java是一个面向对象的编程语言，但是Java中的八种基本数
      
    
    </summary>
    
      <category term="javase" scheme="https://theme-next.org/categories/javase/"/>
    
    
      <category term="javase" scheme="https://theme-next.org/tags/javase/"/>
    
  </entry>
  
  <entry>
    <title>java10补充枚举</title>
    <link href="https://theme-next.org/java10%E8%A1%A5%E5%85%85%E6%9E%9A%E4%B8%BE/"/>
    <id>https://theme-next.org/java10补充枚举/</id>
    <published>2019-08-09T22:00:00.000Z</published>
    <updated>2019-08-10T10:12:02.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>使用场景：</p><p>​    当类的对象的个数是确定的（较少有限）时候，就可以考虑使用枚举类来表示，比如使用一组常量就可以重点考虑使用枚举类</p><p>jdk1.5之前使用自定义枚举类：</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.woniu.java;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Season</span> </span>&#123;</span><br><span class="line"><span class="comment">// 1.属性私有，并且是final类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String SEASONNAME;<span class="comment">// 季节的名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String SEASONDESC;<span class="comment">// 季节的描述</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.定于私有化构造器</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String seasonName, String seasonDesc)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.SEASONNAME = seasonName;</span><br><span class="line"><span class="keyword">this</span>.SEASONDESC = seasonDesc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.提供当前枚举的多个对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING = <span class="keyword">new</span> Season(<span class="string">"春天"</span>, <span class="string">"春暖花开"</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER = <span class="keyword">new</span> Season(<span class="string">"夏天"</span>, <span class="string">"夏日炎炎"</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN = <span class="keyword">new</span> Season(<span class="string">"秋天"</span>, <span class="string">"秋高气爽"</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER = <span class="keyword">new</span> Season(<span class="string">"冬天"</span>, <span class="string">"白雪皑皑"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.获取属性get方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSEASONNAME</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> SEASONNAME;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSEASONDESC</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> SEASONDESC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写toString方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Season [SEASONNAME="</span> + SEASONNAME + <span class="string">", SEASONDESC="</span> + SEASONDESC + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Season spring = Season.SPRING;</span><br><span class="line">System.out.println(spring);</span><br><span class="line">Season summer = Season.SUMMER;</span><br><span class="line">Season autumn = Season.AUTUMN;</span><br><span class="line">Season winter = Season.WINTER;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk1.5之后使用enum枚举来定义</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.woniu.java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> SeasonEnum &#123;</span><br><span class="line"><span class="comment">//创建枚举类对象，多个用，号隔开</span></span><br><span class="line">SPRING(<span class="string">"春天"</span>, <span class="string">"春风又绿江南岸"</span>), </span><br><span class="line">SUMMER(<span class="string">"夏天"</span>, <span class="string">"映日荷花别样红"</span>),</span><br><span class="line">AUTUMN(<span class="string">"秋天"</span>, <span class="string">"秋水共长天一色"</span>),</span><br><span class="line">WINTER(<span class="string">"冬天"</span>, <span class="string">"窗含西岭千秋雪"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SeasonEnum</span><span class="params">(String seasonName, String seasonDesc)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line"><span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> seasonName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> seasonDesc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">SeasonEnum spring = SeasonEnum.SPRING;</span><br><span class="line">System.out.println(spring);</span><br><span class="line">System.out.println(spring.getSeasonName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p> 使用 enum 定义的枚举类默认继承了 java.lang.Enum类，因此不能再继承其他类</p><p>枚举类的构造器只能使用 private 权限修饰符</p><p>枚举类的所有实例必须在枚举类中显式列出（,  分隔 ;  结尾）列出的实例系统会自动添加 public static final 修饰</p><p>必须在枚举类的第一行声明枚举类对象</p><p>Enum 类 的主要方法</p><ul><li>values() 方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值</li><li>valueOf(String str)可以把一个字符串转为对应的枚举类对象，要求字符串必须是枚举类对象的“名字</li><li>toString()：返回当前枚举类对象常量的名称</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//values()</span></span><br><span class="line"><span class="comment">//SeasonEnum[] values = SeasonEnum.values();</span></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; values.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//System.out.println(values[i]);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//valueOf</span></span><br><span class="line">SeasonEnum winter = SeasonEnum.valueOf(<span class="string">"WINTER"</span>);</span><br><span class="line">System.out.println(winter);</span><br><span class="line"></span><br><span class="line"><span class="comment">//toString()</span></span><br><span class="line">String summer = SeasonEnum.SUMMER.toString();</span><br><span class="line">System.out.println(summer);</span><br></pre></td></tr></table></figure><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持， 也就是Annotation(注解)，其实就是代码里的 特殊标记，</p><p>注解和修饰符类似可以修饰包，类，属性，方法，局部变量</p><p>在JavaEE中大面积使用，框架 = 注解 + 反射 + 设计模式</p><p>注解使用@符号来修饰</p><p><strong>文档相关注解：</strong></p><ul><li>@author：作者</li><li>@version：版本</li><li>@see：相关主题</li><li>@Since：从哪个版本开始</li><li>@param： 参数说明</li><li>@return：方法返回说明</li><li>@exception：异常说明</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> Math.java</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavadocTest</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 程序的主方法，程序的入口</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> args String[] 命令行参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 求圆面积的方法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> radius double 半径值</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> double 圆的面积</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">(<span class="keyword">double</span> radius)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>javaSE中三个基本注解</strong></p><ul><li><p>Override: 限定重写父类方法, 该注解只能用于方法</p></li><li><p>@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时</p></li><li><p>@SuppressWarnings: 抑制编译器警告</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"过时的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"重写的toString方法()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替换配置文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/login"</span>) <span class="comment">//注解方式</span></span><br><span class="line"><span class="comment">//替换如下xml配置文件</span></span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;</span><br><span class="line">&lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">com</span>.<span class="title">servlet</span>.<span class="title">LoginServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">LoginServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/<span class="title">login</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    </p><p><strong>自定义Annotation</strong></p><ul><li>JDK 的元注解（ Annotation） 用于修饰其他 Annotation 定义</li><li>JDK5.0提供了4个标准的meta-annotation类型，分别是：<ul><li>Retention ：用于指定该 Annotation 的生命周期，内部包含一个包含一个 RetentionPolicy 类型<ul><li>RetentionPolicy.SOURCE:在源文件中有效（即源文件保留）</li><li>RetentionPolicy.CLASS:在class文件中有效（即class保留）</li><li>RetentionPolicy.RUNTIME:在运行时有效（即运行时保留）</li><li><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1562836584071.png" alt="1562836584071"></li></ul></li><li>Target：用于指定被修饰的 Annotation 能用于修饰哪些程序元素<ul><li><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1562836619003.png" alt="1562836619003"></li></ul></li><li>Documented：修饰的 Annotation 类将被javadoc 工具提取成文档</li><li>Inherited：被它修饰的 Annotation 将具有 继承性</li></ul></li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.woniu.java2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "woniu"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyAnnotation</span>(value = <span class="string">"123"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Class clazz = AnnotationTest.class;</span><br><span class="line">Annotation a = clazz.getAnnotation(MyAnnotation.class);</span><br><span class="line">MyAnnotation m = (MyAnnotation) a;</span><br><span class="line">String info = m.value();</span><br><span class="line">System.out.println(info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>jdk1.8中新添加注解</strong></p><p> jdk1.8中新添加两个注解的改进</p><ul><li>可重复的注解</li><li>可用于类型的注解</li></ul><p>可重复注解</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>类型注解：</p><p>JDK1.8之后，元注解@Target的参数类型ElementType枚举值多了两个：</p><pre><code>- ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中- ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中</code></pre><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;枚举&quot;&gt;&lt;a href=&quot;#枚举&quot; class=&quot;headerlink&quot; title=&quot;枚举&quot;&gt;&lt;/a&gt;枚举&lt;/h1&gt;&lt;p&gt;使用场景：&lt;/p&gt;
&lt;p&gt;​    当类的对象的个数是确定的（较少有限）时候，就可以考虑使用枚举类来表示，比如使用一组常量就可以重点考虑使用
      
    
    </summary>
    
      <category term="javase" scheme="https://theme-next.org/categories/javase/"/>
    
    
      <category term="javase" scheme="https://theme-next.org/tags/javase/"/>
    
  </entry>
  
  <entry>
    <title>java09日期类</title>
    <link href="https://theme-next.org/java09%E6%97%A5%E6%9C%9F%E7%B1%BB/"/>
    <id>https://theme-next.org/java09日期类/</id>
    <published>2019-08-09T21:00:00.000Z</published>
    <updated>2019-08-10T14:27:50.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、jdk8之前的日期、时间API"><a href="#1、jdk8之前的日期、时间API" class="headerlink" title="1、jdk8之前的日期、时间API"></a>1、jdk8之前的日期、时间API</h1><p>计算世界时间的主要标准：</p><p>UTC ： 世界标准时间，</p><p>GMT：英国的格林威治时间，也是世界标准时间，本初子午线</p><p>CST：格林尼治时间</p><h3 id="1-1-java-lang-System类"><a href="#1-1-java-lang-System类" class="headerlink" title="1.1 java.lang.System类"></a>1.1 java.lang.System类</h3><ul><li>当前类提供currentTimeMillis（）方法来返回当前时间与1970年1月1号0分0秒之间的毫秒数之差，也称为时间戳。</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> millis = System.currentTimeMillis();</span><br><span class="line">System.out.println(millis); <span class="comment">//订单号会用到</span></span><br></pre></td></tr></table></figure><h3 id="1-2-java-util-Date"><a href="#1-2-java-util-Date" class="headerlink" title="1.2 java.util.Date"></a>1.2 java.util.Date</h3><p>体系结构：</p><p><img src="date1.png" alt="1563760414344"></p><p>注意两Date</p><p><img src="date2.png" alt="1563760476211"></p><p><strong>java.util.Date</strong></p><p> 考虑两个方法：</p><pre><code>- 如何实例化- 有什么方法可以调用- 查看实现原理</code></pre><p>1、两个构造器的使用</p><p>2、两个方法的调用</p><p>实例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.构造器Date()</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(date); <span class="comment">//默认调用toString方法，并且被重写</span></span><br><span class="line">System.out.println(date.toString());</span><br><span class="line"></span><br><span class="line">System.out.println(date.getTime()); <span class="comment">//获取毫秒数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.根据毫秒数创建日期</span></span><br><span class="line">Date date2 = <span class="keyword">new</span> Date(<span class="number">1563760979511L</span>);</span><br><span class="line">System.out.println(date2);</span><br></pre></td></tr></table></figure><p><strong>java.sql.Date</strong></p><ul><li>对应这数据库中的日期类型对象</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为了防止冲突，进行全路径创建</span></span><br><span class="line">java.sql.Date date = <span class="keyword">new</span> java.sql.Date(<span class="number">1563761119253L</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将util.date转换为sql.date</span></span><br><span class="line">java.sql.Date date2 =  <span class="keyword">new</span> java.sql.Date(<span class="keyword">new</span> Date().getTime());</span><br><span class="line">System.out.println(date2);</span><br></pre></td></tr></table></figure><h3 id="1-3-java-text-SimpleDateForamt"><a href="#1-3-java-text-SimpleDateForamt" class="headerlink" title="1.3. java.text.SimpleDateForamt"></a>1.3. java.text.SimpleDateForamt</h3><pre><code>- simpleDateForm用来格式化和解析日期类型的具体类- 格式化：日期 ---&gt; 文本（字符串）  - 解析：文本（字符串） ---&gt; 日期</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1创建格式化对象</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat();</span><br><span class="line"></span><br><span class="line"><span class="comment">//格式化：日期---&gt;文本</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="comment">//System.out.println(date);</span></span><br><span class="line">String format = sdf.format(date);</span><br><span class="line"><span class="comment">//System.out.println(format); //19-7-22 上午10:43</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析: 文本 ---&gt; 日期</span></span><br><span class="line"><span class="comment">//String str = "2019/07/22"; //默认不识别</span></span><br><span class="line">String str = <span class="string">"19-7-22 上午10:43"</span>; <span class="comment">//默认格式</span></span><br><span class="line">Date parse = sdf.parse(str); <span class="comment">//抛出异常</span></span><br><span class="line">System.out.println(parse);</span><br></pre></td></tr></table></figure><p>可以指定格式化方式：</p><p>官网实例：</p><p><img src="date3.png" alt="1563763981321"></p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用指定格式进行格式化处理</span></span><br><span class="line"><span class="comment">//"yyyy-MM-dd'T'HH:mm:ss.SSSZ"</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd'T'HH:mm:ss.SSSZ"</span>);</span><br><span class="line">sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>); <span class="comment">//考虑2019/07/22方式</span></span><br><span class="line"><span class="comment">//格式化 </span></span><br><span class="line">String str = sdf.format(<span class="keyword">new</span> Date());</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析</span></span><br><span class="line">String sources = <span class="string">"2019-07-22 10:56:00"</span>;</span><br><span class="line">Date date = sdf.parse(sources);</span><br><span class="line">System.out.println(date);</span><br></pre></td></tr></table></figure><p>注意：</p><pre><code>- 字符串和构造器指定的格式必须相同，否则出现异常</code></pre><h3 id="1-4-java-util-Calendar"><a href="#1-4-java-util-Calendar" class="headerlink" title="1.4.java.util.Calendar"></a>1.4.java.util.Calendar</h3><ul><li>Calendar是一个抽象的基类，主要用于完成日期字段直接的互相操作功能</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例化</span></span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//get</span></span><br><span class="line"><span class="keyword">int</span> day = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(day);</span><br><span class="line">System.out.println(calendar.get(Calendar.DAY_OF_WEEK));</span><br><span class="line"></span><br><span class="line"><span class="comment">//set</span></span><br><span class="line"><span class="comment">//calendar.set(Calendar.DAY_OF_MONTH, 10); //改变本身信息</span></span><br><span class="line"><span class="comment">//day = calendar.get(Calendar.DAY_OF_MONTH);</span></span><br><span class="line"><span class="comment">//System.out.println(day);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//add</span></span><br><span class="line">calendar.add(Calendar.DAY_OF_MONTH, -<span class="number">3</span>);</span><br><span class="line">day = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(day);</span><br><span class="line"></span><br><span class="line"><span class="comment">//getTime  日历类 ---&gt; Date</span></span><br><span class="line">Date date = calendar.getTime(); <span class="comment">//更改过的date</span></span><br><span class="line">System.out.println(date);</span><br><span class="line"></span><br><span class="line"><span class="comment">//setTime  date ---&gt; 日历类</span></span><br><span class="line">calendar.setTime(<span class="keyword">new</span> Date()); <span class="comment">//将时间改变回来</span></span><br><span class="line">System.out.println(calendar.get(Calendar.DAY_OF_MONTH));</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>获取月份：一月是0、二月是1、三月是2、以此类推 12月是11</li><li>获取星期时：周日是1、周一是2、... 周六是7</li></ul><h2 id="2、JDK8之后的日期、时间API"><a href="#2、JDK8之后的日期、时间API" class="headerlink" title="2、JDK8之后的日期、时间API"></a>2、JDK8之后的日期、时间API</h2><p>为什么使用新的Date：</p><ul><li>可变性：相日期、时间类型应该设计为不可变的</li><li>格式化：格式化只对Date起作用，Calendar则没有</li><li>偏移量： 日期设定必须使用偏移量</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Calendar.set(year + 1900, month, date) 使用偏移量</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date((<span class="number">2019</span>-<span class="number">1900</span>), (<span class="number">7</span>-<span class="number">1</span>), <span class="number">22</span>);</span><br><span class="line">System.out.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>).format(date));</span><br></pre></td></tr></table></figure><p>jdk8、提供了新的包：</p><p>java.time :包含值对象的基本包</p><p>java.time.format: 格式化和解析日期和时间</p><p>....</p><h3 id="2-2、LocalDate、LocalTime、LocalDateTime"><a href="#2-2、LocalDate、LocalTime、LocalDateTime" class="headerlink" title="2.2、LocalDate、LocalTime、LocalDateTime"></a>2.2、LocalDate、LocalTime、LocalDateTime</h3><p>java8中的java.time包中提供了常用的时间和日期对象：</p><ul><li>LocalDate ： 本地日期</li><li>LocalTime：本地时间</li><li>LocalDateTime：本地时间和日期（最常用之一）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如实例化：方式一：now()</span></span><br><span class="line">LocalDate date = LocalDate.now();</span><br><span class="line">System.out.println(date);</span><br><span class="line">LocalTime time = LocalTime.now();</span><br><span class="line">System.out.println(time);</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：XXX.of()</span></span><br><span class="line"><span class="comment">//LocalDate date2 = LocalDate.of(2019, 7, 22);</span></span><br><span class="line"><span class="comment">//System.out.println(date2);</span></span><br><span class="line"><span class="comment">//LocalDateTime.of(year, month, dayOfMonth, hour, minute)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//getXXX获取相关属性</span></span><br><span class="line">System.out.println(localDateTime.getYear());</span><br><span class="line">System.out.println(localDateTime.getDayOfWeek()); <span class="comment">//星期</span></span><br><span class="line">System.out.println(localDateTime.getMonth()); <span class="comment">//JULY</span></span><br><span class="line">System.out.println(localDateTime.getMonthValue()); <span class="comment">//7</span></span><br><span class="line">System.out.println(localDateTime.getDayOfMonth());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//withXXX 设置属性 --- 不可变性</span></span><br><span class="line">LocalDateTime month = localDateTime.withDayOfMonth(<span class="number">3</span>);  <span class="comment">//设置日期，返回新的对象</span></span><br><span class="line">System.out.println(<span class="string">"新："</span> + month);</span><br><span class="line">System.out.println(<span class="string">"原: "</span> + localDateTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//puls</span></span><br><span class="line">LocalDateTime plusMonths = localDateTime.plusMonths(<span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">"新："</span> + plusMonths);</span><br><span class="line">System.out.println(<span class="string">"原: "</span> + localDateTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//minus</span></span><br><span class="line">LocalDateTime minusHours = localDateTime.minusHours(<span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">"新： "</span> + minusHours);</span><br><span class="line">System.out.println(<span class="string">"原: "</span> + localDateTime);</span><br></pre></td></tr></table></figure><h3 id="2-3-瞬时-Instant"><a href="#2-3-瞬时-Instant" class="headerlink" title="2.3.瞬时 Instant"></a>2.3.瞬时 Instant</h3><ul><li>时间线上的一个瞬时点，被用来记录应用程序中的时间戳（毫秒数），方便计算机识别</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.实例化 now()本初子午线时间</span></span><br><span class="line">Instant instant = Instant.now();</span><br><span class="line"><span class="comment">//使用的是英国的格林威治时间时间，本初子午线时间</span></span><br><span class="line">System.out.println(instant);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.atOffset设置偏移量</span></span><br><span class="line">OffsetDateTime atOffset = instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">System.out.println(atOffset);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.距离1970年的毫秒数</span></span><br><span class="line"><span class="keyword">long</span> milli = instant.toEpochMilli();</span><br><span class="line">System.out.println(milli);<span class="comment">//1563776939702</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.使用毫秒数创建Instant对象</span></span><br><span class="line">Instant instant2 = Instant.ofEpochMilli(<span class="keyword">new</span> Date().getTime());</span><br><span class="line">System.out.println(instant2);</span><br></pre></td></tr></table></figure><h3 id="2-4-格式化-解析日期和时间"><a href="#2-4-格式化-解析日期和时间" class="headerlink" title="2.4. 格式化/解析日期和时间"></a>2.4. 格式化/解析日期和时间</h3><p> jdk1.8使用java.time.format.DateTimeFormatter提供了3中方式进行格式化：</p><ul><li>预定义格式化</li><li>本地化相关的格式</li><li>自定义格式</li></ul><p>实例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、使用预定义的格式创建格式化对象</span></span><br><span class="line">DateTimeFormatter dtf = DateTimeFormatter.ISO_LOCAL_DATE_TIME;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化：日期---》文本</span></span><br><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line">String format = dtf.format(now);</span><br><span class="line">System.out.println(format);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析: 文本 ---》 日期</span></span><br><span class="line">TemporalAccessor parse = dtf.parse(<span class="string">"2019-07-22T14:50:25.154"</span>);</span><br><span class="line">System.out.println(parse);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.本地化相关的格式</span></span><br><span class="line"><span class="comment">// 方式一：ofLocalizedDateTime(FormatStyle.XXX)</span></span><br><span class="line"><span class="comment">// LONG、MEDIUM、SHORT</span></span><br><span class="line">DateTimeFormatter dtf2 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);</span><br><span class="line"><span class="comment">// 格式化</span></span><br><span class="line">String format2 = dtf2.format(now);</span><br><span class="line">System.out.println(format2);</span><br><span class="line"><span class="comment">// 解析：</span></span><br><span class="line">TemporalAccessor parse2 = dtf2.parse(<span class="string">"2019年7月22日 下午02时57分47秒"</span>);</span><br><span class="line">System.out.println(parse2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、自定义格式</span></span><br><span class="line">DateTimeFormatter ofPattern = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>);</span><br><span class="line"><span class="comment">// 格式化</span></span><br><span class="line">String format3 = ofPattern.format(now);</span><br><span class="line">System.out.println(format3);</span><br><span class="line"><span class="comment">// 解析：</span></span><br><span class="line">TemporalAccessor parse3 = ofPattern.parse(<span class="string">"2019-07-22 03:02:08"</span>);</span><br><span class="line">System.out.println(parse3);</span><br></pre></td></tr></table></figure><h2 id="3、Java比较器"><a href="#3、Java比较器" class="headerlink" title="3、Java比较器"></a>3、Java比较器</h2><ul><li>引用数据类型（数组、对象）只能使用 == 或！= 来进行比较（地址的相等或不等），如果想比较大小则必须使用java比较器</li></ul><p>java中比较器分为两种：</p><pre><code>- 自然排序：java.lang.Comparable- 定制排序：java.util.Comparator</code></pre><p>实例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//string类型实现了 Comparable&lt;String&gt;接口所以能够排序</span></span><br><span class="line">String[] strs = <span class="keyword">new</span> String[] &#123; <span class="string">"ff"</span>, <span class="string">"cc"</span>, <span class="string">"dd"</span>, <span class="string">"aa"</span>, <span class="string">"ee"</span> &#125;;</span><br><span class="line"></span><br><span class="line">Arrays.sort(strs); <span class="comment">//为什么能够排序，实现的是默认自然排序</span></span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(strs));</span><br></pre></td></tr></table></figure><p><strong>Comparable排序：</strong></p><p>​     String 、包装类等实现了comparable接口重写了compareTo(T o)方法，给出了比较两个对象的大小的方式，所以我们自定义的类只需要实现该接口重写相应的方法实现排序</p><p>重写compareTo(T o)方法的规则：</p><ul><li>如果this对象（属性值） &gt; o(形参对象的属性值) ，则返回正数</li><li>如果this对象（属性值） &lt; O(形参对象的属性值)，则返回复数</li><li>如果this对象（属性值） = O(形参对象的属性值)，则返回零</li></ul><p>实例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name; <span class="comment">// 商品名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> price; <span class="comment">// 商品价格</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String name, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Goods [name="</span> + name + <span class="string">", price="</span> + price + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="comment">// System.out.println("compareTo --- ");</span></span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Goods) &#123;</span><br><span class="line">Goods good = (Goods) o;</span><br><span class="line"><span class="comment">// 设置比较标准</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.getPrice() &gt; good.getPrice()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//正序</span></span><br><span class="line"><span class="comment">// return -1; //倒序</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getPrice() &lt; good.getPrice()) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// return 1;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//如果价格相等，按照字母排序</span></span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.getName().compareTo(good.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"类型不匹配"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Goods[] goods = <span class="keyword">new</span> Goods[<span class="number">4</span>];</span><br><span class="line">goods[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">"红楼梦"</span>, <span class="number">30</span>);</span><br><span class="line">goods[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">"西游记"</span>, <span class="number">80</span>);</span><br><span class="line">goods[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">"三国"</span>, <span class="number">70</span>);</span><br><span class="line">goods[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">"水浒"</span>, <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">Arrays.sort(goods); <span class="comment">//实现自然排序</span></span><br><span class="line">System.out.println(goods); <span class="comment">// 数组的地址</span></span><br><span class="line">System.out.println(Arrays.toString(goods));</span><br></pre></td></tr></table></figure><p><strong>Comparator排序</strong></p><p>使用场景：</p><pre><code>- 当元素的类型没有实现java.lang.Comparable接口或虽然实现了该接口但指定的排序规则和我们需要实现的不一样，我们就可以考虑使用Comparator排序</code></pre><p>使用规则：</p><p>   实现接口，重写compare(Object o1, object o2) 方法，比较o1 和 o2的大小</p><ul><li>大于零： o1 &gt; 02</li><li>等于零： o1 = o2</li><li>小于零： o1 &lt; o2</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strs = <span class="keyword">new</span> String[] &#123; <span class="string">"ff"</span>, <span class="string">"cc"</span>, <span class="string">"dd"</span>, <span class="string">"aa"</span>, <span class="string">"ee"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口的实现类</span></span><br><span class="line">Arrays.sort(strs, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//从大到小 --- 字典顺序的倒序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -o1.compareTo(o2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(strs));</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Goods[] goods = <span class="keyword">new</span> Goods[<span class="number">4</span>];</span><br><span class="line">goods[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">"红楼梦"</span>, <span class="number">30</span>);</span><br><span class="line">goods[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">"西游记"</span>, <span class="number">80</span>);</span><br><span class="line">goods[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">"三国"</span>, <span class="number">70</span>);</span><br><span class="line">goods[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">"水浒"</span>, <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//价格倒序 字母倒序</span></span><br><span class="line">Arrays.sort(goods, <span class="keyword">new</span> Comparator&lt;Goods&gt;()&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Goods o1, Goods o2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//价格倒叙</span></span><br><span class="line"><span class="comment">//方式一：</span></span><br><span class="line"><span class="keyword">if</span>(o1.getPrice() &gt; o2.getPrice())&#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//价格倒序</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(o1.getPrice() &lt; o2.getPrice())&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//价格倒序</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line"><span class="keyword">return</span> -o1.getName().compareTo(o2.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：</span></span><br><span class="line"><span class="comment">//Double.compare(o1.getPrice(), o2.getPrice());</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(goods));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、jdk8之前的日期、时间API&quot;&gt;&lt;a href=&quot;#1、jdk8之前的日期、时间API&quot; class=&quot;headerlink&quot; title=&quot;1、jdk8之前的日期、时间API&quot;&gt;&lt;/a&gt;1、jdk8之前的日期、时间API&lt;/h1&gt;&lt;p&gt;计算世界时间的主要标
      
    
    </summary>
    
      <category term="javase" scheme="https://theme-next.org/categories/javase/"/>
    
    
      <category term="javase" scheme="https://theme-next.org/tags/javase/"/>
    
  </entry>
  
  <entry>
    <title>java08多线程</title>
    <link href="https://theme-next.org/java08%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://theme-next.org/java08多线程/</id>
    <published>2019-08-09T20:00:00.000Z</published>
    <updated>2019-08-11T23:05:44.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><h2 id="1、程序、进程、线程"><a href="#1、程序、进程、线程" class="headerlink" title="1、程序、进程、线程"></a>1、程序、进程、线程</h2><ul><li><p>程序：完成特定任务，编写的一组特定的指令集合。 静态代码 ---- 静态</p></li><li><p>进程：正在运行的一个程序。有其自身的产生，运行、消亡的过程（生命周期） --- 动态</p><ul><li>系统在运行时会为每个不同的程序分配不同的内存区域，进程作为资源的分配单位。</li></ul></li><li><p>线程：进程的进一步细分，是程序内部的一条执行路径。</p><ul><li>一个进程同一时间内执行多个线程，就是多线程。</li><li>每个进程有独立的运行栈和计数器。切换的开销少。</li><li>多个线程共享相同的内存单元/内存地址，从同一个堆中分配对象，访问相同的变量和对象。存在安全隐患</li></ul></li></ul><p>  内存结构图（了解）：</p><p>  <img src="%E5%A4%9A%E7%BA%BF%E7%A8%8B1.png" alt="1"></p><p><strong>多线程：</strong></p><p><img src="%E5%A4%9A%E7%BA%BF%E7%A8%8B2.png" alt="1564626804148"></p><p><strong>并行、并发</strong></p><ul><li>并行：多个cpu同时执行多个任务。</li><li>并发：一个cpu同时执行多个任务，时间片段</li></ul><p><strong>单核、多核</strong></p><ul><li>单核：执行多线程时，一个单位时间内只能执行一个线程，只是切换时间特别短，宏观看起来就是同时执行对个线程。</li><li>多核：多个内核单位时间内同时执行多个线程。</li></ul><h2 id="2、线程创建和使用（重点）"><a href="#2、线程创建和使用（重点）" class="headerlink" title="2、线程创建和使用（重点）"></a>2、线程创建和使用（重点）</h2><p><strong>多线的使用场景：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 程序需要同时执行多个任务</span><br><span class="line">- 程序需要实现一些特殊的等待任务，如：用户输入，文件的读写，网络操作，搜索等需要后台执行的程序时。</span><br></pre></td></tr></table></figure><p><strong>线程的创建和启动</strong></p><p>两种方式：</p><ol><li>继承java.lang.Thread</li><li>实现Runnable接口</li></ol><p>多线程创建方式一：(继承)</p><p>步骤：</p><ol><li><p>创建一个继承Thread的子类</p></li><li><p>重写Thread的Run()方法</p></li><li><p>创建Thread子类的对象</p></li><li><p>通过此对象调用start（）方法</p></li></ol><p>示例代码：(输出0-99个数)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.woniu.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">//. 创建一个继承Thread的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.重写Thread的Run()方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">//线程完成的业务逻辑</span></span><br><span class="line"><span class="comment">//输出0-99个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">System.out.println( Thread.currentThread().getName() + <span class="string">" ： "</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main方法运行后会开启一个主线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//3.创建Thread子类的对象 --- 创建分线程</span></span><br><span class="line">MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.通过此对象调用start（）方法</span></span><br><span class="line">t1.start(); <span class="comment">//start最后调用run</span></span><br><span class="line"><span class="comment">//不能直接调用run(),此刻没有实现多线程调用</span></span><br><span class="line"><span class="comment">//t1.run();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此刻或抛出IllegalThreadStateException ,不能再次调用start方法，启动线程，必须重写创建线程</span></span><br><span class="line"><span class="comment">//t1.start(); </span></span><br><span class="line"><span class="keyword">new</span> MyThread().start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////输出0-99个数</span></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; 100; i++) &#123;</span></span><br><span class="line"><span class="comment">//System.out.println("main：" + i);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">System.out.println(<span class="string">"------main-------"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>如果手动调用run（）方法，则是普通方法调用，没有启动多线程</li><li>run()方法由jvm调用，什么时候调用，执行过程的控制都有操作系统的CPU调度决定。</li><li>启动多线程必须调用start（）方法</li><li>一个线程对象只能调用一次start（）方法，如果重复调用则抛出llegalThreadStateException异常</li></ul><p>练习： 创建两个分线程，一个输出100之内的偶数，一个输出100之内的奇数。</p><p><strong>线程常用方法：</strong></p><table><thead><tr><th></th><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td></td><td>getName()</td><td>获取线程名称</td></tr><tr><td></td><td><strong>run</strong>()</td><td>线程在被调度时执行方法</td></tr><tr><td></td><td><strong>setName</strong>(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" target="_blank" rel="noopener">String</a> name)</td><td>设置线程名称</td></tr><tr><td></td><td>sleep(long millis)</td><td>让当前线程指定的毫秒数暂停</td></tr><tr><td></td><td>start()</td><td>启动线程</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.woniu.thread;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10</span>);<span class="comment">//</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//if(i % 20 == 0)&#123;</span></span><br><span class="line"><span class="comment">//yield(); //释放执行权限，交给cpu，让cpu从新分配资源（切换线程），</span></span><br><span class="line"><span class="comment">////但有可能重新分配给自己</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyThread2 t1 = <span class="keyword">new</span> MyThread2();</span><br><span class="line"><span class="comment">//设置分线程名称</span></span><br><span class="line">t1.setName(<span class="string">"线程一 "</span>);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置主线程名称</span></span><br><span class="line">Thread.currentThread().setName(<span class="string">"主线程："</span>);</span><br><span class="line"><span class="comment">//主线程业务</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">20</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> </span><br><span class="line">                    <span class="comment">//注意：此刻主线程调用分线程t1</span></span><br><span class="line">t1.join();<span class="comment">//(让步)主线程将执行权限分给t1分线程，直达t1分线程执行完毕后再切换回来继续执行</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(t1.isAlive()); <span class="comment">//线程消失</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程调度：</strong></p><p>调度策略</p><ul><li>时间片：分时段执行</li><li>抢占式：高优先级可抢占低优先级的线程</li></ul><p>调度方法</p><ul><li>同优先级线程组成先进先出队列（先到先服务），使用时间片策略</li><li>对高优先级，使用优先调度的抢占式策略</li></ul><p>优先级等级</p><ul><li>MAX_PRIORITY ：10</li><li>MIN _PRIORITY ：1</li><li>NORM_PRIORITY ：5</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.woniu.thread;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(</span><br><span class="line">Thread.currentThread().getName() + <span class="string">":"</span> + Thread.currentThread().getPriority() + <span class="string">":"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建子线程</span></span><br><span class="line">ThreadDemo t1 = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line">t1.setName(<span class="string">"子线程"</span>);</span><br><span class="line"><span class="comment">// 设置优先级，只是概率高</span></span><br><span class="line">t1.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">Thread.currentThread().setName(<span class="string">"主线程"</span>);</span><br><span class="line">Thread.currentThread().setPriority(Thread.MIN_PRIORITY);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(</span><br><span class="line">Thread.currentThread().getName() + <span class="string">":"</span> + Thread.currentThread().getPriority() + <span class="string">":"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>演示代码：（三个窗口买票，总票数为100张）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.woniu.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三个窗口买票，总票数为100张</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义总票数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(getName() + <span class="string">"： 买票， 票号为："</span> + ticket);</span><br><span class="line">ticket--;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Window t1 = <span class="keyword">new</span> Window();</span><br><span class="line">Window t2 = <span class="keyword">new</span> Window();</span><br><span class="line">Window t3 = <span class="keyword">new</span> Window();</span><br><span class="line"></span><br><span class="line">t1.setName(<span class="string">"1号窗口"</span>);</span><br><span class="line">t2.setName(<span class="string">"2号窗口"</span>);</span><br><span class="line">t3.setName(<span class="string">"3号窗口"</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：</p><ul><li>每个窗口卖的票数都是100张，可更改为static的方式实现，三个线程卖100张票的情况，但依然出现重票现象。</li><li>关于资源共享的问题，可以使用Runnable方式实现。</li></ul><p><strong>多线程的创建方式二：（实现Runnable接口）</strong></p><p>步骤：</p><ol><li>创建一个实现Runnable接口的实现类</li><li>重写实现类中的run()方法</li><li>创建实现类对象</li><li>创建Thread对象，并使用实现类作为Thread构造器的入参对象</li><li>调用Thread对象的start（）方法</li></ol><p>示例代码：（使用接口实现多线程）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.woniu.runnable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1创建一个实现Runnable接口的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThared</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.重写实现类中的run()方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//3.创建实现类对象</span></span><br><span class="line">MyThared m = <span class="keyword">new</span> MyThared();</span><br><span class="line"><span class="comment">//4.创建Thread对象，并使用实现类作为Thread构造器的入参对象</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(m);</span><br><span class="line"><span class="comment">//5.调用Thread对象的start（）方法</span></span><br><span class="line">t.start();</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(m);</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：（三个窗口买票，总票数为100张）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.woniu.runnable;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总票数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"卖票， 票号为："</span> + ticket);</span><br><span class="line">ticket--;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Window w = <span class="keyword">new</span> Window();</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(w);</span><br><span class="line"></span><br><span class="line">t1.setName(<span class="string">"窗口一"</span>);</span><br><span class="line">t2.setName(<span class="string">"窗口二"</span>);</span><br><span class="line">t3.setName(<span class="string">"窗口三"</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种方式说明：</p><p>​    相同：</p><p>​            两种方式都需要重写run()方法，需要实现的业务代码都写在run方法中</p><p>   实现接口的方便之处：</p><p>​        避免的单继承的局限性</p><p>​        多个线程可以共享同一个接口中的对象，非常适合多线程共享资源的情况</p><p>​         开发中优先使用</p><h2 id="3、线程生命周期（理解）"><a href="#3、线程生命周期（理解）" class="headerlink" title="3、线程生命周期（理解）"></a>3、线程生命周期（理解）</h2><p>JDK 中用Thread.State 类定义了 线程的几种</p><ul><li>新建：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</li><li>就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片此时它已具备了运行的条<br>件，只是没分配到CPU资源</li><li>运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功<br>能</li><li>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执<br>行，进入阻塞状态</li><li>死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</li></ul><p>线程生命周期;</p><p><img src="%E5%A4%9A%E7%BA%BF%E7%A8%8B3.png" alt="1564717060733"></p><h2 id="4、线程同步（重点）"><a href="#4、线程同步（重点）" class="headerlink" title="4、线程同步（重点）"></a>4、线程同步（重点）</h2><p>问题：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 多个线程执行的不确定性引起的结果不稳定</span><br><span class="line">- 多个线程对同一资源的共享，会造成操作的不完整性，破坏数据</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.woniu.runnable;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总票数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"卖票， 票号为："</span> + ticket);</span><br><span class="line">ticket--;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Window w = <span class="keyword">new</span> Window();</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(w);</span><br><span class="line"></span><br><span class="line">t1.setName(<span class="string">"窗口一"</span>);</span><br><span class="line">t2.setName(<span class="string">"窗口二"</span>);</span><br><span class="line">t3.setName(<span class="string">"窗口三"</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：</p><ul><li>买票过程中出现了错票和重票---线程安全问题</li><li>当某个线程再操作车票的过程中，尚未完成，其他线程也参与进来，所以也操作车票。</li><li>当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有 执行<br>完，另一个线程参与进来执行。导致共享数据的错误</li></ul><p>如何解决：</p><ul><li>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行</li><li>当一个线程使用操作ticke的时候，其它线程先不参与进来，直到操作完成其他线程再参与进来，<br>也就是说在多线程在操作同一个资源时要排队。</li><li>使用<strong>同步代码块</strong>或<strong>同步方法</strong>解决</li></ul><p><strong>Synchronized的使用：</strong></p><p> java对于多线程的安全问题提供了专业的解决方式：同步机制（锁）</p><p>使用方式：</p><p>​    同步代码块：</p><p>​       synchronized(对象) {</p><p>​         //需要被同步的代码</p><p>​       }</p><p>同步的前提： </p><ol><li>必须要有两个或者两个以上的线程 </li><li>必须是多个线程使用同一个锁</li></ol><p>好处：解决了多线程的安全问题。<br>弊端：多个线程需要判断锁，较为消耗资源</p><p>示例代码：（线程同步，同步代码块，使用Runnable接口）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.woniu.runnable;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总票数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">//try &#123;</span></span><br><span class="line"><span class="comment">//Thread.sleep(100);</span></span><br><span class="line"><span class="comment">//&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">            <span class="comment">//注意线程同步必须使用同一把锁</span></span><br><span class="line"><span class="comment">//synchronized (obj) &#123;</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"卖票， 票号为："</span> + ticket);</span><br><span class="line">ticket--;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Window w = <span class="keyword">new</span> Window();</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(w);</span><br><span class="line"></span><br><span class="line">t1.setName(<span class="string">"窗口一"</span>);</span><br><span class="line">t2.setName(<span class="string">"窗口二"</span>);</span><br><span class="line">t3.setName(<span class="string">"窗口三"</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：（线程同步，同步代码块，使用继承Thread）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.woniu.syn;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总票数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">     </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//synchronized (this) &#123;</span></span><br><span class="line"><span class="keyword">synchronized</span> (Window2.class) &#123; <span class="comment">//this代表t1,t2,t3,不能使用</span></span><br><span class="line"><span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"卖票， 票号为："</span> + ticket);</span><br><span class="line">ticket--;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Window2 t1 = <span class="keyword">new</span> Window2();</span><br><span class="line">Window2 t2 = <span class="keyword">new</span> Window2();</span><br><span class="line">Window2 t3 = <span class="keyword">new</span> Window2();</span><br><span class="line"></span><br><span class="line">t1.setName(<span class="string">"窗口一"</span>);</span><br><span class="line">t2.setName(<span class="string">"窗口二"</span>);</span><br><span class="line">t3.setName(<span class="string">"窗口三"</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>操作共享的数据代码，即需要被同步的代码</li><li>共享数据：多个线程需要共同操作的变量，比如我们的ticket变量</li><li>同步监视器：俗称锁，任何一个类的对象都可以充当锁<ul><li>多个线程必须用一把锁</li><li>使用接口的方式的多线程，可考虑使用this当“锁”，使用继承的方式可考虑使用当前class对象当“锁”</li></ul></li><li>同步方式解决的线程安全问题</li><li>同步方式在操作代码时，只能有一个线程参与，其他线程只能等待，相当于一个单线程的过程，效率低</li></ul><p><strong>2.使用同步方法实现同步机制：</strong></p><p>当同步的行为可以封装为一个方法时，就可以使用同步方法的方式</p><p>示例代码：（使用接口）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.woniu.syn;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总票数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="comment">//同步监视器(锁)？this</span></span><br><span class="line"><span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"卖票， 票号为："</span> + ticket);</span><br><span class="line">ticket--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Window3 w = <span class="keyword">new</span> Window3();</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(w);</span><br><span class="line"></span><br><span class="line">t1.setName(<span class="string">"窗口一"</span>);</span><br><span class="line">t2.setName(<span class="string">"窗口二"</span>);</span><br><span class="line">t3.setName(<span class="string">"窗口三"</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码:（使用继承）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.woniu.syn;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window4</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总票数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; <span class="comment">//锁是Window4.class</span></span><br><span class="line"><span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"卖票， 票号为："</span> + ticket);</span><br><span class="line">ticket--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Window4 t1 = <span class="keyword">new</span> Window4();</span><br><span class="line">Window4 t2 = <span class="keyword">new</span> Window4();</span><br><span class="line">Window4 t3 = <span class="keyword">new</span> Window4();</span><br><span class="line"></span><br><span class="line">t1.setName(<span class="string">"窗口一"</span>);</span><br><span class="line">t2.setName(<span class="string">"窗口二"</span>);</span><br><span class="line">t3.setName(<span class="string">"窗口三"</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单例设计模式：（懒汉模式，线程安全）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.woniu.designpatterns;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式(饿汉模式)</span></span><br><span class="line"><span class="comment"> *         (懒汉模式)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态只有一份singleton</span></span><br><span class="line"><span class="comment">//private static Singleton singleton =  new Singleton();</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//new Singleton();</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前类的实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//改进：</span></span><br><span class="line"><span class="comment">//方式一：</span></span><br><span class="line"><span class="comment">//synchronized (Singleton.class) &#123; </span></span><br><span class="line"><span class="comment">//if(singleton == null)&#123; </span></span><br><span class="line"><span class="comment">//singleton = new Singleton();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//return singleton;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//方式二：效率高</span></span><br><span class="line"><span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (Singleton.class) &#123; </span><br><span class="line"><span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123; </span><br><span class="line">singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singleton;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>死锁：</p><ul><li>不同的线程分别占用对方需要的同步的资源不放弃，都在等待对象放弃自己需要的同步资源，就形成了线程的死锁，</li><li>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都出于阻塞状态，无法继续</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.woniu.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">StringBuffer s1 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">StringBuffer s2 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line"><span class="comment">//分线程1</span></span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (s1) &#123;</span><br><span class="line">s1.append(<span class="string">"a"</span>);</span><br><span class="line">s2.append(<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (s2) &#123;</span><br><span class="line">s1.append(<span class="string">"b"</span>);</span><br><span class="line">s2.append(<span class="string">"2"</span>);</span><br><span class="line">System.out.println(s1);</span><br><span class="line">System.out.println(s2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分线程2</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (s2) &#123;</span><br><span class="line">s1.append(<span class="string">"c"</span>);</span><br><span class="line">s2.append(<span class="string">"3"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (s1) &#123;</span><br><span class="line">s1.append(<span class="string">"d"</span>);</span><br><span class="line">s2.append(<span class="string">"4"</span>);</span><br><span class="line">System.out.println(s1);</span><br><span class="line">System.out.println(s2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：</p><p>​    专门的算法</p><p>​     尽量减少同步资源的定义</p><p>​     尽量避免嵌套同步</p><h2 id="5、线程通信"><a href="#5、线程通信" class="headerlink" title="5、线程通信"></a>5、线程通信</h2><ul><li>线程执行时互相交换执行。</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.woniu.comm;</span><br><span class="line"></span><br><span class="line"><span class="comment">//让两个线程交替打印数字</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintCount</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="comment">//notify(); //唤醒线程</span></span><br><span class="line">notifyAll();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + num);</span><br><span class="line">num++;</span><br><span class="line"><span class="keyword">if</span>(num &gt;= <span class="number">30</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">wait(); <span class="comment">//线程等待，释放锁，object类中的方法，</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">PrintCount count = <span class="keyword">new</span> PrintCount();</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(count);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(count);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(count);</span><br><span class="line"></span><br><span class="line">t1.setName(<span class="string">"A"</span>);</span><br><span class="line">t2.setName(<span class="string">"B"</span>);</span><br><span class="line">t3.setName(<span class="string">"C"</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>wait() ：执行到wait（）当前线程排队阻塞（等待），并释放同步监视器<br>notify()：执行到notify（）唤醒正在排队的阻塞线程，优先级最高的先唤醒<br>notifyAll (）：唤醒正在排队等待资源的所有线程结束等待</li><li>这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报<br>java.lang.IllegalMonitorStateException异常</li><li>这三个方法必须是同一个同步监视器</li><li>这三个方法是定义在java.lang.Object对象当中的</li></ol><p><strong>经典例题：生产者/消费者问题</strong></p><p>问题描述：<br>    生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处获取一定数量的产品店<br>员一次只能持有固定数量的产品如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店<br>中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果<br>店中有产品了再通知消费者来取走产品。</p><p>分析问题：</p><p>​    1、是否为多线程？是。生产者线程、消费者线程</p><p>   2、是否有数据共享？有。店员手中的产品</p><p>   3、如何解决线程安全？使用同步机制（锁）</p><p>   4、是否涉及线程通信？ 是</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.woniu.product;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clerk</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> productCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加产品</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addProduct</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(productCount &lt; <span class="number">20</span>)&#123;</span><br><span class="line">productCount++;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">": 开始生产第"</span> + productCount + <span class="string">"个产品"</span>);</span><br><span class="line">    notify();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费产品</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getProduct</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(productCount &gt; <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">": 消费者开始消费第"</span> + productCount + <span class="string">"个产品"</span>);</span><br><span class="line">     productCount--;</span><br><span class="line">     notify();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//等待</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Clerk clerk)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">//创建产品</span></span><br><span class="line">System.out.println(<span class="string">"生產者生产产品 ： "</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">clerk.addProduct();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Clerk clerk)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//消费产品</span></span><br><span class="line">System.out.println(<span class="string">"消费者消费产品："</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">clerk.getProduct();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Clerk c = <span class="keyword">new</span> Clerk();</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(c));</span><br><span class="line">t1.setName(<span class="string">"生产者"</span>);</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(c));</span><br><span class="line">t2.setName(<span class="string">"消费者"</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考链接：</p><ol><li><p><a href="https://blog.csdn.net/Mr_YangXianfa__/article/details/45624367" target="_blank" rel="noopener">写的比较全面</a></p></li><li><p><a href="https://blog.csdn.net/weixin_42621338/article/details/82899060" target="_blank" rel="noopener">一个经典例题</a></p></li><li><p><a href="https://blog.csdn.net/mingyundezuoan/article/details/79100327" target="_blank" rel="noopener">源码分析</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java多线程&quot;&gt;&lt;a href=&quot;#Java多线程&quot; class=&quot;headerlink&quot; title=&quot;Java多线程&quot;&gt;&lt;/a&gt;Java多线程&lt;/h1&gt;&lt;h2 id=&quot;1、程序、进程、线程&quot;&gt;&lt;a href=&quot;#1、程序、进程、线程&quot; class=&quot;head
      
    
    </summary>
    
      <category term="javase" scheme="https://theme-next.org/categories/javase/"/>
    
    
      <category term="javase" scheme="https://theme-next.org/tags/javase/"/>
    
  </entry>
  
  <entry>
    <title>java07IO流</title>
    <link href="https://theme-next.org/java07IO%E6%B5%81/"/>
    <id>https://theme-next.org/java07IO流/</id>
    <published>2019-08-09T19:01:01.000Z</published>
    <updated>2019-08-11T22:51:10.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="I-O流"><a href="#I-O流" class="headerlink" title="I/O流"></a>I/O流</h1><h1 id="1、File类的使用"><a href="#1、File类的使用" class="headerlink" title="1、File类的使用"></a>1、File类的使用</h1><ul><li>java.io.File类：文件或文件夹的抽象表示形式，与平台无关。</li><li>File能新建，删除、重命名文件和目录，但不能访问文件本身。如果需要访问文件内容，则需要输入/输出流</li><li>File对象可以作为参数传递给IO流的构造器</li><li>File对象可以不对应真实存在的文件或文件夹</li></ul><p>File的构造器：</p><table><thead><tr><th>构造器</th><th>描述</th></tr></thead><tbody><tr><td><strong>File</strong>(<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html" target="_blank" rel="noopener">String</a> pathname)</td><td>根据路径获取File对象</td></tr><tr><td><strong>File</strong>(<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html" target="_blank" rel="noopener">String</a> parent, <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html" target="_blank" rel="noopener">String</a> child)</td><td></td></tr><tr><td><strong>File</strong>(<a href="https://docs.oracle.com/javase/7/docs/api/java/io/File.html" target="_blank" rel="noopener">File</a> parent, <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html" target="_blank" rel="noopener">String</a> child)</td><td></td></tr></tbody></table><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File f1 = <span class="keyword">new</span> File(<span class="string">"hello.txt"</span>); <span class="comment">//相对路径，以当前的文件所在的工程为相对路径的起点</span></span><br><span class="line">f1 = <span class="keyword">new</span> File(<span class="string">"E:\\workspace\\java_io\\hello.txt"</span>); <span class="comment">//绝对路径</span></span><br><span class="line">System.out.println(f1);<span class="comment">//hello.txt</span></span><br><span class="line">System.out.println(f1.exists()); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器2 \表示转义符</span></span><br><span class="line">File f2 = <span class="keyword">new</span> File(<span class="string">"E:\\workspace\\java_io"</span>,<span class="string">"hello.txt"</span>);</span><br><span class="line">System.out.println(f2.exists());<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器3</span></span><br><span class="line">File f3 = <span class="keyword">new</span> File(<span class="keyword">new</span> File(<span class="string">"E:\\workspace\\java_io"</span>),<span class="string">"hello2.txt"</span>);</span><br><span class="line">System.out.println(f3.exists()); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>常用方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File f1 = <span class="keyword">new</span> File(<span class="string">"hello.txt"</span>);</span><br><span class="line">File f2 = <span class="keyword">new</span> File(<span class="string">"java\\javaee\\hello.txt"</span>);</span><br><span class="line">System.out.println(f1.getAbsolutePath()); <span class="comment">//获取完整的路径</span></span><br><span class="line">System.out.println(f1.getPath()); <span class="comment">//相对路径</span></span><br><span class="line">System.out.println(f1.getParent()); <span class="comment">//上级路径</span></span><br><span class="line">System.out.println(f1.length()); <span class="comment">//文件的字节数</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> Date(f1.lastModified())); <span class="comment">//修改时间</span></span><br><span class="line">System.out.println(<span class="string">"---------------"</span>);</span><br><span class="line">System.out.println(f2.getAbsolutePath());</span><br><span class="line">System.out.println(f2.getPath());</span><br><span class="line">System.out.println(f2.getParent());</span><br><span class="line">System.out.println(f2.length());</span><br></pre></td></tr></table></figure><p>常用方法2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"E:\\workspace"</span>);</span><br><span class="line"></span><br><span class="line">String[] list = f.list(); <span class="comment">//遍历当前目录下的所有文件和文件夹</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">    String fileName = list[i];</span><br><span class="line">    System.out.println(fileName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"-------------"</span>);</span><br><span class="line"></span><br><span class="line">File[] listFiles = f.listFiles();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; listFiles.length; i++) &#123;</span><br><span class="line">    File file = listFiles[i];</span><br><span class="line">    System.out.println(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2、IO流的原理和使用"><a href="#2、IO流的原理和使用" class="headerlink" title="2、IO流的原理和使用"></a>2、IO流的原理和使用</h1><h2 id="2-1为什么使用IO流"><a href="#2-1为什么使用IO流" class="headerlink" title="2.1为什么使用IO流"></a>2.1为什么使用IO流</h2><p>大部分程序都需要进行输入/输出处理,比如从键盘读取数据、从屏幕中输出数据、从文件中写数据等等。在 Java 中,把这些不同类型的输入、输出源抽象为流(Stream),而其中输入或输出的数据则称为数据流(Data Stream),用统一的接口表示,从而使程序设计简单明了</p><h2 id="2-2-‘流’的介绍"><a href="#2-2-‘流’的介绍" class="headerlink" title="2.2 ‘流’的介绍"></a>2.2 ‘流’的介绍</h2><ul><li><p>流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。</p></li><li><p>I/O是Input/Output的缩写，用于处理设备之间的数据传输，如：读/写文件, 网络通信。</p></li><li><p>java.io包下提供了各种“流”类和接口</p></li><li><p>输入(input)：读取外部数据（硬盘、网络等外部存储设备）到程序（内存）中（读）</p></li><li><p>输出（output）：将程序（内存）数据输出到外部存储设备（硬盘、网络等）中（写）</p></li></ul><h2 id="2-3示意图"><a href="#2-3示意图" class="headerlink" title="2.3示意图"></a>2.3示意图</h2><p><img src="https://img-blog.csdnimg.cn/20181028152553371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjgwOTM0,size_27,color_FFFFFF,t_70" alt></p><h2 id="2-4流的分类"><a href="#2-4流的分类" class="headerlink" title="2.4流的分类"></a>2.4流的分类</h2><ul><li>我们对IO流一般会从3个维度进行描述<ul><li>根据流的方向：输出、输出</li><li>根据流的大小：字节、字符</li><li>根据流的角色：（功能越来越强大） 节点（文件流）， 处理流</li></ul></li><li>四个抽象基类</li></ul><table><thead><tr><th></th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>InputStream</td><td>Read</td></tr><tr><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table><p>流的体系：</p><p><img src="IO1.png" alt="1564369340107"></p><p>这些所有的流都是这4个基类的实现类</p><h1 id="3、节点流"><a href="#3、节点流" class="headerlink" title="3、节点流"></a>3、节点流</h1><table><thead><tr><th>文件流</th><th>缓冲流(处理流的一种)</th></tr></thead><tbody><tr><td>FileInputStream</td><td>BufferedInputStream</td></tr><tr><td>FileOutputStream</td><td>BufferedOutputStream</td></tr><tr><td>FileReader</td><td>BufferedReader</td></tr><tr><td>FileWriter</td><td>BufferedWriter</td></tr></tbody></table><p>字符流读文件：</p><p>示例代码：（）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileReader reader = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.创建File类对象，指向操作的文件</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"hello.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建具体的流,读文本（字符流，输入）</span></span><br><span class="line">reader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.读数据 read() : 返回读入的一个字符, 返回-1读取完毕</span></span><br><span class="line"><span class="comment">//int data = reader.read();</span></span><br><span class="line"><span class="comment">//while (data != -1) &#123;</span></span><br><span class="line"><span class="comment">//System.out.println((char) data);</span></span><br><span class="line"><span class="comment">//data = reader.read();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二:</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">while</span>( (data = reader.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">System.out.println((<span class="keyword">char</span>)(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 不能自动回收gc</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">reader.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileReader r = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.創建File对象</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"hello.txt"</span>);</span><br><span class="line"><span class="comment">// 2.创建流</span></span><br><span class="line">r = <span class="keyword">new</span> FileReader(file);</span><br><span class="line"><span class="comment">// 3.读数据</span></span><br><span class="line"><span class="keyword">char</span>[] cs = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">3</span>]; <span class="comment">//缓存的大小</span></span><br><span class="line"><span class="keyword">int</span> len; <span class="comment">//读取的字符数</span></span><br><span class="line"><span class="keyword">while</span> ((len = r.read(cs)) != -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//错误方式</span></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; cs.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//System.out.print(cs[i] + " ");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确方式一</span></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="comment">//System.out.print(cs[i] + " ");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//正确方式二</span></span><br><span class="line">String str = <span class="keyword">new</span> String(cs, <span class="number">0</span>, len);</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">r.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>read（）理解：返回读入的一个字符，如果达到末尾，返回-1</li><li>读取的文件一定要存在，否则报异常FileNotFoundException</li><li>为了保证资源合理利用，必须使用try-catch-finally关闭资源</li></ul><p><strong>字符流的写：</strong></p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建File对象</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"hello2.txt"</span>); <span class="comment">//文本可以不存在</span></span><br><span class="line"><span class="comment">//2.获取字符输出流 默认false：覆盖 ， true：追加</span></span><br><span class="line">FileWriter writer = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line"><span class="comment">//3.写</span></span><br><span class="line">writer.write(<span class="string">"红红的太阳，蓝蓝的天"</span>);</span><br><span class="line">writer.write(<span class="string">"admin"</span>);</span><br><span class="line"><span class="comment">//4.关</span></span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建File</span></span><br><span class="line">File srcFile = <span class="keyword">new</span> File(<span class="string">"hello.txt"</span>);</span><br><span class="line">File destFile = <span class="keyword">new</span> File(<span class="string">"hello3.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符流不能读取和写入图片 --- 非文本数据</span></span><br><span class="line"><span class="comment">//File srcFile = new File("123.jpg");</span></span><br><span class="line"><span class="comment">//File destFile = new File("456.jpg");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建流</span></span><br><span class="line">FileReader re = <span class="keyword">new</span> FileReader(srcFile);</span><br><span class="line">FileWriter wr = <span class="keyword">new</span> FileWriter(destFile);</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据读写操作</span></span><br><span class="line"><span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> len; <span class="comment">//记录每次读取的字符个数</span></span><br><span class="line"><span class="keyword">while</span>((len = re.read(cbuf)) != -<span class="number">1</span>)&#123; <span class="comment">//读取的数据临时保存到cbuf缓存中</span></span><br><span class="line"><span class="comment">//写 --- 每次写len个字符</span></span><br><span class="line">wr.write(cbuf, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line"><span class="keyword">if</span>(wr != <span class="keyword">null</span>)&#123;</span><br><span class="line">wr.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(re != <span class="keyword">null</span>)&#123;</span><br><span class="line">re.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>输出操作，对应的File可以不存在，不会报错，会自动生成对应的文件</li><li>FileWriter(file ，false) ： 对原有文件进行覆盖（默认）</li><li>FileWriter(file ，true)：对原有文件进行追加</li></ul><p><strong>字节流读文件</strong></p><p>示例代码：（字符流读取信息）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1造文件</span></span><br><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"hello.txt"</span>);</span><br><span class="line"><span class="comment">//2造流</span></span><br><span class="line">FileInputStream input = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line"><span class="comment">//3读文件</span></span><br><span class="line"><span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">3</span>]; <span class="comment">//缓存字节数</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"> <span class="comment">//返回读取得字节总数，读取的数据放入bs缓存中</span></span><br><span class="line"><span class="keyword">while</span>((len = input.read(bs)) != -<span class="number">1</span>)&#123; <span class="comment">//中文显示默认2个字节保存</span></span><br><span class="line">String str = <span class="keyword">new</span> String(bs, <span class="number">0</span>, len); <span class="comment">//将字节组装为string</span></span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure><p>示例代码：（复制图片）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建File</span></span><br><span class="line">File srcFile = <span class="keyword">new</span> File(<span class="string">"123.jpg"</span>);</span><br><span class="line">File destFile = <span class="keyword">new</span> File(<span class="string">"456.png"</span>);</span><br><span class="line"><span class="comment">//2.创流</span></span><br><span class="line">FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(destFile);</span><br><span class="line"><span class="comment">//3读写</span></span><br><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = inputStream.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//写</span></span><br><span class="line">outputStream.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.关</span></span><br><span class="line">inputStream.close();</span><br><span class="line">outputStream.close();</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>文本文件（.txt, java,c.cpp等），使用字符流处理</li><li>非文本文件：使用字节流处理 （图片，视频...）</li></ul><h1 id="4、缓存流"><a href="#4、缓存流" class="headerlink" title="4、缓存流"></a>4、缓存流</h1><ul><li>为了提高数据的读取效率，javaAPI提供了带缓冲功能的流，在使用这些流类时，会创建一个内部缓冲区数组，缺省使用8192个字符（8kb）缓存区</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建File类</span></span><br><span class="line"><span class="comment">//File f = new File("123.jpg");</span></span><br><span class="line"><span class="comment">//File f2 = new File("789.jpg");</span></span><br><span class="line"><span class="comment">////2.造流</span></span><br><span class="line"><span class="comment">//FileInputStream input = new FileInputStream(f);</span></span><br><span class="line"><span class="comment">//FileOutputStream out = new FileOutputStream(f2);</span></span><br><span class="line"><span class="comment">//3.包装 --- 可以嵌套</span></span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"123.jpg"</span>)));</span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"789.jpg"</span>)));</span><br><span class="line"><span class="comment">//4.操作 --- 读写</span></span><br><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span>(( len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">bos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5关 --- 先关外部的包装类, 内部的也会关联关闭</span></span><br><span class="line">bis.close();</span><br><span class="line">bos.close();</span><br></pre></td></tr></table></figure><h1 id="5、-转换流"><a href="#5、-转换流" class="headerlink" title="5、 转换流"></a>5、 转换流</h1><ul><li>转换流提供了在字节流和字符流之间的转换</li><li>很多时候我们使用转换流来处理文件乱码问题，实现编码和解码的功能</li><li>如果字节流中的数据都是字符类型时，转成字符流效率更高</li></ul><table><thead><tr><th>名称</th><th>作用</th><th>方向</th></tr></thead><tbody><tr><td>InputStreamReader</td><td>将InputStream转换为Reader</td><td>字节 ---》字符</td></tr><tr><td>OutputStreamWriter</td><td>将Writer转换为OutputStream</td><td>字符---》字节</td></tr></tbody></table><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、创建输入流</span></span><br><span class="line">FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"db.txt"</span>);</span><br><span class="line"><span class="comment">//2、转换 字节流转换为字符流</span></span><br><span class="line">InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(inputStream); <span class="comment">//使用系统默认编码格式</span></span><br><span class="line">reader = <span class="keyword">new</span> InputStreamReader(inputStream, <span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//3、读取操作</span></span><br><span class="line"><span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = reader.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">String str = <span class="keyword">new</span> String(buffer, <span class="number">0</span>, len);</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4关闭资源</span></span><br><span class="line">reader.close(); <span class="comment">//内层关联关闭</span></span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1创建流</span></span><br><span class="line">FileInputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"db.txt"</span>);</span><br><span class="line">FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">"db_2.txt"</span>);</span><br><span class="line"><span class="comment">//2转换流</span></span><br><span class="line">InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(input);</span><br><span class="line">OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(out);</span><br><span class="line"><span class="comment">//3读写</span></span><br><span class="line"><span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = reader.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">writer.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.关闭</span></span><br><span class="line">reader.close();</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure><p>总结：</p><p>   解码：字节/字节数组 ---》 字符数组/字符串</p><p>   编码：字符数组/字符串 ---》字节、字节数组</p><h2 id="6-对象序列化"><a href="#6-对象序列化" class="headerlink" title="6. 对象序列化"></a>6. 对象序列化</h2><ul><li>序列化：用ObjectOutputStream类保存基本类型数据或对象。</li><li>反序列化：使用ObjectInputStream类读取基本类型数据或对象</li><li>不能序列化static和transient修饰的成员变量</li><li>对象序列化机制允许把内存中的对象转换成与平台无关的二进制流。从而把这种二进制数据保存在硬盘中。获取通过网络将这种二进制数据传输到另一个网络节点。当程序获取到这种二进制流，就可以恢复成原来java对象。</li><li>对象序列化需要实现Serializable接口</li></ul><p>序列化的步骤：</p><ol><li>创建ObjectOutputStream</li><li>调用ObjectOutputStream的writerObjet（）方法可输出序列化对象</li><li>操作flush</li></ol><p>反序列化步骤：</p><ol><li>创建ObjectInputStream</li><li>调用ObjectInputStrea的Readobject()方法读取流中的对象</li></ol><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建处理流</span></span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"object.dat"</span>));</span><br><span class="line"><span class="comment">//序列化</span></span><br><span class="line"><span class="comment">//oos.writeObject(new String("测试信息"));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">oos.writeObject(<span class="keyword">new</span> Person(<span class="string">"admin"</span>,<span class="number">20</span>));</span><br><span class="line">oos.flush();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建处理流</span></span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"object.dat"</span>));</span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line">Person p = (Person) ois.readObject();</span><br><span class="line"></span><br><span class="line">System.out.println(p);</span><br></pre></td></tr></table></figure><hr><p>参考链接：</p><ol><li><p><a href="https://blog.csdn.net/li123128/article/details/80025433" target="_blank" rel="noopener">IO流大总结</a></p></li><li><p><a href="https://blog.csdn.net/zhao_yu_lei/article/details/72823874" target="_blank" rel="noopener">几种IO流读写文件</a></p></li><li><p><a href="https://blog.csdn.net/coder150806/article/details/82556802" target="_blank" rel="noopener">java IO流学习总结</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;I-O流&quot;&gt;&lt;a href=&quot;#I-O流&quot; class=&quot;headerlink&quot; title=&quot;I/O流&quot;&gt;&lt;/a&gt;I/O流&lt;/h1&gt;&lt;h1 id=&quot;1、File类的使用&quot;&gt;&lt;a href=&quot;#1、File类的使用&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="javase" scheme="https://theme-next.org/categories/javase/"/>
    
    
      <category term="javase" scheme="https://theme-next.org/tags/javase/"/>
    
  </entry>
  
  <entry>
    <title>java06异常</title>
    <link href="https://theme-next.org/java06%E5%BC%82%E5%B8%B8/"/>
    <id>https://theme-next.org/java06异常/</id>
    <published>2019-08-09T18:03:01.000Z</published>
    <updated>2019-08-11T22:39:47.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>为什么高级语言会出现异常：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 因为程序出错是不可避免的，所以为了提高程序的健壮性，所以所有的高级语言都添加了异常的处理方式，被称为异常处理机制</span><br><span class="line">- 注意开发过程中的逻辑错误和语法错误不是异常</span><br></pre></td></tr></table></figure><h2 id="1、异常概述"><a href="#1、异常概述" class="headerlink" title="1、异常概述"></a>1、异常概述</h2><p>java把异常分为两大类：</p><ul><li><p>Error ： jvm无法处理和解决的严重问题。（无法避免）</p><blockquote><p>程序本身无法克服和恢复，没救了。一般是指虚拟机相关的问题，例如系统崩溃，内存空间不足，方法调用栈溢出，遇到该类问题，建议让让程序终止。</p></blockquote></li><li><p>Exception：可以避免</p><blockquote><p>还能够解决，可捕获，且可能恢复，其中异常分为系统异常和普通异常。</p></blockquote><ol><li><p>系统异常（unchecked异常，也叫（Runtime Exception，运行时异常）：软件本身缺陷导致的，例如数组脚本越界，空指针异常，软件使用者无法克服和恢复，但是该类问题可以让软件系统继续运行或者软件中断运行。（可处理，也可以不处理，不强制用ry..catch 或者throws声明）</p></li><li><p>普通异常（checked异常）：是运行环境变化引起导致的。网络断了，硬盘空间不足，可解决。（必须用try..catch 或者throws声明继续抛给上层调用方法处理）</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20190531165740945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZqeGNzZG4=,size_16,color_FFFFFF,t_70" alt></p></li></ul><p>j<strong>ava.lang.Error</strong></p><p>实例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java.lang.StackOverflowError : 栈溢出</span></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="comment">//java.lang.OutOfMemoryError: 内存溢出</span></span><br><span class="line">Integer[] arr = <span class="keyword">new</span> Integer[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br></pre></td></tr></table></figure><p><strong>java.lang.Exception</strong></p><ul><li>偶然出现的编程错误导致的一般性问题，可以使用异常机制进行处理，目的是让程序能够处理“错误”，提高程序的健壮性，看起来比较智能。</li></ul><p>处理方式：</p><ol><li><p>遇到错误终止程序</p></li><li><p>处理错误，给出提示，继续运行</p></li></ol><p>捕捉错误的时机：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 编译时期：编译时出现的错误，需要事先强制处理错误（checked）</span><br><span class="line">- 运行时期：运行时出现的错误（unchecked）</span><br></pre></td></tr></table></figure><p> <strong>异常体系</strong></p><ul><li>java.lang.Throwable<ul><li>java.lang.Error：不做处理</li></ul></li><li>java.lang.Exception：处理</li></ul><h2 id="2、常见的异常类型"><a href="#2、常见的异常类型" class="headerlink" title="2、常见的异常类型"></a>2、常见的异常类型</h2><p>面试常问：需要记住</p><ul><li>编译时期异常：（checked）<ul><li>IOException<ul><li>FileNotFoundException</li></ul></li><li>ClassNotFoundException</li></ul></li><li>运行时期异常：（unchecked，java.lang.RuntimeException）<ul><li>NullPointException</li><li>ArrayIndexOutOfBoundsException</li><li>ClassCastException</li><li>NumberFormatException</li><li>InputMismatchException</li><li>ArithmeticException</li></ul></li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">////java.lang.NullPointerException</span></span><br><span class="line"><span class="comment">//String str = null;</span></span><br><span class="line"><span class="comment">//System.out.println(str.length());</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">////ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">//String[] arr = new String[4];</span></span><br><span class="line"><span class="comment">//System.out.println(arr[5]);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ClassCastException</span></span><br><span class="line"><span class="comment">//Object obj = new Date();</span></span><br><span class="line"><span class="comment">//String str2 = (String)obj;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//NumberFormatException</span></span><br><span class="line"><span class="comment">//int num = Integer.parseInt("abc");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//InputMismatchException</span></span><br><span class="line"><span class="comment">//Scanner input = new Scanner(System.in);</span></span><br><span class="line"><span class="comment">//System.out.println("请输入一个数");</span></span><br><span class="line"><span class="comment">//int res = input.nextInt();</span></span><br><span class="line"><span class="comment">//input.close();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ArithmeticException</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">10</span> / <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="3、处理异常"><a href="#3、处理异常" class="headerlink" title="3、处理异常"></a>3、处理异常</h2><h3 id="3-1、异常处理模型：抓抛模型"><a href="#3-1、异常处理模型：抓抛模型" class="headerlink" title="3.1、异常处理模型：抓抛模型"></a>3.1、异常处理模型：抓抛模型</h3><ol><li><p>抓取：进行异常处理</p><p>方式一：try-catch-finally</p><p>方式二：throws + 异常类型</p></li><li><p>抛出：程序在运行的过程中一但出现异常，就会在异常出现的地方生成异常对象，并将此抛出，其后代码不在运行。</p></li></ol><h3 id="3-2-、处理方式"><a href="#3-2-、处理方式" class="headerlink" title="3.2 、处理方式"></a>3.2 、处理方式</h3><p><strong>方式一： try-catch-finally（自己处理）</strong></p><p>语法结构：</p><p> try {</p><p>​    //可能出现异常的代码</p><p>  } catch(异常类型 变量名称) {</p><p>​     //处理异常代码</p><p>  } catch（异常类型 变量名称） {</p><p>​    //处理异常代码</p><p>  } ... {</p><p>}finally {  //可选择</p><p>   //一定执行的代码</p><p>}</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"123"</span>;</span><br><span class="line">str = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> num = Integer.parseInt(str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有机会执行</span></span><br><span class="line">     Object obj = <span class="keyword">new</span> Date();</span><br><span class="line">     String str2 = (String)obj;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"num = "</span> + num);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(NullPointerException e)&#123;</span><br><span class="line">    System.out.println(<span class="string">"NullPointerException --- "</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(NumberFormatException e) &#123;</span><br><span class="line">    <span class="comment">//System.out.println(e.getMessage()); //异常对象信息</span></span><br><span class="line"><span class="comment">//e.printStackTrace(); //异常堆栈信息</span></span><br><span class="line">    System.out.println(<span class="string">"NumberFormatException----"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    System.out.println(<span class="string">"Exception --- "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"执行 ---------- "</span>);</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- try将可能出现的异常代码包含起来，一但代码出现异常将会在出现异常的地方生成异常对象并抛给系统，之后跳转到catch区域</span><br><span class="line">- catch则可以根据是否匹配（对应的类型或子类）捕捉到异常对象，再进行异常代码的处理</span><br><span class="line">- 处理完异常代码逻辑跳出try-catch块执行剩余的代码，（可能不会执行所有的catch块）</span><br><span class="line">- 在try-catch声明的变量不能跳出该结构被找到，所以有时候需要在try-catch块之外</span><br><span class="line">- try-catch将编译时出现的异常推迟到运行时异常处理，但仍然可能出错，所以在开发中运行时异常我们一般不做处理。</span><br></pre></td></tr></table></figure><p>演示代码：（finally）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = num1 / num2;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">        <span class="comment">//继续抛出异常</span></span><br><span class="line">        System.out.println(Integer.parseInt(<span class="string">"abc"</span>));</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"一定会执行 --- "</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>演示代码：（return执行）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(method());</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//演示return也执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">System.out.println(nums[<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">catch</span>(IndexOutOfBoundsException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//执行在finally之后</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"一定会执行 --- "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>演示代码：（资源释放）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream input = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//File类代表一个文件/文件夹</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"hello.txt"</span>);</span><br><span class="line">    <span class="comment">//创建流，建立“管道”，将文本读取到内存</span></span><br><span class="line">    input = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取hello.txt文件信息</span></span><br><span class="line">    <span class="keyword">int</span> data = input.read();</span><br><span class="line">    <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123; <span class="comment">//判断文件内容是否存在</span></span><br><span class="line">        System.out.print((<span class="keyword">char</span>)data);</span><br><span class="line">        data = input.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//关闭资源</span></span><br><span class="line">    <span class="keyword">if</span>(input != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            input.close();<span class="comment">//关闭资源</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>finally声明的语句一定会被执行，即使catch中出现异常，或try-catch中有return语句也会被执行</li><li>通常jvm不能够及时回收的资源可放入finally语句中，比如：数据库连接，输入输出流等资源的释放</li></ul><p>方式二：throws + 异常类型 （别的方法处理）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">method2(); <span class="comment">//调用者处理异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//声明抛出异常，谁调用谁处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">FileInputStream input = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// File类代表一个文件/文件夹</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"hello.txt"</span>);</span><br><span class="line"><span class="comment">// 创建流，建立“管道”，将文本读取到内存</span></span><br><span class="line">input = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取hello.txt文件信息</span></span><br><span class="line"><span class="keyword">int</span> data = input.read();</span><br><span class="line"><span class="keyword">while</span> (data != -<span class="number">1</span>) &#123; <span class="comment">// 判断文件内容是否存在</span></span><br><span class="line">System.out.print((<span class="keyword">char</span>) data);</span><br><span class="line">data = input.read();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">input.close();<span class="comment">// 关闭资源</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>写方法声明时可以说明此方法执行时会被抛出的异常</li><li>此方法没有真正处理异常，只给抛出调用者来处理</li></ul><h3 id="3-3-开发中选择try-catch或throws注意事项"><a href="#3-3-开发中选择try-catch或throws注意事项" class="headerlink" title="3.3. 开发中选择try-catch或throws注意事项"></a>3.3. 开发中选择try-catch或throws注意事项</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverrideTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(SuperClass sup)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">sup.method();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">subClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>如果父类中被重写的方法没有throws异常，则子类重写的方法也不能抛出异常，子类只能try-catch处理</li><li>子类重写的方法抛出的异常必须是父类的同类型或子类类型</li></ul><h2 id="4、-手动生成异常（throw）"><a href="#4、-手动生成异常（throw）" class="headerlink" title="4、 手动生成异常（throw）"></a>4、 手动生成异常（throw）</h2><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Student stu = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">stu.regist(-<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">regist</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//System.out.println("输出数据有误");</span></span><br><span class="line"><span class="comment">//手动抛出异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"输出数据有误"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、-自定义异常"><a href="#5、-自定义异常" class="headerlink" title="5、 自定义异常"></a>5、 自定义异常</h2><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用户自定义异常类都是RuntimeException的子类</li><li>自定义异常类通常需要编写几个重载的构造器</li><li>自定义异常类需要提供serialVersionUID</li><li>自定义的异常通过throw抛出</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;异常&quot;&gt;&lt;/a&gt;异常&lt;/h1&gt;&lt;p&gt;为什么高级语言会出现异常：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class
      
    
    </summary>
    
      <category term="javase" scheme="https://theme-next.org/categories/javase/"/>
    
    
      <category term="javase" scheme="https://theme-next.org/tags/javase/"/>
    
  </entry>
  
  <entry>
    <title>java05集合</title>
    <link href="https://theme-next.org/java05%E9%9B%86%E5%90%88/"/>
    <id>https://theme-next.org/java05集合/</id>
    <published>2019-08-09T18:02:02.000Z</published>
    <updated>2019-08-11T22:39:18.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="1、集合框架概述"><a href="#1、集合框架概述" class="headerlink" title="1、集合框架概述"></a>1、集合框架概述</h2><ul><li>java中为了对多个对象进行操作，就需要对多个对象进行存储，针对Array的弊端，Java集合就创建一个“容器”，可以动态的把多个对象的引用放入容器中。</li><li>java集合类就是对多个对象进行存储的操作类，存储的类型可以是单个对象，也可以是关联对象。</li><li>注意Java集合中存储的对象在内存中，如果存储在硬盘中的叫做“持久化操作”</li></ul><p>Java集合分为两种不同的体系：</p><ul><li><p>Collection：单值接口操作</p><ul><li>List：接口：元素有序，可重复  ---“动态”数组<ul><li>ArrayList、LinkedList、Vector</li></ul></li><li>Set：接口：元素无序，不可重复 --- “高中集合”<ul><li>HashSet、LinkedHashSet、TreeSet</li></ul></li></ul></li><li><p>Map：键值操作接口、有key---value组成    --- “高中函数y = f（x）”</p><ul><li>HashMap、LinkedHashMap、TreeMap、Hashtable、Properties</li></ul><p><img src="https://img-blog.csdn.net/20170303143344527?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDY0ODU1NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p></li></ul><h2 id="2、Collection接口"><a href="#2、Collection接口" class="headerlink" title="2、Collection接口"></a>2、Collection接口</h2><ul><li>Collection接口不提供任何实现类，而是提供更加具体的子接口</li><li>在JDK5之前，集合会丢失容器中所放入的对象的类型，会把所有放入的对象都当成Object类型处理，从1.5之后增加了泛型，则Java集合可以记住容器中的对象的数据类型。</li></ul><h3 id="2-1、collection接口体系："><a href="#2-1、collection接口体系：" class="headerlink" title="2.1、collection接口体系："></a>2.1、collection接口体系：</h3><p><img src="%E9%9B%86%E5%90%881.png" alt="1563935115563"></p><h3 id="2-2、常用方法：（API）"><a href="#2-2、常用方法：（API）" class="headerlink" title="2.2、常用方法：（API）"></a>2.2、常用方法：（API）</h3><p><img src="https://img-blog.csdn.net/20171013134550027?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM2ODM4NjMw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><p>演示代码：（）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过ArrayList创建对象</span></span><br><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">//add(E e) //Object e：添加元素</span></span><br><span class="line">coll.add(<span class="string">"AA"</span>);</span><br><span class="line">coll.add(<span class="string">"BB"</span>);</span><br><span class="line">coll.add(<span class="number">123</span>); <span class="comment">//自动装箱</span></span><br><span class="line">coll.add(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line"><span class="comment">//size() ：获取集合中元素的个数</span></span><br><span class="line">System.out.println(coll);</span><br><span class="line">System.out.println(<span class="string">"集合中元素个数： "</span> + coll.size()); <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将coll2中的所有元素添加到指定集合中</span></span><br><span class="line"><span class="comment">//addAll(Collection&lt;? extends E&gt; c)</span></span><br><span class="line">Collection coll2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll2.add(<span class="number">456</span>);</span><br><span class="line">coll2.add(<span class="string">"cc"</span>);</span><br><span class="line">coll.addAll(coll2);</span><br><span class="line">System.out.println(coll);</span><br><span class="line">System.out.println(<span class="string">"集合中元素个数： "</span> + coll.size()); <span class="comment">//6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//clear() ： 清空集合中的元素</span></span><br><span class="line">coll.clear();</span><br><span class="line">System.out.println(coll);</span><br><span class="line">System.out.println(<span class="string">"集合中元素个数： "</span> + coll.size()); <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//isEmpty():判断当前集合是否为空</span></span><br><span class="line">System.out.println(coll.isEmpty());</span><br></pre></td></tr></table></figure><p>实例代码：（contains(Object o)、containsAll(Collection&lt;?&gt; c)）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll.add(<span class="number">123</span>);</span><br><span class="line">coll.add(<span class="number">456</span>);</span><br><span class="line">coll.add(<span class="keyword">new</span> String(<span class="string">"Tom"</span>));</span><br><span class="line">coll.add(<span class="keyword">false</span>);</span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">"小王"</span>, <span class="number">20</span>);</span><br><span class="line">coll.add(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、contains(Object o) : 判断当前集合中是否包含指定的元素,判断对象相等会调用对象所在类的equals()方法</span></span><br><span class="line"><span class="comment">// boolean contains = coll.contains(123);</span></span><br><span class="line"><span class="comment">// System.out.println(contains);</span></span><br><span class="line"><span class="comment">// boolean contains2 = coll.contains(new String("Tom"));</span></span><br><span class="line"><span class="comment">// 添加p對</span></span><br><span class="line"><span class="comment">// System.out.println(contains2); // true</span></span><br><span class="line"><span class="comment">// boolean contains3 = coll.contains(p);</span></span><br><span class="line"><span class="comment">// System.out.println(contains3); // true</span></span><br><span class="line"><span class="keyword">boolean</span> contains4 = coll.contains(<span class="keyword">new</span> Person(<span class="string">"小王"</span>, <span class="number">20</span>));</span><br><span class="line">System.out.println(contains4); <span class="comment">// false: 调用的是父类（object的equals方法使用是==比较）</span></span><br><span class="line">                                <span class="comment">// true : 重写父类的equals方法：属性相同就相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、containsAll(Collection&lt;?&gt; c) :判断coll2集合中的所有元素是否在某个集合中存在</span></span><br><span class="line">Collection coll2 = Arrays.asList(<span class="number">123</span>,<span class="number">456</span>);</span><br><span class="line">System.out.println(coll.containsAll(coll2));</span><br></pre></td></tr></table></figure><ul><li>在Collection接口中的添加object类型的对象时，要求所在的类重写equals方法</li><li>集合在判断相同元素时会调用所在类的equals方法判断是否相同</li></ul><p>示例代码：(<strong>remove</strong>(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" target="_blank" rel="noopener">Object</a> o),<strong>removeAll</strong>(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" target="_blank" rel="noopener">Collection</a>&lt;?&gt; c))</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll.add(<span class="number">123</span>);</span><br><span class="line">coll.add(<span class="number">456</span>);</span><br><span class="line">coll.add(<span class="keyword">new</span> String(<span class="string">"Tom"</span>));</span><br><span class="line">coll.add(<span class="keyword">false</span>);</span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">"小王"</span>, <span class="number">20</span>);</span><br><span class="line">coll.add(p);</span><br><span class="line"></span><br><span class="line">coll.remove(<span class="number">123</span>);</span><br><span class="line">System.out.println(coll);</span><br><span class="line"></span><br><span class="line"><span class="comment">//remove(Object o)</span></span><br><span class="line">coll.remove(<span class="keyword">new</span> Person(<span class="string">"小王"</span>, <span class="number">20</span>));</span><br><span class="line">System.out.println(coll);</span><br><span class="line"></span><br><span class="line"><span class="comment">//removeAll(Collection&lt;?&gt; c)</span></span><br><span class="line">Collection coll2 = Arrays.asList(<span class="number">123</span>,<span class="number">456</span>);</span><br><span class="line">coll.removeAll(coll2);</span><br><span class="line">System.out.println(coll);</span><br></pre></td></tr></table></figure><p>示例代码：(<strong>equals</strong>(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" target="_blank" rel="noopener">Object</a> o),)<strong>retainAll</strong>(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" target="_blank" rel="noopener">Collection</a>&lt;?&gt; c)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll.add(<span class="number">123</span>);</span><br><span class="line">coll.add(<span class="number">456</span>);</span><br><span class="line">coll.add(<span class="keyword">new</span> String(<span class="string">"Tom"</span>));</span><br><span class="line">coll.add(<span class="keyword">false</span>);</span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">"小王"</span>, <span class="number">20</span>);</span><br><span class="line">coll.add(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(coll);</span></span><br><span class="line"><span class="comment">////retainAll(Collection&lt;?&gt; c):获取交集</span></span><br><span class="line"><span class="comment">//Collection coll2 = Arrays.asList(123,456);</span></span><br><span class="line"><span class="comment">//coll.retainAll(coll2);</span></span><br><span class="line"><span class="comment">//System.out.println(coll);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//equals(Object o)</span></span><br><span class="line">Collection coll2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll2.add(<span class="number">123</span>);</span><br><span class="line">coll2.add(<span class="number">456</span>);</span><br><span class="line">coll2.add(<span class="keyword">new</span> String(<span class="string">"Tom"</span>));</span><br><span class="line">coll2.add(<span class="keyword">false</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"小王"</span>, <span class="number">20</span>);</span><br><span class="line">coll2.add(p2);</span><br><span class="line"><span class="comment">//传递的集合和本身的集合要完全相同，返回ture</span></span><br><span class="line"><span class="keyword">boolean</span> res = coll.equals(coll2); <span class="comment">//判断集合中的元素是否完全相同</span></span><br><span class="line">System.out.println(res);</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll.add(<span class="number">123</span>);</span><br><span class="line">coll.add(<span class="number">456</span>);</span><br><span class="line">coll.add(<span class="keyword">new</span> String(<span class="string">"Tom"</span>));</span><br><span class="line">coll.add(<span class="keyword">false</span>);</span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">"小王"</span>, <span class="number">20</span>);</span><br><span class="line">coll.add(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">//hashCode()：返回当前对象的哈希值</span></span><br><span class="line">System.out.println(coll.hashCode()); <span class="comment">//?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//集合 ---&gt; 数组</span></span><br><span class="line">Object[] objs = coll.toArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objs.length; i++) &#123;</span><br><span class="line">System.out.println(objs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展: 数组 ---&gt;集合</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//size()</span></span><br><span class="line">System.out.println(coll.size());</span><br></pre></td></tr></table></figure><h2 id="3、Iterator迭代器接口"><a href="#3、Iterator迭代器接口" class="headerlink" title="3、Iterator迭代器接口"></a>3、Iterator迭代器接口</h2><ul><li>Iterator对象称为迭代器（设计模式），主要用于遍历Collection集合中的元素</li><li>迭代器模式是为容器而生。</li><li>Collection接口继承了java.lang.Iterable接口</li><li>Iterator仅用于遍历集合，本身不提供承装对象的能力，如果需要创建Iterator对象，则必须有需要迭代的集合</li><li>集合对象每次调用iterator（）方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前</li><li>当使用Iterator对集合元素进行迭代时，Iterator并不是把集合元素本身传给了迭代变量，而是把集合元素的值传给了迭代变量（就如同参数传递是值传递，基本数据类型传递的是值，引用类型传递的仅仅是对象的引用变量），所以修改迭代变量的值对集合元素本身没有任何影响。</li></ul><p>迭代器执行原理:</p><p>示例代码：(使用迭代器变量元素)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">"Tom"</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">"Jac"</span>));</span><br><span class="line">    coll.add(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取迭代器对象</span></span><br><span class="line">    Iterator iterator = coll.iterator();</span><br><span class="line">    <span class="comment">//方式一：</span></span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">    System.out.println(iterator.next()); <span class="comment">//没有元素抛出NoSuchElementException</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式二：</span></span><br><span class="line">    <span class="comment">//iterator.hasNext() ：判断是否有下一个元素</span></span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        <span class="comment">//next：1、将指针下移，2、将下移后当前位置中的元素返回</span></span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>示例代码：（深刻理解迭代器）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll.add(<span class="number">123</span>);</span><br><span class="line">coll.add(<span class="number">456</span>);</span><br><span class="line">coll.add(<span class="keyword">new</span> String(<span class="string">"Tom"</span>));</span><br><span class="line">coll.add(<span class="keyword">new</span> String(<span class="string">"Jack"</span>));</span><br><span class="line">coll.add(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误的方式</span></span><br><span class="line"><span class="comment">//Iterator iterator = coll.iterator();</span></span><br><span class="line"><span class="comment">//while(iterator.next() != null)&#123; //每次next都有移动指针</span></span><br><span class="line"><span class="comment">//System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//错误方式 ：每次iterator都会获取新的迭代器</span></span><br><span class="line"><span class="keyword">while</span>(coll.iterator().hasNext())&#123;</span><br><span class="line">System.out.println(coll.iterator().next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：（iterator中的remove）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll.add(<span class="number">123</span>);</span><br><span class="line">coll.add(<span class="number">456</span>);</span><br><span class="line">coll.add(<span class="keyword">new</span> String(<span class="string">"Tom"</span>));</span><br><span class="line">coll.add(<span class="keyword">new</span> String(<span class="string">"Jack"</span>));</span><br><span class="line">coll.add(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除Tom</span></span><br><span class="line">Iterator iterator = coll.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    <span class="comment">//iterator.remove(); //报错：IllegalStateException</span></span><br><span class="line">    Object object = iterator.next();</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"Tom"</span>.equals(object))&#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">        <span class="comment">//iterator.remove();报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(coll);</span><br></pre></td></tr></table></figure><ul><li>Iterator可以删除集合中的元素，但是在遍历过程中通过迭代器对象的remove()方法不是集合中的remove方法</li><li>如果还未调用next（）方法或多次调用remove方法都会报错</li></ul><p><strong>使用foreach循环遍历集合元素</strong></p><ul><li>jdk1.5之后提供了foreach循环迭代访问Collection和数组</li><li>foreach底层使用的迭代器方式</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">"Tom"</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">"Jack"</span>));</span><br><span class="line">    coll.add(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for(数据类型 变量：数组/集合)</span></span><br><span class="line">    <span class="keyword">for</span>(Object obj : coll)&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//方式一：</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方式二：增强for循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : arr)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>思考题：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String[] &#123; <span class="string">"mm"</span>, <span class="string">"mm"</span>, <span class="string">"mm"</span> &#125;;</span><br><span class="line"><span class="comment">// 方式一：</span></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//arr[i] = "GG";</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：</span></span><br><span class="line"><span class="keyword">for</span> (String str : arr) &#123;</span><br><span class="line">    str = <span class="string">"GG"</span>; <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、List接口"><a href="#4、List接口" class="headerlink" title="4、List接口"></a>4、List接口</h2><h3 id="4-1、List概述"><a href="#4-1、List概述" class="headerlink" title="4.1、List概述"></a>4.1、List概述</h3><ul><li>List集合有序，可重复。可看成“动态”数组，代替原来的数组</li></ul><p>核心实现类：</p><ul><li>ArrayList、<ul><li>LinkedList</li></ul></li><li>Vector</li></ul><p>核心实现类特点：（面试内容）</p><ul><li>ArrayList：作为List接口的主要实现类、线程不安全、效率高。<strong>底层使用Object[]数组实现存储</strong></li><li>LinkedList：<strong>底层使用双向链表存储数据，</strong>如果频繁添加，删除，插入元素则效率较高</li><li>Vector：古老的实现类、甚至出现在List接口之前，线程安全。效率低。底层使用Object[]数组实现存储</li></ul><h3 id="4-2、源码分析"><a href="#4-2、源码分析" class="headerlink" title="4.2、源码分析"></a>4.2、源码分析</h3><p><strong>ArrayList源码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment">默认构造器器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内部默认创建object[]数组保存数据</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment"> * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"><span class="comment">//jdk1.8初始状态创建了空&#123;&#125;数组</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment"> * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment"> * first element is added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向集合中添加元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加调用的方法</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123; <span class="comment">//参数 1</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; </span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); <span class="comment">//获取10</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//调用扩容方法</span></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//扩容方法</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//扩容的执行算法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment">     * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>ArrayList底层使用Object[]数组来存储数据，</li><li>add()添加元素、底层才初始数组长度，初始化数组的长度为10</li><li>每次扩充容量为1.5倍</li></ul><p><strong>LinkedList源码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to first node.</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first; <span class="comment">//第一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to last node.</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last; <span class="comment">//最后一个节点</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next; <span class="comment">//下一个节点</span></span><br><span class="line">        Node&lt;E&gt; prev; <span class="comment">//上一个节点</span></span><br><span class="line">         <span class="comment">//element：内容</span></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素的算法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Links e as last element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>LinkedList创建对象时，内部声明了Node类型的fist属性和last属性，默认为null</li><li>add（）添加，将内容添加到新建的node节点中，再讲新建的node和原来的建立关联</li><li>其中node创建方式体现了双向链表的结构</li></ul><p>Vector分析：</p><ul><li>创建Vector对象时，底层都使用了长度为10的数组，再扩容方式上和List一样，，默认每次扩容2倍</li></ul><p>面试题：</p><p>  ArrayList、LinkedList、Vector的异同，谈谈你的理解</p><h3 id="4-3、常用方法-collection之外的方法"><a href="#4-3、常用方法-collection之外的方法" class="headerlink" title="4.3、常用方法(collection之外的方法)"></a>4.3、常用方法(collection之外的方法)</h3><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="number">123</span>);</span><br><span class="line">list.add(<span class="number">456</span>);</span><br><span class="line">list.add(<span class="string">"abc"</span>);</span><br><span class="line">list.add(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在指定位置添加元素</span></span><br><span class="line">list.add(<span class="number">1</span>, <span class="string">"bbb"</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定位置的元素</span></span><br><span class="line">Object obj = list.get(<span class="number">5</span>); <span class="comment">//不能超出下标最大值</span></span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="number">123</span>);</span><br><span class="line">list.add(<span class="number">456</span>);</span><br><span class="line">list.add(<span class="string">"abc"</span>);</span><br><span class="line">list.add(<span class="number">123</span>);</span><br><span class="line">list.add(<span class="keyword">new</span> Person(<span class="string">"admin"</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">////获取集合中首次出现的元素的位置</span></span><br><span class="line"><span class="comment">//int i = list.indexOf(123);</span></span><br><span class="line"><span class="comment">//System.out.println(i);</span></span><br><span class="line"><span class="comment">////获取集合中最后一次出现的元素的位置</span></span><br><span class="line"><span class="comment">//int lastIndexOf = list.lastIndexOf(123);</span></span><br><span class="line"><span class="comment">//System.out.println(lastIndexOf);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">////返回删除的对象</span></span><br><span class="line"><span class="comment">//Object remove = list.remove(3);</span></span><br><span class="line"><span class="comment">//System.out.println(remove);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//boolean remove2 = list.remove("abc");</span></span><br><span class="line"><span class="comment">//System.out.println(remove2);</span></span><br><span class="line"><span class="comment">//System.out.println(list);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//boolean remove3 = list.remove(new Person("admin", 20));</span></span><br><span class="line"><span class="comment">//System.out.println(remove3);</span></span><br><span class="line"><span class="comment">//System.out.println(list);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改的效果</span></span><br><span class="line">list.set(<span class="number">1</span>, <span class="string">"cc"</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定区间的元素[ )</span></span><br><span class="line">List subList = list.subList(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">System.out.println(subList);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>增加：add(object obj)、</li><li>删：remove(int index)、remove(Object obj)</li><li>改：set（int index, object obj）</li><li>查：get(int index)</li><li>插入：add(int index, Object obj)</li><li>长度：size()</li><li>遍历：<ul><li>Iterator：迭代器</li><li>增强for循环</li><li>普通for  循环</li></ul></li></ul><p>面试题：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除时注意下标和对象的区别</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>); <span class="comment">//删除</span></span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">updateList(list);</span><br><span class="line">System.out.println(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateList</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line"><span class="comment">//list.remove(2); //下标2 </span></span><br><span class="line">list.remove(<span class="keyword">new</span> Integer(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、Set接口"><a href="#5、Set接口" class="headerlink" title="5、Set接口"></a>5、Set接口</h2><ul><li>set：存储无序的，不可重复的数据</li></ul><p><strong>核心实现类：</strong></p><ul><li>HashSet:<ul><li>LinkedHashSet（子类）</li></ul></li><li>TreeSet</li></ul><p><strong>核心实现类特点：</strong></p><ul><li>HashSet：所为set接口的主要实现类，线程不安全的，可以存储null值</li><li>LinkedHashSet：作为hashSet的子类，遍历数据时，可以按照添加的顺序遍历，对于操作频繁的元素，可以考虑使用，提供效率。LinkedHashSet的存储效率高于HashSet</li><li>TreeSet：可以按照添加对象的属性进行排序。要求添加的元素为同一类型</li></ul><p>实现原理：</p><p>添加的过程描述如：</p><ol><li>当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法 来得到该对象<br>的 hashCode 值，然后根据 hashCode 值，通过某种散列函数决定该对象 在 HashSet 底层数组<br>中的存储位置。（这个散列函数会与底层数组的长度相计算得到在 数组中的下标，并且这种散列<br>函数计算还尽可能保证能均匀存储元素，越是散列分布， 该散列函数设计的越好）</li><li>如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果 为true，添<br>加失败；如果为false，那么会保存该元素，但是该数组的位置已经有元素了， 那么会通过链表的<br>方式继续链接</li><li>如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相 等，hashSet 将会把<br>它们存储在不同的位置，但依然可以添加成功</li></ol><p>理解无序性，不可重复：</p><ol><li>无序性：表示存储的数据在底层的数组中并非按照数组的索引顺序添加，而是根据数据的哈希值决定</li><li>不可重复：为了保证元素的不可重写，我们需要重写hashcode和equals方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set set = <span class="keyword">new</span> HashSet();</span><br><span class="line">set.add(<span class="number">456</span>);</span><br><span class="line">set.add(<span class="number">123</span>);</span><br><span class="line">set.add(<span class="number">123</span>); <span class="comment">//重复的不能添加</span></span><br><span class="line">set.add(<span class="string">"aa"</span>);</span><br><span class="line"><span class="comment">//set.add("aa");</span></span><br><span class="line"><span class="comment">//set.add(new String("abc"));</span></span><br><span class="line"><span class="comment">//set.add(new String("abc")); //string重写hashcode和equeals</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要重写hashcode和equeals方法保证元素唯一性</span></span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="string">"tom"</span>, <span class="number">20</span>)); </span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="string">"tom"</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(set);</span><br></pre></td></tr></table></figure><p>总结：（面试）</p><ol><li>HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类</li><li>Set接口是Collection的子接口，set接口没有提供额外的方法</li><li>Set 判断两个对象是否相同不是使用 == 运算符，而是根据 equals() 方法</li><li>HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取、查找、删除性能</li><li>HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode() 方法比较相等，并且两个对象<br>的 equals() 方法返回值也相等</li><li>对于存放在Set容器中的对象，对应的类一定要重写equals() 和hashCode(Objectobj) 方法，以实<br>现对象相等规则 。即： “<strong>相等的对象必须具有相等的散列码“</strong></li></ol><p><strong>LinkedHashSet</strong></p><ul><li>LinkedHashSet 是 HashSet 的子类</li><li>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用<strong>双向链表维护元</strong><br><strong>素的次序</strong>，这使得元素看起来是以插入顺序保存的</li><li>LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能</li><li>LinkedHashSet 不允许集合元素重复</li></ul><p><strong>TreeSet</strong></p><ul><li>TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态</li><li>TreeSet底层使用 <strong>红黑树结构存储数据</strong></li><li>判断两个对象是否相等的唯一标准：<ul><li>自然排序使用： compareTo(Object obj) ==0判断相等，不再使用equals（）方法</li><li>定制排序使用：compare(Object o1, Object o2)判断相等， 不再使用equals（）方法</li><li>当需要把一个对象放入 TreeSet 中，重写该对象对应的 equals() 方法时，应保证该方法与<br>compareTo(Object obj) 方法有一致的结果：如果两个对象通过equals() 方法比较返回 true，<br>则通过 compareTo(Object obj) 方法比较应返回 0</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定制排序</span></span><br><span class="line">Comparator&lt;Person&gt; com = <span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//姓名 a -- z</span></span><br><span class="line"><span class="comment">//return o1.getName().compareTo(o2.getName());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// z--a 当姓名相同时，判断年龄</span></span><br><span class="line"><span class="keyword">int</span> res = o1.getName().compareTo(o2.getName());</span><br><span class="line"><span class="keyword">if</span>(res == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> -Integer.compare(o1.getAge(), o2.getAge());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeSet&lt;Person&gt; set = <span class="keyword">new</span> TreeSet&lt;Person&gt;(com);</span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="string">"a"</span>, <span class="number">12</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="string">"b"</span>, <span class="number">20</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="string">"c"</span>, <span class="number">24</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="string">"d"</span>, <span class="number">26</span>));</span><br><span class="line"><span class="comment">//姓名相同，年龄不同为不同对象，需要添加到容器中，判断标准为compareTo</span></span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="string">"e"</span>, <span class="number">10</span>)); </span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="string">"e"</span>, <span class="number">33</span>));</span><br><span class="line"><span class="comment">//set.add("abc");</span></span><br><span class="line"></span><br><span class="line">System.out.println(set);</span><br></pre></td></tr></table></figure><h2 id="6、Map接口"><a href="#6、Map接口" class="headerlink" title="6、Map接口"></a>6、Map接口</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- map：双列数据、存储key-value对数据</span><br></pre></td></tr></table></figure><p>核心实现类：</p><ul><li>HashMap<ul><li>LinkedHashMap(子类)</li></ul></li><li>TreeMap</li><li>Hashtable<ul><li>Properties（子类）</li></ul></li></ul><p>实现类特点：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- HashMap：作为Map接口的主要实现类，线程不安全的，效率高。存储null的key和value，底层使用数组+链表（jdk7）， 数组+链表+红黑树（jdk8）</span><br><span class="line">- LinkedHashMap：实现了遍历map集合中元素的顺序和添加的顺序一直。以为在原有的HashMap的底层结构中添加了一对指针，指向前一个和后一个元素。所以对于频繁的操作，此执行效率高于HashMap</span><br><span class="line">- TreeMap：可以按照key-value对进行排序，实现排序遍历，此时考虑key的自然排序和定制排序的使用</span><br><span class="line">- Hashtable：作为古老的实现类，线程安全的，效率低，不能存储null的key或value</span><br><span class="line">- Properties：常用来作为配置文件，key和value都是String类型</span><br></pre></td></tr></table></figure><p>map常用方法：</p><p><img src="https://img-blog.csdn.net/20171013141128526?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM2ODM4NjMw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><h3 id="6-1-Map结构的理解"><a href="#6-1-Map结构的理解" class="headerlink" title="6.1 Map结构的理解"></a>6.1 Map结构的理解</h3><p>map结构的理解：</p><ul><li>Map中的key是无序的，不能重复的。使用set存储所有的key  ---- &gt;key所在的类必须重写equals和hashcode方法</li><li>Map中的value是无序的，可重复的，使用collection存储所有的value  ---&gt; value所在的类重写equals()方法</li><li>一个键值对： key-value构成了一个Entry对象</li><li>Map中的Entry是无序的，不可重复的，使用set存储所有的entry</li></ul><h3 id="6-2-HashMap的底层实现原理"><a href="#6-2-HashMap的底层实现原理" class="headerlink" title="6.2 HashMap的底层实现原理"></a>6.2 HashMap的底层实现原理</h3><p>JDK8：HashMap使用的是数组+链表+红黑树实现</p><p>JDK7：HashMap使用的是数组+链表</p><h3 id="6-3、LinkedHashMap"><a href="#6-3、LinkedHashMap" class="headerlink" title="6.3、LinkedHashMap"></a>6.3、LinkedHashMap</h3><ul><li>在HashMap的存储结构的基础上，使用了一对双向链表来记录添加的元素顺序</li><li>迭代顺序和添加顺序一致</li></ul><p><strong>常用方法：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line"><span class="comment">//添加</span></span><br><span class="line">map.put(<span class="number">123</span>, <span class="string">"AA"</span>);</span><br><span class="line">map.put(<span class="number">456</span>, <span class="string">"BB"</span>);</span><br><span class="line">map.put(<span class="number">789</span>, <span class="string">"CC"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line">map.put(<span class="number">123</span>, <span class="string">"dd"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Map map1 = <span class="keyword">new</span> HashMap();</span><br><span class="line">map1.put(<span class="string">"cc"</span>, <span class="number">123</span>);</span><br><span class="line">map1.put(<span class="string">"dd"</span>, <span class="number">456</span>);</span><br><span class="line">map.putAll(map1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//remove</span></span><br><span class="line">Object obj = map.remove(<span class="string">"cc"</span>);</span><br><span class="line">System.out.println(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">//clear</span></span><br><span class="line">map.clear();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">"AA"</span>, <span class="number">123</span>);</span><br><span class="line">map.put(<span class="number">45</span>, <span class="number">123</span>);</span><br><span class="line">map.put(<span class="string">"bb"</span>, <span class="number">67</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//get（）</span></span><br><span class="line">Object value = map.get(<span class="string">"AA"</span>);</span><br><span class="line">System.out.println(value);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断key是否存在</span></span><br><span class="line"><span class="keyword">boolean</span> key = map.containsKey(<span class="string">"bb"</span>);</span><br><span class="line">System.out.println(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断value</span></span><br><span class="line"><span class="keyword">boolean</span> containsValue = map.containsValue(<span class="number">67</span>);</span><br><span class="line">System.out.println(containsValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Empty：内容空   null：没有地址</span></span><br><span class="line">map.clear();  </span><br><span class="line">System.out.println(map.isEmpty());</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">"AA"</span>, <span class="number">123</span>);</span><br><span class="line">map.put(<span class="number">45</span>, <span class="number">123</span>);</span><br><span class="line">map.put(<span class="string">"bb"</span>, <span class="number">67</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历所有的key</span></span><br><span class="line">Set keySet = map.keySet();</span><br><span class="line">Iterator iterator = keySet.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    Object next = iterator.next();</span><br><span class="line">    System.out.print(next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"\n---------"</span>);</span><br><span class="line"><span class="comment">//遍历所有的value</span></span><br><span class="line">Collection values = map.values();</span><br><span class="line"><span class="keyword">for</span>(Object obj:values)&#123;</span><br><span class="line">    System.out.print(obj);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"\n---------"</span>);</span><br><span class="line"><span class="comment">//方式一：entrySet </span></span><br><span class="line">Set entrySet = map.entrySet();</span><br><span class="line">Iterator iterator2 = entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator2.hasNext())&#123;</span><br><span class="line">    Object next = iterator2.next();</span><br><span class="line">    <span class="comment">//entry/node</span></span><br><span class="line">    Entry entry = (Entry)next;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">"---"</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"\n---------"</span>);</span><br><span class="line"><span class="comment">//方式二:</span></span><br><span class="line">Set keySet2 = map.keySet(); <span class="comment">//所有的key</span></span><br><span class="line">Iterator iterator3 = keySet2.iterator(); </span><br><span class="line"><span class="keyword">while</span>(iterator3.hasNext())&#123;<span class="comment">//遍历所有key</span></span><br><span class="line">    Object key = iterator3.next(); <span class="comment">//key</span></span><br><span class="line">    Object value = map.get(key); <span class="comment">//根据key获取value</span></span><br><span class="line">    System.out.println(key + <span class="string">"---"</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>添加：put（Object key, Object vlaue）</p><p>修改：put（Object key, Object vlaue）</p><p>删除：remove(Object key)</p><p>查询：get（object key）</p><p>长度：size（）</p><p>遍历： keySet () / values() /  entrySet() ---key-value = entry</p><h3 id="6-4-TreeMap"><a href="#6-4-TreeMap" class="headerlink" title="6.4 TreeMap"></a>6.4 TreeMap</h3><ul><li>TreeMap可以实现所有的kev-value处于有序状态</li><li>TreeMap底层使用<strong>红黑树数据结构</strong>存储</li><li>TreeMap的key的排序：<ul><li>自然排序：TreeMap的所有的key必须实现Comparable接口，而且所有的key必须为同一类对象，否则抛出ClassCastException异常</li><li>定制排序：创建TreeMap时，传入一个Compartor接口的实现类，该对象负责对TreeMap中的所有key进行排序</li></ul></li><li>TreeMap判断两个key相等的标准：两个key通过compareTo()或compare() ==  0</li></ul><p>演示代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line"><span class="comment">//姓名自然顺序 0 , 1  -1</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.getName().compareTo(o.getName());</span><br><span class="line"><span class="comment">//return this.getName() - o.getName();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeMap map = <span class="keyword">new</span> TreeMap();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> String();</span><br><span class="line"><span class="comment">//方式一：</span></span><br><span class="line"><span class="comment">//map.put("c", 3);</span></span><br><span class="line"><span class="comment">//map.put("b", 3);</span></span><br><span class="line"><span class="comment">//map.put("d", 3);</span></span><br><span class="line"><span class="comment">//map.put("e", 3);</span></span><br><span class="line"><span class="comment">//map.put("a", 3);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">map.put(<span class="keyword">new</span> Person(<span class="string">"a"</span>,<span class="number">20</span>), <span class="number">90</span>);</span><br><span class="line">map.put(<span class="keyword">new</span> Person(<span class="string">"c"</span>,<span class="number">20</span>), <span class="number">90</span>);</span><br><span class="line">map.put(<span class="keyword">new</span> Person(<span class="string">"d"</span>,<span class="number">20</span>), <span class="number">90</span>);</span><br><span class="line">map.put(<span class="keyword">new</span> Person(<span class="string">"b"</span>,<span class="number">20</span>), <span class="number">90</span>);</span><br><span class="line">map.put(<span class="keyword">new</span> Person(<span class="string">"f"</span>,<span class="number">20</span>), <span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeMap map = <span class="keyword">new</span> TreeMap(<span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> -o1.getName().compareTo(o2.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">map.put(<span class="keyword">new</span> Person(<span class="string">"a"</span>,<span class="number">20</span>), <span class="number">90</span>);</span><br><span class="line">map.put(<span class="keyword">new</span> Person(<span class="string">"c"</span>,<span class="number">20</span>), <span class="number">90</span>);</span><br><span class="line">map.put(<span class="keyword">new</span> Person(<span class="string">"d"</span>,<span class="number">20</span>), <span class="number">90</span>);</span><br><span class="line">map.put(<span class="keyword">new</span> Person(<span class="string">"b"</span>,<span class="number">20</span>), <span class="number">90</span>);</span><br><span class="line">map.put(<span class="keyword">new</span> Person(<span class="string">"f"</span>,<span class="number">20</span>), <span class="number">90</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure><h3 id="6-5-Properties"><a href="#6-5-Properties" class="headerlink" title="6.5 Properties"></a>6.5 Properties</h3><ul><li>Properties该对象是属性文件，常用来保存配置信息</li><li>属性文件中的内容都为String类型</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream input = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//System.out.println(new File("/java_collection/src/db.properties").getPath());</span></span><br><span class="line">        <span class="comment">//创建文件输入流</span></span><br><span class="line">        input = <span class="keyword">new</span> FileInputStream(<span class="string">"db.properties"</span>);</span><br><span class="line">        <span class="comment">//创建配置文件对象</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//加载配置文件信息</span></span><br><span class="line">        pro.load(input); <span class="comment">//配置信息加载到pro对象中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取配置文件对象中保存的数据</span></span><br><span class="line">        String user = pro.getProperty(<span class="string">"user"</span>);</span><br><span class="line">        String password = pro.getProperty(<span class="string">"password"</span>);</span><br><span class="line">        System.out.println(user + <span class="string">"---"</span> + password);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(input != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                input.close();</span><br><span class="line">                input = <span class="keyword">null</span>; <span class="comment">//gc</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="7、Collections工具类"><a href="#7、Collections工具类" class="headerlink" title="7、Collections工具类"></a>7、Collections工具类</h2><ul><li>Collections是操作Set、List、Map集合的工具类</li><li>Collection中提供了一系列的静态方法对集合中的元素进行排序、查询、修改等操作，还提供了对集合中对象设置不可变性，同步等方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="number">123</span>);</span><br><span class="line">list.add(<span class="number">23</span>);</span><br><span class="line">list.add(<span class="number">45</span>);</span><br><span class="line">list.add(<span class="number">33</span>);</span><br><span class="line">list.add(<span class="number">78</span>);</span><br><span class="line">list.add(<span class="number">33</span>);<span class="comment">//6</span></span><br><span class="line"></span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转</span></span><br><span class="line"><span class="comment">//Collections.reverse(list);</span></span><br><span class="line"><span class="comment">//随机排序</span></span><br><span class="line"><span class="comment">//Collections.shuffle(list);</span></span><br><span class="line"><span class="comment">//自然排序</span></span><br><span class="line"><span class="comment">//Collections.sort(list);</span></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="comment">//Collections.swap(list, 1, 2);</span></span><br><span class="line"><span class="comment">//返回指定集合中指定的元素出现的次数</span></span><br><span class="line"><span class="comment">//int i = Collections.frequency(list, 33);</span></span><br><span class="line"><span class="comment">//System.out.println(i);</span></span><br><span class="line"><span class="comment">//System.out.println(list);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//容器初始大小为6，元素个数为零 size() == 0</span></span><br><span class="line"><span class="comment">//List dest = new ArrayList(6);</span></span><br><span class="line"><span class="comment">//copy</span></span><br><span class="line">List dest = Arrays.asList(<span class="keyword">new</span> Object[list.size()]);</span><br><span class="line">Collections.copy(dest, list);</span><br><span class="line">System.out.println(dest);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回线程安全的list</span></span><br><span class="line">List list2 = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure><h2 id="8-面试"><a href="#8-面试" class="headerlink" title="8 面试"></a>8 面试</h2><ol><li>ArrayList, LinkedList, Vector, Stack是List的4个实现类，比较他们的异同。 </li></ol><ul><li>ArrayList 是一个数组队列，相当于动态数组。它由数组实现，随机访问效率高，随机插入、随机删除效率低。 </li><li>LinkedList 是一个双向链表。它也可以被当作堆栈、队列或双端队列进行操作。LinkedList随机访问效率低，但随机插入、随机删除效率高。</li><li>Vector 是矢量队列，和ArrayList一样，它也是一个动态数组，由数组实现。但是ArrayList是非线程安全的，而Vector是线程安全的。 </li><li>Stack 是栈，它继承于Vector。它的特性是：先进后出(FILO, First In Last Out)。</li></ul><ol start="2"><li>HashMap、HashTable、TreeMap的区别 <ul><li>HashMap是键值对的方式存储的，但不能保证次序，单线程</li><li>HashTable与HashMap存储方式相同，但是是线程安全的； </li><li>TreeMap是有序的键值对，基于红黑树排序。</li></ul></li></ol><hr><p>参考链接[1]：https://blog.csdn.net/u010648555/article/details/56049460</p><p>参考链接[2]：https://blog.csdn.net/Jungle_Rao/article/details/81390270</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集合&quot;&gt;&lt;a href=&quot;#集合&quot; class=&quot;headerlink&quot; title=&quot;集合&quot;&gt;&lt;/a&gt;集合&lt;/h1&gt;&lt;h2 id=&quot;1、集合框架概述&quot;&gt;&lt;a href=&quot;#1、集合框架概述&quot; class=&quot;headerlink&quot; title=&quot;1、集合框架概述&quot;
      
    
    </summary>
    
      <category term="javase" scheme="https://theme-next.org/categories/javase/"/>
    
    
      <category term="javase" scheme="https://theme-next.org/tags/javase/"/>
    
  </entry>
  
  <entry>
    <title>java04字符串</title>
    <link href="https://theme-next.org/java04%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://theme-next.org/java04字符串/</id>
    <published>2019-08-09T17:02:01.000Z</published>
    <updated>2019-08-11T06:43:15.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串相关类"><a href="#字符串相关类" class="headerlink" title="字符串相关类"></a>字符串相关类</h2><ol><li><p>String类：代表一字符串，Java中所有的字符串字面量（如“abc”）都作为次类的实例实现</p></li><li><p>string是一个final类，<strong>代表不可变的字符序列</strong></p></li><li><p>字符串是常量，用双引号引起来，，它的值在赋值之后不能改变</p></li><li><p>String对象的字符内容是存储在一个字符数组value[]中的</p></li></ol><p>源码实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//string是不可变类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[]; <span class="comment">//保持字符串内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br></pre></td></tr></table></figure><p><strong>字面量的定义方式</strong></p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"abc"</span>;</span><br><span class="line">String str2 = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(str.equals(str2)); //true</span></span><br><span class="line">System.out.println(str == str2);<span class="comment">//true 以为常量池中有相同的数据，所以java会把str的地址赋值为str2</span></span><br><span class="line"></span><br><span class="line">str = <span class="string">"123"</span>; <span class="comment">//因为字符串的不可变性，java会创建一个新的地址赋值给str</span></span><br><span class="line">System.out.println(str == str2); <span class="comment">//false</span></span><br><span class="line"><span class="comment">//解释如下图</span></span><br></pre></td></tr></table></figure><p><img src="%E5%AD%97%E7%AC%A6%E4%B8%B21.png" alt></p><p><strong>String  str = &quot;abc&quot; 于 String str = new String(&quot;abc&quot;) 区别</strong></p><ul><li>字符串常量存储在常量池中，目的是共享信息</li><li>new字符串对象存储在堆中</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"abc"</span>;</span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">"abc"</span>); <span class="comment">//创建对象，放入堆中</span></span><br><span class="line">String str4 = <span class="keyword">new</span> String(<span class="string">"abc"</span>); <span class="comment">//创建对象放入堆中</span></span><br><span class="line">System.out.println(str1 == str3); <span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str4); <span class="comment">//false</span></span><br><span class="line">System.out.println(str1.equals(str3)); <span class="comment">//true 因为string类重写object的equeals方法，故只判断内容相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//itern方法返回常量池中保存的地址</span></span><br><span class="line">System.out.println(str1 == str3.intern()); <span class="comment">//true 因为str和str3内容相同，常量池中只保存一份</span></span><br></pre></td></tr></table></figure><p><img src="%E5%AD%97%E7%AC%A6%E4%B8%B22.png" alt="1563351486200"></p><ul><li>常量于常量拼接的结果在常量池中，且常量池中不会存在相同的内容</li><li>只要其中有一个是变量，结果就在堆中</li><li>如果拼接的结果调用intern()方法，则返回值就在常量池中</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"hello"</span>;</span><br><span class="line">String str2 = <span class="string">"world"</span>;</span><br><span class="line">String str3 = <span class="string">"hello"</span> + <span class="string">"world"</span>;</span><br><span class="line">String str4 = str1 + <span class="string">"world"</span>;</span><br><span class="line">String str5 = str1 + str2;</span><br><span class="line">String str6 = (str1 + str2).intern();</span><br><span class="line"></span><br><span class="line">System.out.println(str3 == str4); <span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5); <span class="comment">//false</span></span><br><span class="line">System.out.println(str4 == str5); <span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str6);<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>进一步理解string的不可变性：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"小明"</span>,<span class="number">20</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"小明"</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(p1 == p2); <span class="comment">//false</span></span><br><span class="line">System.out.println(p1.name == p2.name); <span class="comment">//true  不同对象中的string属性保存在同一个常量池中</span></span><br></pre></td></tr></table></figure><p>理解视图：</p><p><img src="%E5%AD%97%E7%AC%A6%E4%B8%B23.png" alt="1563354067440"></p><p>思考题：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.woniu.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"good"</span>);</span><br><span class="line"><span class="keyword">char</span>[] ch = &#123;<span class="string">'t'</span>,<span class="string">'e'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>  i =<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str, <span class="keyword">char</span>[] ch , <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="comment">//System.out.println(i + "-----");</span></span><br><span class="line"><span class="comment">//System.out.println(str + "------");</span></span><br><span class="line">str = <span class="string">"test ok"</span>;<span class="comment">//</span></span><br><span class="line"><span class="comment">//System.out.println(str + "========");</span></span><br><span class="line">ch[<span class="number">0</span>] = <span class="string">'b'</span>;</span><br><span class="line">i = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">StringTest2 test = <span class="keyword">new</span> StringTest2();</span><br><span class="line"></span><br><span class="line">test.change(test.str, test.ch,test.i);</span><br><span class="line"></span><br><span class="line">System.out.println(test.str); <span class="comment">//good</span></span><br><span class="line">System.out.println(test.ch); <span class="comment">//best</span></span><br><span class="line">System.out.println(test.i); <span class="comment">//10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充：参数传递</p><ul><li>参数传递本质上都是值传递，将变量存储的内容复制一份给方法调用的形参</li><li>值类型数据：变量保存的是数据本身，所以传递是复制数据本身</li><li>引用类型：变量保存的是引用（地址），所以传递的是地址，如果方法内部对传递的数据进行修改，会影响到原来的数据。</li></ul><p>​    理解图示：</p><p><img src="%E5%AD%97%E7%AC%A6%E4%B8%B24.png" alt="1563356131596"></p><p><strong>String常用方法：</strong></p><table><thead><tr><th>返回值<strong>Modifier and Type</strong></th><th>方法名</th></tr></thead><tbody><tr><td>int</td><td><strong>length</strong>() ：获取字符串的长度</td></tr><tr><td>char</td><td>charAt(int index):获取字符串中的一个字符</td></tr><tr><td>int</td><td>indexOf(String str) ：返回传入的字符串出现的首位置</td></tr><tr><td>boolean</td><td><strong>startsWith</strong>(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" target="_blank" rel="noopener">String</a> prefix) ： 返回原字符串是否为传入的字符串开头</td></tr><tr><td>boolean</td><td>endsWith(String suffix):是否为以指的的字符串结尾</td></tr><tr><td>string</td><td>toLowerCase()：返回原来的字符串小写</td></tr><tr><td>string</td><td>toUpperCase()：返回原来的字符串大写</td></tr><tr><td>string</td><td><strong>substring</strong>(int beginIndex) :从指定下标到结束</td></tr><tr><td>string</td><td><strong>substring</strong>(int beginIndex, int endIndex) : 包含开始，不包含结束</td></tr></tbody></table><p>作业：</p><p>1、验证邮箱的正确行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 必须包含点（.）和@符号</span><br><span class="line">- 点（.）必须在@符号之后</span><br><span class="line">- @只能出现一次</span><br><span class="line">- @和点直接必须有字符</span><br><span class="line">- 不能使用中文</span><br></pre></td></tr></table></figure><p>2、过滤不文明词汇</p><p>​    “中国足球真TM烂，TM的。TM的烂”</p><p><strong>字符串和基本类型转换</strong></p><ol><li>基本类型---&gt;字符串，<ul><li>可以用一个空的“”号相加</li></ul></li><li>字符---&gt;基本类型：<ul><li>包装类.parseXXX(&quot;&quot;)</li></ul></li></ol><p><strong>StringBuider 和stringBuffer的区别</strong></p><p>StringBuffer：</p><p>查看源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>[] value;  <span class="comment">//可变字符序列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">//字符串长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br></pre></td></tr></table></figure><p>默认初始值大小</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs a string buffer with no characters in it and an</span></span><br><span class="line"><span class="comment">    * initial capacity of 16 characters.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(<span class="number">16</span>); <span class="comment">//调用父类方法创建stringBuffer字符串</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates an AbstractStringBuilder of the specified capacity.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">       value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity]; <span class="comment">//创建大小为16的字符数组</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- StringBuffer初始大小为16个字符，如果我们的操作的字符大于16个建议创建时给初始大小</span><br><span class="line">- 可变字符序列</span><br><span class="line">- 线程安全，效率低</span><br></pre></td></tr></table></figure><p>面试题：string、stringBuffer、StringBuilder的区别</p><ul><li>string（JDK1.0） : 不可变序列</li><li>StringBuffer（JDK1.0）：可变序列，效率低，线程安全</li><li>StringBuilder（JDK1.5）：可变序列，效率高，线程不安全</li></ul><p>查看三者之间的效率：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.woniu.demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringEfficiencyTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> startTime = <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">long</span> endTime = <span class="number">0L</span>;</span><br><span class="line">String text = <span class="string">""</span>;</span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始对比</span></span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">buffer.append(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"StringBuffer的执行时间："</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">builder.append(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"StringBuilder的执行时间："</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">text = text + i;</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"String的执行时间："</span> + (endTime - startTime));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>==和equals</strong></p><ul><li>== 是操作符、equals是方法</li></ul><p>==：</p><ul><li>基本类型：== 只要值相等返回true</li><li>引用类型：== 判断是否为变量中为同一地址，相同返回ture</li></ul><p>equals：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 所有的类都继承了父类（java.lang.Object）中的equals方法</span><br><span class="line">- object中的equals和==本质上是相同的结果</span><br></pre></td></tr></table></figure><p>特例：</p><ul><li>当使用equels方法进行比较时，对File ，String、Data及包装类，来说比较的是内容，而不考虑是否为同一个引用</li><li>当自定义对象是，我们可以考虑重写Object中继承的equals方法，用于比较对象的“内容”是否相同</li></ul><p>源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">*/</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">this</span> == obj); <span class="comment">//比较的还是地址</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>总结：面试题： == 和equals区别</p><p>1、== 即可以比较基本类型也可以比较引用类型，对于基本类型比较的就是值，对于引用类型比较的内存地址</p><p>2、equlas、它是Object类中的方法，如果该方法没有被重写则默认使用==. 我们经常使用的string等类。equals方法被重写，比较的是“内容”。</p><p>3、通常情况下，我们重写equals方法，会比较类中的相应属性是否相等</p><h2 id="Sting常用转换"><a href="#Sting常用转换" class="headerlink" title="Sting常用转换"></a>Sting常用转换</h2><h3 id="基本类型-gt-字符串："><a href="#基本类型-gt-字符串：" class="headerlink" title="基本类型--&gt;字符串："></a>基本类型--&gt;字符串：</h3><ol><li><p>使用包装类的 toString() 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> c=<span class="number">10</span>;</span><br><span class="line">String str1=Integer.toString(c);</span><br><span class="line">System.out.println(<span class="string">"toString 方法转化的字符串："</span>+str);</span><br></pre></td></tr></table></figure></li><li><p>使用String类的 valueOf() 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str2=String.valueOf(c);</span><br><span class="line">System.out.println(<span class="string">"使用String类的valueOf（）方法转化的字符串"</span>+str2);</span><br></pre></td></tr></table></figure></li><li><p>用一个空字符串加上基本类型，得到的就是基本类型数据对应的字符串</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str3=c+<span class="string">""</span>;</span><br><span class="line">System.out.println(<span class="string">"使用控制符串添加的到的字符串："</span>+str3);</span><br></pre></td></tr></table></figure></li></ol><h3 id="字符串-gt-基本类型："><a href="#字符串-gt-基本类型：" class="headerlink" title="字符串--&gt;基本类型："></a>字符串--&gt;基本类型：</h3><ol><li><p>调用包装类的 parseXxx 静态方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=<span class="string">"8"</span>;</span><br><span class="line"><span class="keyword">int</span> d=Integer.parseInt(str);</span><br><span class="line">System.out.println(<span class="string">"调用包装类的parse转化："</span>+d);</span><br></pre></td></tr></table></figure></li><li><p>调用包装类的 valueOf() 方法转换为基本类型的包装类，会自动拆箱</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> e=Integer.valueOf(str);</span><br><span class="line">System.out.println(<span class="string">"调用valueOf方法转化："</span>+e);</span><br></pre></td></tr></table></figure></li></ol><h3 id="数组-gt-字符串"><a href="#数组-gt-字符串" class="headerlink" title="数组 --&gt; 字符串"></a>数组 --&gt; 字符串</h3><ol><li><p>字符数组--&gt;字符串</p><p>String 类的构造器：String(char value[])、String(char value[], int offffset, int count) </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用String(char value[])构造器</span></span><br><span class="line"><span class="keyword">char</span>[] c =&#123;<span class="string">'中'</span>,<span class="string">'国'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>&#125;;</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(c));<span class="comment">//中国345</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用String(char value[], int offffset, int count)</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(c,<span class="number">1</span>,<span class="number">3</span>));<span class="comment">//国34</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line">String[] arr = &#123; <span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span> &#125;;</span><br><span class="line">StringBuffer str5 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">    str5.append(s);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(str5.toString()); <span class="comment">// 012345</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>字节数组---&gt;字符串</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用String(byte bytes[])构造器</span></span><br><span class="line"><span class="keyword">byte</span>[] b = &#123;<span class="string">'a'</span>,<span class="string">'1'</span>,<span class="string">'b'</span>&#125;;</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(b));<span class="comment">//a1b</span></span><br><span class="line"><span class="comment">//String(byte bytes[], int offffset, int length)</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(b,<span class="number">1</span>,<span class="number">2</span>));<span class="comment">//1b</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="字符串-gt-数组"><a href="#字符串-gt-数组" class="headerlink" title="字符串 --&gt; 数组"></a>字符串 --&gt; 数组</h3><ol><li><p>字符串--&gt;字符数组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.char[] toCharArray()</span></span><br><span class="line">String str1 = <span class="string">"hello"</span>;</span><br><span class="line">System.out.println(str1.toCharArray());<span class="comment">//hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.getChars(char dst[], int dstBegin)</span></span><br><span class="line">    String str1 = <span class="string">"hello"</span>;</span><br><span class="line">str1.getChars(<span class="number">0</span>, <span class="number">5</span>, str1, <span class="number">0</span>);<span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.当字符串中含有特定字符需要转义符</span></span><br><span class="line"><span class="comment">// 字符串转数组  java.lang.String</span></span><br><span class="line">    String str = <span class="string">"0,1,2,3,4,5"</span>;</span><br><span class="line">    String[] arr = str.split(<span class="string">","</span>); <span class="comment">// 用,分割</span></span><br><span class="line">    System.out.println(Arrays.toString(arr)); <span class="comment">// [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>字符串---&gt;字节数组</p><p>byte[] getBytes()：使用平台的默认字符集将此 String 编码为byte 序列，并将结果存储到一 </p><p>个新的 byte 数组中 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"中"</span>; </span><br><span class="line">System.out.println(str.getBytes(<span class="string">"ISO8859-1"</span>).length);<span class="comment">// -128~127 </span></span><br><span class="line">System.out.println(str.getBytes(<span class="string">"GBK"</span>).length); System.out.println(str.getBytes(<span class="string">"UTF-8"</span>).length); System.out.println(<span class="keyword">new</span> String(str.getBytes(<span class="string">"ISO8859-1"</span>), <span class="string">"ISO8859-1"</span>));<span class="comment">// 乱码，表示不了中文 </span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(str.getBytes(<span class="string">"GBK"</span>), <span class="string">"GBK"</span>)); System.out.println(<span class="keyword">new</span> String(str.getBytes(<span class="string">"UTF-8"</span>), <span class="string">"UTF-8"</span>));</span><br></pre></td></tr></table></figure><p>byte[] getBytes(String charsetName)：使用指定的字符集将此 String 编码到 byte 序列，并 </p><p>将结果存储到新的 byte 数组</p></li></ol><h3 id="Stringbuffer-、Stringbuilder-、String区别"><a href="#Stringbuffer-、Stringbuilder-、String区别" class="headerlink" title="Stringbuffer 、Stringbuilder 、String区别"></a>Stringbuffer 、Stringbuilder 、String区别</h3><p>String程序运行时会额外创建一个对象，保存String的字符串。当频繁操作字符串时，就会额外产生很多临时变量。StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。至于 StringBuilder 和StringBuffer ，它们基本相似，不同之处，StringBuffer 是线程安全的，而 StringBuilder 则没有实现线程安全功能（不能同步访问），所以性能略高。因此一般情况下，如果需要创建一个内容可变的字符串对象，应优先考虑使用 StringBuffer 类。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h1&gt;&lt;h2 id=&quot;字符串相关类&quot;&gt;&lt;a href=&quot;#字符串相关类&quot; class=&quot;headerlink&quot; title=&quot;字符串相关类&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="javase" scheme="https://theme-next.org/categories/javase/"/>
    
    
      <category term="javase" scheme="https://theme-next.org/tags/javase/"/>
    
  </entry>
  
  <entry>
    <title>java03面向对象</title>
    <link href="https://theme-next.org/java03%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://theme-next.org/java03面向对象/</id>
    <published>2019-08-09T17:01:03.000Z</published>
    <updated>2019-08-11T21:43:49.489Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面向对象（Oriented-Object）"><a href="#面向对象（Oriented-Object）" class="headerlink" title="面向对象（Oriented Object）"></a>面向对象（Oriented Object）</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote><pre><code>OOP（面向对象编程）、OOD(面向对象设计)、OOA（面向对象的分析）Object Oriented Programming </code></pre></blockquote><p>是相对于面向过程而言的，过程其实就是函数，对象是将函数和属性进行了封装。</p><ol><li>抽象会使复杂的问题简单化，</li><li>从以前执行者变成指挥者，</li><li>面向对象更符合人类思维，面向过程符合机器思想。</li></ol><h4 id="面向对象和面向过程区别"><a href="#面向对象和面向过程区别" class="headerlink" title="面向对象和面向过程区别"></a>面向对象和面向过程区别</h4><ul><li><p>面向过程：事物比较简单，可以用线性的思维去解决。 </p></li><li><p>面向对象：事物比较复杂，使用简单的线性思维无法解决。</p></li><li><p>共同点：都是解决实际问题的一种思维方式。解决复杂问题，通过面向对象方式便于我们从宏观上把握事物之间复杂的关系，方便我们分析整个系统；具体到微观操作，仍然使用面向过程方式来处理。</p></li></ul><h3 id="重要概念（重点）"><a href="#重要概念（重点）" class="headerlink" title="重要概念（重点）"></a>重要概念（重点）</h3><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><ol><li>定义：接收消息的实体，一切皆为对象，对象都有属性和行为，对象都属于某个类，每个对象都独一无二。</li><li>属性：对象的特征，一般是名词</li><li>行为：对象可以做的事情，一般是动词</li></ol><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><ol><li><p>定义：具有相同属性和行为的对象的集合。类是模子，确定对象将会拥有的属性和行为。</p></li><li><p>要素：</p><p>​     创建对象的蓝图和模板</p><p>​     类的属性：数据抽象</p><p>​     类的方法：行为抽象 </p><p>​     构造器（构造方法）</p></li><li><p>分为普通类和抽象类</p></li></ol><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li><p>成员变量</p><ol><li>类中，方法外</li><li>有默认值</li><li>存在堆内存</li><li>随着对象的创建而创建，销毁而销毁</li><li>访问方式：对象.成员变量</li></ol></li><li><p>局部变量</p><ol><li>方法中，参数上，语句中。</li><li>没有默认值，必须初始化</li><li>局部变量只在自己所属的大括号内有效，大括号结束，局部变量失去作用域。</li><li>局部变量存在于栈内存中，随着所属区域的运行而存在，结束而释放。</li></ol></li><li><p>静态变量</p><p>见 static关键字</p></li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>方法的参数传递：</p><ol><li><p>值传递</p><p>(形式参数类型是基本数据类型)：方法调用时，实际参数把它的值传递给对应的形式参数，形式参数只是用实际参数的值初始化自己的存储单元内容，是两个不同的存储单元，所以方法执行中形式参数值的改变不影响实际参数的值。</p></li><li><p>引用传递</p><p>(形式参数类型是引用数据类型参数)：也称为传地址。方法调用时，实际参数是对象(或数组)，这时实际参数与形式参数指向同一个地址，在方法执行中，对形式参数的操作实际上就是对实际参数的操作，这个结果在方法结束后被保留了下来，所以方法执行中形式参数的改变将会影响实际参数。</p></li></ol><p><img src="http://images.cnitblog.com/blog/362101/201411/081053385189779.png" alt="111"></p><p>测试总结：</p><p>值传递就是值的拷贝，包括基本类型，如int、long等，也包括基本变量类型包装类String、Long、Integer等，虽说是类但使用的是值传递(经过测试)</p><p> 引用传递就是地址的拷贝，常见的有对象等</p><p>形参与实参说明:  在一个方法中,比如method1(Object o)中,O就是形参,形参就是形式参数,当你调用这个方法时,要传入一个值,这个值叫做实际参数,也叫实参,形参你可以理解成一个占位符(为传入实参占一个位置).</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><pre><code> 1. 每一个类有一个默认的隐式的无参数的构造方法 **特征**：1. 名称和类名一样2. 无返回值类型3. 创建对象的时候调用4. 构造方法一般用来给属性赋初始值（set方法侧重于修改属性值）5. 如果一个类中写了带参数的构造方法，那么默认的隐式的无参数的构造 方法就会消失6. 构造方法不能被继承</code></pre><ol start="2"><li>构造代码块和构造方法的区别</li></ol><ul><li>构造代码块：是给所有的对象进行初始化 ，只要对象一建立就会调用这个代码块。 </li><li>构造方法：是给与之对应的对象进行初始化。</li></ul><h4 id="方法重载（Overload）"><a href="#方法重载（Overload）" class="headerlink" title="方法重载（Overload）"></a>方法重载（Overload）</h4><p>定义：在一个类中，方法名称一样，方法参数不一样（参数类型，参数个数，参数类型的顺序）</p><p>注意：</p><ol><li><p>在同一个类里，用同一个方法名</p></li><li><p>不同：参数列表不同（类型，个数，顺序不同）</p></li><li><p>与返回值类型，访问修饰符无关</p></li></ol><h4 id="方法重写-（Override）"><a href="#方法重写-（Override）" class="headerlink" title="方法重写 （Override）"></a>方法重写 （Override）</h4><p>定义：在子类中可以根据需要对从父类中继承来的方法进行重写。（访问修饰符 、返回值、方法名(参数列表) throws 异常 {方法体}） </p><p>注意：</p><ol><li>在不同的类（子父类）里，用同一个方法名</li><li>重写方法必须和被重写方法具有相同方法名称、参数列表和返回类型。</li><li>子类重写的返回值，<strong>不能大于</strong>父类被重写的返回值类型<ul><li>如果父类返回值类型为void， 则子类必须为void</li><li>如果父类返回值类型为A，则子类必须返回为A或A的间接或直接子类</li></ul></li><li>子类重写的访问修饰符（权限），不能小于父类被重写的方法访问权限<ul><li>特殊情况：子类不能重写父类中声明为private权限的方法</li></ul></li><li>子类方法抛出的异常不能大于父类被重写方法的异常</li></ol><h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><p><strong>1. this</strong>：代表对象。就是所在函数所属对象的引用。哪个对象调用了this所在的函数，this就代表哪个对象。</p><p><strong>2. 如何使用</strong></p><p>this.xx; （调用的是成员属性和成员方法）//普通方法中，this总是指向调用该方法的对象。</p><p>this(...); （调用本类对应参数的构造函数）//构造方法中，this总是指向正要初始化的对象。</p><p>注意：</p><p>（1）this调用构造函数，必须定义在构造函数的第一行。否则编译失败。</p><p>（2）this不能用于static修饰的方法。</p><h4 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h4><p>用来在子类中调用父类的属性和方法，可以修饰属性，方法、构造器</p><p><strong>super</strong>：代表子类所属父类中的内存空间引用。</p><p><strong>super()：</strong>表示父类的构造方法，并会调用于参数相对应的构造方法。而super()是在调用父类中空参数的构造方法。</p><h4 id="abstract关键字"><a href="#abstract关键字" class="headerlink" title="abstract关键字"></a>abstract关键字</h4><p>abstract可以修饰成员方法和类。<br>abstract不能和final同时使用。<br>abstract不能修饰变量和构造器；<br>abstract不能修饰类方法，即不能和static放在一起。<br>abstract不能和private同时修饰。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">抽象方法：</span><br><span class="line">[修饰符] <span class="keyword">abstract</span> 方法名（...）;</span><br><span class="line"><span class="comment">//抽象方法无方法体</span></span><br><span class="line"><span class="comment">//仅存在于抽象类</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">抽象类：</span><br><span class="line">[修饰符] <span class="keyword">abstract</span> 类名&#123;</span><br><span class="line"><span class="comment">//该类只能被继承，不能实例化【抽象类的构造器不能创建该类实例，】</span></span><br><span class="line"><span class="comment">//抽象类可以包含成员变量，方法（普通方法和抽象方法都可以），构造器，初始化块，内部类（接口、枚举）。</span></span><br><span class="line"><span class="comment">//抽象类不一定要有抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h4><p>static表示静态内容</p><p>static可以修饰：</p><ul><li>属性</li><li>方法</li><li>静态块</li></ul><p>使用static修饰的内容，就可以和类相关联，类存在，static修饰的就存在</p><p>我们可以使用类名的方式去访问：</p><ul><li>类名.属性名</li><li>类名.方法名称</li></ul><p>实例对象能够访问实例属性和方法，静态属性和方法</p><p>使用场景：</p><p>当想让所有的实例对象访问同一个资源时，就可以修饰为静态</p><h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ol><li><p>定义：抽象方法和常量值的集合</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">interface</span> 接口名称 </span>&#123;</span><br><span class="line"></span><br><span class="line">​    常量；</span><br><span class="line"></span><br><span class="line">​    方法；</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">接口中定义的属性，默认为：<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span></span><br><span class="line"></span><br><span class="line">接口中定义的方法：默认为: <span class="keyword">public</span> <span class="keyword">abstract</span> </span><br><span class="line"></span><br><span class="line">接口中没有构造器！</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li>作用：</li></ol><p>修饰符 class 类名 extends 父类 implements 接口1， 接口2 ,...</p><ul><li>接口的主要作用就是被实现类实现，一个类可以实现多个接口</li><li>接口也可以继承其他接口</li><li>实现类必须实现接口中的所有方法，否则仍为抽象类</li><li>接口和实现类直接存在多态性</li></ul><ol start="3"><li><p>jdk1.8中的接口</p><ul><li>jdk1.8中接口添加了静态方法和默认方法</li><li>接口中定义的静态方法只能被接口调用</li><li>接口的实现类对象可以调用默认方法</li><li>如果实现类中的方法重写了接口中的默认方法，则实现类调用重写方法</li><li>如果子类（实现类）所继承的父类和接口中的默认方法重名，并且子类没有重写，在调用是则使用类优先原则，默认调用的是父类的方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="comment">// 抽象方法，静态属性</span></span><br><span class="line"><span class="comment">// 1.8之后 接口可以添加 静态方法，默认方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"A method1 ---- "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"A method2 ---- "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"A method3 ---- "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>常见的接口用法</p><p>单方法接口(函数式接口)：Lambda表达式、@FunctionalInterface</p><p>标识性接口</p><p>普通接口</p><p>常量接口（接口最不正确的用法）</p></li></ol><h3 id="Java面向对象语言的三大特点"><a href="#Java面向对象语言的三大特点" class="headerlink" title="Java面向对象语言的三大特点"></a>Java面向对象语言的三大特点</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ol><li><p>说明</p><ol><li>继承是通过关键字extends（扩展）实现</li><li>通过继承子类中无需再声明父类中已存在的属性和方法，提高了代码的复用性</li><li>子类和父类的关系不同于子集和集合的关系，子类的功能可以更丰富，子类可以扩展父类没有的功能</li><li>A继承B则B就获取到A中所有的属性和方法，包括私有的，只是因为封装的问题子类中不能直接访问，可以间接方法</li></ol></li><li><p>java中继承的一些规定：</p></li></ol><ol><li><p>一个类可以被多个类继承</p></li><li><p>Java中继承为单继承性，只能有一个父类，子类下可以再有子类，所以就有了间接继承和直接继承关系</p></li><li><p>子类继承了父类后，就可以获取到直接父类和间接父类的所有属性和方法</p><p>特殊说明：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 如果我们没有声明任何父类，则这个类默认继承java.lang.Object</span><br><span class="line">2. 所有的类都间接或直接继承java.lang.Object, 所有的都会有Object的属性和方法</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>注意</li></ol><ul><li><p>在创建子类对象之前系统会默认创建父类对象</p></li><li><p>父类中私有属性是能够被继承，只是访问权限问题不能直接访问</p></li><li><p>如果子类想用父类的属性和方法，则使用super关键字</p></li><li><p>super可以使用构造器、属性、方法三种场合</p></li><li><p>子类继承父类，可以得到父类的全部属性和方法（除了父类的构造方法）。</p></li><li><p>Java中只有单继承，没有多继承。多继承会引起混乱，使得继承链过于复杂，系统难于维护。</p></li><li><p>Java中的多继承，可以通过接口来实现。</p></li></ul><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>​           隐藏一切可隐藏的实现细节提供简单的编程接口</p><p>​           私有属性，公有方法。好处：将变化隔离；</p><p>​           便于使用；提高重用性，安全性。</p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>​             方法重写：子类对父类的方法给出自己的实现版本。</p><p>​             对象造型：用父类型的引用去引用子类对象。 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(num);</span><br><span class="line">System.out.println(<span class="string">"showFu"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(num);</span><br><span class="line">System.out.println(<span class="string">"showZi"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Fu m = <span class="keyword">new</span> Fu();</span><br><span class="line">Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">Zi z = <span class="keyword">new</span> Zi();</span><br><span class="line"></span><br><span class="line">System.out.println(m.num);</span><br><span class="line">System.out.println(f.num);</span><br><span class="line">System.out.println(z.num);</span><br><span class="line"></span><br><span class="line">m.show();</span><br><span class="line">f.show();</span><br><span class="line">z.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">showFu</span><br><span class="line"><span class="number">5</span></span><br><span class="line">showZi</span><br><span class="line"><span class="number">5</span></span><br><span class="line">showZi</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;面向对象（Oriented-Object）&quot;&gt;&lt;a href=&quot;#面向对象（Oriented-Object）&quot; class=&quot;headerlink&quot; title=&quot;面向对象（Oriented Object）&quot;&gt;&lt;/a&gt;面向对象（Oriented Object）&lt;/
      
    
    </summary>
    
      <category term="javase" scheme="https://theme-next.org/categories/javase/"/>
    
    
      <category term="javase" scheme="https://theme-next.org/tags/javase/"/>
    
  </entry>
  
  <entry>
    <title>java02基础</title>
    <link href="https://theme-next.org/java02%E5%9F%BA%E7%A1%80/"/>
    <id>https://theme-next.org/java02基础/</id>
    <published>2019-08-09T17:01:02.000Z</published>
    <updated>2019-08-10T09:26:00.728Z</updated>
    
    <content type="html"><![CDATA[<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li><p>定义：方法就是一段用来完成特定功能的代码片段，类似于其它语言的函数。方法用于定义该类或该类的实例的行为特征和功能实现。 方法是类和对象行为特征的抽象。方法很类似于面向过程中的函数。面向过程中，函数是最基本单位，整个程序由一个个函数调用组成。面向对象中，整个程序的基本单位是类，方法是从属于类和对象的。</p><p>对象名.方法名(实参列表)<br>方法的详细说明</p><ol><li>形式参数：在方法声明时用于接收外界传入的数据。<br>实参：调用方法时实际传给方法的数据。</li><li>返回值：方法在执行完毕后返还给调用它的环境的数据。</li><li>返回值类型：事先约定的返回值的数据类型，如无返回值，必须显示指定为为void。</li></ol></li></ol><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ol><li><p>声明一个数组：</p><p>int a[];//指定数据类型</p><p>int []a;</p><p>int a[]=new int[4]//声明的同时分配空间</p><p>int a[]=new int[]{1,6,4,10}//声明的同时分配空间并赋值</p><p>int a[]={1,6,4,10}//声明的同时分配空间并赋值</p></li><li><p>二维数组</p><ul><li><p>声明</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a [][]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#125;</span><br><span class="line">a.length=<span class="number">3</span></span><br><span class="line"> a[<span class="number">0</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">a[<span class="number">0</span>].length=<span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line">- 输出：</span><br><span class="line">   </span><br><span class="line">     ```java </span><br><span class="line">   int a[][]=new int [3] [];</span><br><span class="line">     a[0]=new int[3];</span><br><span class="line">  a[1]=new int[4];</span><br><span class="line">     a[2]=new int[2];</span><br><span class="line">     以上都属于开辟空间</span><br><span class="line">   赋值: a[0] [0]=1;</span><br></pre></td></tr></table></figure><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二进制转十进制</span><br><span class="line">Integer.parseInt(&quot;0110&quot;, 2);</span><br><span class="line"></span><br><span class="line">八进制转十进制</span><br><span class="line">Integer.parseInt(&quot;17&quot;, 8);</span><br><span class="line"></span><br><span class="line">十六进制转十进制</span><br><span class="line">Integer.parseInt(&quot;17&quot;, 16);</span><br><span class="line"></span><br><span class="line">十进制转成二进制</span><br><span class="line">Integer.toBinaryString(int i);</span><br><span class="line"></span><br><span class="line">十进制转成八进制</span><br><span class="line">Integer.toOctalString(int i);</span><br><span class="line"></span><br><span class="line">十进制转成十六进制</span><br><span class="line">Integer.toHexString(int i);</span><br></pre></td></tr></table></figure><h3 id="获取随机数"><a href="#获取随机数" class="headerlink" title="获取随机数"></a>获取随机数</h3><ol><li>方法一<br>(数据类型)(最小值+Math.random()<em>(最大值-最小值+1))<br>例:<br>(int)(1+Math.random()</em>(10-1+1))<br>从1到10的int型随数</li><li>方法二<br>获得随机数<br>for (int i=0;i&lt;30;i++)<br>{System.out.println((int)(1+Math.random()<em>10));}<br>(int)(1+Math.random()</em>10)<br>通过java.Math包的random方法得到1-10的int随机数<br>公式是:最小值---最大值（整数）的随机数<br>（类型）最小值+Math.random()*最大值</li><li>方法三<br>Random ra =new Random();<br>for (int i=0;i&lt;30;i++)<br>{System.out.println(ra.nextInt(10)+1);}<br>通过java.util包中的Random类的nextInt方法来得到1-10的int随机数</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/a&gt;方法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;定义：方法就是一段用来完成特定功能的代码片段，类似于其它语言的函数。方法用于定义该类或该类的实例的行为特征和功能实现。 方
      
    
    </summary>
    
      <category term="javase" scheme="https://theme-next.org/categories/javase/"/>
    
    
      <category term="javase" scheme="https://theme-next.org/tags/javase/"/>
    
  </entry>
  
  <entry>
    <title>java01基础</title>
    <link href="https://theme-next.org/java01%E5%9F%BA%E7%A1%80/"/>
    <id>https://theme-next.org/java01基础/</id>
    <published>2019-08-09T17:01:01.000Z</published>
    <updated>2019-08-10T09:25:55.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java简介"><a href="#java简介" class="headerlink" title="java简介"></a>java简介</h2><ul><li><p>界面：HTML CSS JAVASCRIPT JQUERY BOOTSTRAP VUE</p></li><li><p>服务器端技术：JAVA JAVAWEB 数据库（mysql oracle） </p></li><li><p>JAVA:在大家要开发的项目中是一种服务器端技术，完成业务逻辑的处理，比如验证用户名密码是否正确。</p></li><li><p>B/S :浏览器/服务器,一种项目结构</p></li><li><p>JAVA之父 JAMES GOSLING</p></li><li><p>HOTJAVA</p></li><li><p>根据开发项目类型JAVA 分为三种类型：</p><p>JAVASE :标准版 桌面应用程序<br>JAVAEE :企业版 开发B/S结构的项目<br>JAVAME ：小型版 嵌入式 </p></li></ul><h2 id="一般的高级语言的运行过程"><a href="#一般的高级语言的运行过程" class="headerlink" title="一般的高级语言的运行过程"></a>一般的高级语言的运行过程</h2><ul><li>.c /.cpp 源代码————&gt;编译----&gt;.exe可执行程序（针对特定操作系统）</li><li>.java-----&gt;编译-----&gt;.class(字节码文件，在操作系统不能直接运行，可以跨平台)------&gt;解释（不同平台有不同的解释器JVM Java虚拟机）----&gt;看到程序的运行结果</li></ul><h2 id="JVM：JAVA虚拟机"><a href="#JVM：JAVA虚拟机" class="headerlink" title="JVM：JAVA虚拟机"></a>JVM：JAVA虚拟机</h2><ul><li>解释字节码程序</li><li>管理Java程序在运行过程所占用的内存空间</li><li>JRE：Java运行环境</li><li>JRE（JVM是其一部分）</li></ul><h2 id="JDK：JAVA开发工具包"><a href="#JDK：JAVA开发工具包" class="headerlink" title="JDK：JAVA开发工具包"></a>JDK：JAVA开发工具包</h2><ol><li>bin目录：存放可执行文件；</li><li>ib目录：存放Java的类库文件；</li><li>include目录：存放用于本地方法的文件；</li><li>demo目录：存放演示程序；</li><li>jre目录：存放Java运行环境文件；</li></ol><h2 id="学会使用Java-API文档"><a href="#学会使用Java-API文档" class="headerlink" title="学会使用Java API文档"></a>学会使用Java API文档</h2><ul><li>Java中已经定义好的类、接口数不胜数，不可能完完全全把这些类及其这些类的方法记住。但API文档能够帮助解决这样的问题。在学习Java的过程中和别人交流是很重要的，有助于提高自己的技术知识。</li><li>Java API文档是一种非常有用的文档，描述许多Java的内置功能，其中包含类、包、接口等帮助。</li></ul><h2 id="Java数据结构"><a href="#Java数据结构" class="headerlink" title="Java数据结构"></a>Java数据结构</h2><ul><li><p>标识符命名规则：</p><p>1.类名称（首字母大写）<br>2.方法名称<br>3.变量名称（一般首字母小写）字母、_、$ 双单词采用驼峰法</p></li></ul><h2 id="八种基本数据类型"><a href="#八种基本数据类型" class="headerlink" title="八种基本数据类型"></a>八种基本数据类型</h2><ul><li><p>整数型：<br>byte（1字节）-128〜127</p><p>short（2）   -2^15〜2^15-1 -32768〜32767</p><p>int（4）      21 4748 3647//java中任何整数默认int型</p><p>long（8字节） //d=214748xxxl 超过int型最大值要加l</p></li><li><p>浮点型：<br>float e=3.14f （4字节）  //浮点数不能做精确运算</p><p>double f=3.14 （8字节）</p></li><li><p>字符型：<br>char j=&#39;中&#39;; （2字节）0〜65536//单引号只能且放一个字符（没有符号位）可以表示一个汉字</p></li><li><p>波尔型：<br>Boolean（1字节） //变量能表示ture false</p></li></ul><p><strong>字符串</strong>数据类型：<br>    不属于8种基本类型例如 String s=&quot;abc&quot; abc是字符串 s.length=3</p><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><ul><li><p>强制类型转换<br>大数据向小数据放  // short d=128;  错误方式<br>小数向整数放          //byte  c=(byte)d;正确方式<br>转换过程中都可能发生精度损失，因为转换过程中采用的原理是高位截断，   剩下的位数可能表示的数字跟原来就不一致了。</p><pre><code>short s=1;s+=1; //等价于 s=(short)(s+1) 需要强制转换</code></pre></li><li><p>精度损失：<br>以下情况可能会发生精度损失，因为等号右边按照Int型运算，不够存放算术运算结果<br>//        long a=24<em>24</em>60<em>1000</em>1000;<br>//        long a=24<em>24</em>60<em>1000</em>1000l;</p></li><li><p>自动提升转换</p><p>1.可以将一个char型变量赋值给int型或者long型，不能byte和short<br>2.不能将一个整型的变量赋值给char<br>3.可以将一个整型的字面量赋值给char (0-65535)<br>a+1&lt;a 在高位截短的情况下可能发生<br>4.常量 只能赋一次值<br> 例：final int a=10;</p></li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ol><li>算数运算符<br>%取余<br>++自加 // <strong>a++先参与后自加 ++a先自加后参与</strong><br>--自减</li><li>关系运算符<br>&lt; &gt; &lt;= &gt;= == !=</li><li>逻辑运算符<br>&amp;&amp;  与  (&quot;A&amp;&amp;B&quot; A部分为false则B部分不执行输出false)<br>||  或(&quot;A||B&quot; A部分为ture则B部分不执行输出ture)<br>!（op1） 非（一元运算符 包括++ --）<br>&amp; 、|(也是逻辑与和逻辑或，不存在短路效应)</li><li>位运算符<br>位运算符用来对二进制数进行测试、置位或移位等操作，操作数只能为整型或字符型数据<br>〜a //按位取反<br>a&amp;b<br>a|b<br>a^b<br>a&gt;&gt;2   A左移2位<br>A&lt;&lt;2   A右移2位<br>A &gt;&gt;&gt;3 A无符号右移3位<br>（注意 赋值运算符 =和条件运算符max=a&gt;b?a:b;）<br>注意：0b10 表示十进制2<br>   010 表示十进制8<br>   0x10 表示十进制16</li></ol><h2 id="Java控制语句"><a href="#Java控制语句" class="headerlink" title="Java控制语句"></a>Java控制语句</h2><ul><li><p>多重if 结构</p><p>判断某个数是否落在某个区间</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in); <span class="comment">// 从控制台输入</span></span><br><span class="line">    <span class="keyword">int</span> jf = sc.nextInt();</span><br><span class="line">    <span class="keyword">if</span> (jf &lt; <span class="number">2000</span>)</span><br><span class="line">        System.out.println(<span class="string">"0.9折"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jf &gt;= <span class="number">2000</span> &amp;&amp; jf &lt; <span class="number">4000</span>)</span><br><span class="line">        System.out.println(<span class="string">"0.8折"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jf &gt;= <span class="number">4000</span> &amp;&amp; jf &lt; <span class="number">8000</span>)</span><br><span class="line">        System.out.println(<span class="string">"0.7折"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        System.out.println(<span class="string">"0.6折"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Switch</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Switch（表达式）&#123;</span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">     语句<span class="comment">//</span></span><br><span class="line">          <span class="keyword">break</span>；</span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">    语句<span class="comment">//</span></span><br><span class="line">     <span class="keyword">break</span>；</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">   语句<span class="comment">//</span></span><br></pre></td></tr></table></figure><ul><li><p>while</p><p>while(布尔ture/false表达式) //循环条件，只要表达式为ture就一直执行下去</p><p>   while(answer.equals(&quot;y&quot;)){</p><pre><code>  syso(&quot;早上。。中午。。晚上。。&quot;)；  syso(&quot;表演的怎么样？请回答（y/n）:&quot;);  answer=input.next(); //循环输入回答}</code></pre><p>   syso(&quot;圆满完成！&quot;)//只有当回答是y 时才跳出循环</p></li><li><p>循环结构do while</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">循环操作                        <span class="comment">//至少执行一次操作</span></span><br><span class="line">&#125;<span class="keyword">while</span>(布尔ture/<span class="keyword">false</span>表达式)；  <span class="comment">//循环条件，只要表达式为ture就一直执行</span></span><br></pre></td></tr></table></figure><ul><li>for循环</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   初始化；布尔表达式；更新</span><br><span class="line"> <span class="keyword">for</span>  (<span class="keyword">int</span>=<span class="number">0</span>;   i&lt;<span class="number">100</span>;   i++)&#123;</span><br><span class="line">    sysyo(<span class="string">"我最棒"</span>)；<span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>（；；）&#123;</span><br><span class="line"> <span class="keyword">if</span>（布尔表达式）&#123;</span><br><span class="line">  <span class="keyword">break</span>/<span class="keyword">continue</span>；</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>最先执行初始化。可以声明一种类型，但可以初始化一个或多个循环控制变量，也可以是空语句。</li><li>然后检测布尔表达式。ture循环体被执行，false循环体终止，开始执行循环体后面的语句。</li><li>执行一次循环后，更新循环控制变量。</li><li>再次检测布尔表达式。执行上面的过程。</li></ol><ul><li>嵌套for循环</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lest2</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">   System.out.println(<span class="string">"请输入行数n"</span>);</span><br><span class="line">   <span class="keyword">int</span> n=sc.nextInt();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n-i-<span class="number">1</span>; j++) &#123;</span><br><span class="line">    System.out.print(<span class="string">" "</span>);  <span class="comment">// 不加ln默认不换行！！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>*i+<span class="number">1</span>;j++) &#123;</span><br><span class="line">System.out.print(<span class="string">"*"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">""</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java简介&quot;&gt;&lt;a href=&quot;#java简介&quot; class=&quot;headerlink&quot; title=&quot;java简介&quot;&gt;&lt;/a&gt;java简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;界面：HTML CSS JAVASCRIPT JQUERY BOOTSTRAP VUE&lt;/
      
    
    </summary>
    
      <category term="javase" scheme="https://theme-next.org/categories/javase/"/>
    
    
      <category term="javase" scheme="https://theme-next.org/tags/javase/"/>
    
  </entry>
  
  <entry>
    <title>博客美化</title>
    <link href="https://theme-next.org/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"/>
    <id>https://theme-next.org/博客美化/</id>
    <published>2019-07-30T15:59:33.000Z</published>
    <updated>2019-08-01T15:51:47.099Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p><strong>NexT主题美化</strong></p></blockquote>            <h2 id="☑️-NexT-v7-2-0-自带功能集合"><a href="#☑️-NexT-v7-2-0-自带功能集合" class="headerlink" title="☑️  NexT.v7.2.0 自带功能集合"></a>☑️  NexT.v7.2.0 自带功能集合</h2><p> 1️⃣ <a href="https://github.com/theme-next/theme-next.org" target="_blank" rel="noopener">NexT网站配置源码</a> ：主要看站点配置文件<code>_config.yml</code></p><p> 2️⃣ <a href="https://github.com/theme-next/theme-next.org" target="_blank" rel="noopener">NexT主题配置源码</a>：主要看主题配置文件<code>_config.yml</code></p><p> 3️⃣<a href="https://theme-next.org/docs/">Next主题官方博客</a>:  绝大部分配置这里都可以找到</p><p> ❗️ 本博客具体实现功能如下：</p><ol><li><p>设置站点名称/昵称/简介</p></li><li><p>设置菜单<code>menu</code></p></li><li><p>设置头像<code>avatar</code></p></li><li><p>博客评论功能<code>valine</code>,需注册<a href="https://leancloud.cn" target="_blank" rel="noopener">leancloud</a></p></li><li><p>设置社交链接&amp;图标<code>social</code>&amp; <code>social_icons</code> </p><p>图标大全：<a href="https://link.zhihu.com/?target=http%3A//fontawesome.dashgame.com/" target="_blank" rel="noopener">Font Awesome</a></p></li><li><p>设置网站图标<code>favicon</code>,把头像设置成.png文件放到image文件夹下，在代码里替换掉image/后面的XXXX.png；logo.svg也可以用png替换（本人测试成功）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">favicon：</span><br><span class="line">  small：/ images / favicon-<span class="number">16</span>x16-next.png</span><br><span class="line">  medium：/images/favicon-<span class="number">32</span>x32-next.png</span><br><span class="line">  apple_touch_icon：/images/apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab：/images/logo.svg</span><br><span class="line">  ＃ ANDROID_MANIFEST：/images/manifest.json</span><br><span class="line">  ＃ ms_browserconfig：/images/browserconfig.xml</span><br></pre></td></tr></table></figure></li><li><p>增加RSS订阅功能，详见3️⃣</p></li><li><p>减少两侧留白，详见3️⃣</p></li><li><p>阅读百分比，详见3️⃣</p></li><li><p>访客数和访问量统计busuanzi (不准确，我没弄)</p></li><li><p>底部是否显示hexo /NexT 版本号 和 “驱动支持”，详见3️⃣</p></li><li><p>Copyright 后面的❤️修改 增加动态设置和颜色设置，详见3️⃣</p></li><li><p>显示右上GitHub标识<code>github_banner</code></p></li><li><p>代码页面增加copy按钮，详见3️⃣</p></li><li><p>在标签页显示标签云 <code>tagcloud</code></p></li><li><p><strong>本地搜索</strong>  ，详见3️⃣</p></li><li><p>图床<a href="https://zhuanlan.zhihu.com/p/35270383" target="_blank" rel="noopener">盘点一下免费好用的图床</a>  （我还没用）</p></li><li><p>友情链接</p><p>打开 <code>themes/next/_config.yml</code> 文件,搜索关键字 <code>Blog rolls</code></p></li><li><p>博文置顶<a href="http://wangwlj.com/2018/01/09/blog_pin_post/" target="_blank" rel="noopener">Hexo博客彻底解决置顶问题</a> （我还没做）</p></li></ol><h2 id="❌-删除部分"><a href="#❌-删除部分" class="headerlink" title="❌ 删除部分"></a>❌ 删除部分</h2><ol><li><p>删除在线聊天功能daoVoice</p></li><li><p>删除文章阴影和动态背景canvas</p><p>理由：太占资源了而且并不实用(包括看板娘/鼠标点击效果/爆炸效果/内插音乐播放器等)不建议设置。</p></li></ol><h2 id="🆕-新功能"><a href="#🆕-新功能" class="headerlink" title="🆕 新功能"></a>🆕 新功能</h2><p>待发掘...</p><hr><p>本文为原创内容，转载请注明出处。🙏</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;&lt;strong&gt;NexT主题美化&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;            

&lt;h2 id=&quot;☑️-NexT-v7-2-0-自带功能集合&quot;&gt;&lt;a href=&quot;#☑
      
    
    </summary>
    
      <category term="技术分享" scheme="https://theme-next.org/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="NexT" scheme="https://theme-next.org/tags/NexT/"/>
    
      <category term="Blog" scheme="https://theme-next.org/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>《白银时代》读后感</title>
    <link href="https://theme-next.org/%E6%96%87%E5%AD%A61/"/>
    <id>https://theme-next.org/文学1/</id>
    <published>2019-07-30T15:59:30.000Z</published>
    <updated>2019-07-31T16:28:08.366Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p> 人的一切痛苦，本质上都是对自己无能的愤怒。</p><p><strong>王小波</strong></p></blockquote><p>当代流传着这么一句话：<strong>“男生不可不读王小波，女生不可不读周国平。”</strong></p><p>王小波的作品以其文采和哲思赢得了无数读者的青睐，无论花季还是老年，都能从他的文字中收获智慧和超然。</p><p>王小波，中国当代学者、作家。代表作品有《黄金时代》《白银时代》《青铜时代》《黑铁时代》等。他仅创作的一部电影剧本《东宫西宫》，就获得了阿根廷国际电影节最佳编剧奖，并且入围1997年戛纳国际电影节。</p><p>在王小波的众多作品中，最吸引我的，就是他的《白银时代》。</p><p>翻开王小波《白银时代》的第一页，大学二年级热力学课老师正在课室上讲道：“将来的世界是银子的”。</p><p>自此，王小波便以一个独特的视角，在白银时代这个虚拟时空里作了一个关于未来世界的黑色预言。</p><p><strong>希腊神话里说，白银时代的人蒙神恩宠，终身不会衰老，也不会为生计所迫，他们没有痛苦没有忧虑，一直到死，相貌和心灵都像儿童。死掉以后，他们的幽灵还会在尘世上游荡。</strong></p><p>然而他所表现的白银世界却与神话中的乌托邦理想国大相径庭甚至是截然相反。</p><p>这是个在两个时空下同时进行的故事，一个是大二的学生时代，一个是2020年步入写作公司的职业时代。在作者眼里，它们都是白银时代，在同质化基础上构建起来的一个压抑自我和人性的强权社会。</p><p>这是个师生恋的故事。主人公被刻画成了一个受虐者，被倒挂，被钉十字架，如耶稣受难日那天般被折磨。我们在阅读之余，不禁惊叹王小波的世界，那深不见底的内涵。</p><p>王小波变幻莫测的文风，体现了现实对人的折磨，但不苦闷，也不压抑，自然流畅的文字为人们解读了现实中不可言喻的道理。</p><p>在故事中，有一句话不断被重复——“世界是银色的”。我们可以想象一下，整个世界都是灰蒙蒙的银色，看不到未来，主人公在银色的世界里被镀成了一个银色的雕塑，压抑、沉闷。</p><p>他的白银时代一些人说看不懂，一会儿是“我”坐在写字楼里写文章，一会儿又回到了师生恋，王小波的文章总是在这虚虚实实真真假假中，把读者绕进去。</p><hr><p>本文内容为转载，感谢阅读。🙏</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt; 人的一切痛苦，本质上都是对自己无能的愤怒。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;王小波&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当代流传着这么一句话：&lt;strong&gt;“男生不可不读
      
    
    </summary>
    
      <category term="文学分享" scheme="https://theme-next.org/categories/%E6%96%87%E5%AD%A6%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>处女篇</title>
    <link href="https://theme-next.org/%E5%A4%84%E5%A5%B3%E7%AF%87/"/>
    <id>https://theme-next.org/处女篇/</id>
    <published>2019-07-27T19:00:19.000Z</published>
    <updated>2019-07-31T18:09:01.077Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>养成写博客的习惯</p><p> 这将使你的人生变的非常有意义！</p></blockquote><h2 id="❓-为什么创建个人博客"><a href="#❓-为什么创建个人博客" class="headerlink" title="❓ 为什么创建个人博客"></a>❓ 为什么创建个人博客</h2><p>Record：</p><ul><li>记录下自己的学习过程及心得</li><li>记录让人自律，自律让人自信</li><li>记录是对自己努力的一种认可</li></ul><p>Share：</p><ul><li>一名优秀的程序员必将具备开源精神</li><li>个人的工作与学习过程遇到过很多问题也是通过search blogs 解决的</li><li>个人经历与经验分享给朋友未尝不是一件美事</li></ul><p>Exchange：</p><ul><li>My blogs should 具有讨论价值</li><li>文章应该具有思辨性</li><li>认识更多的小伙伴</li><li>交流中成长</li></ul><p>Freedom：</p><ul><li>远离鱼龙混杂的广告</li><li>浩瀚重复的blog资源</li><li>静下心回归写作本身</li><li>选择性汲取精华blog</li></ul><h2 id="🛠-怎样搭建个人博客"><a href="#🛠-怎样搭建个人博客" class="headerlink" title="🛠 怎样搭建个人博客"></a>🛠 怎样搭建个人博客</h2><ul><li>首先你需要一个GitHub账号</li><li>你需要在电脑安装git并且你需要熟悉一些DOS命令</li><li>在DOS窗口安装Hexo并使用NexT主题</li><li><a href="https://smartbeng.github.io/2017/03/26/blogFinish/" target="_blank" rel="noopener">最适合新手的 GitHub + Hexo 「大话」博客搭建教程</a></li><li><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo 官网</a>：https://hexo.io/zh-cn/ 部署博客</li><li><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT 主题官网</a>：http://theme-next.iissnan.com/ 美化博客</li></ul><h2 id="✍🏻-如何经营个人博客"><a href="#✍🏻-如何经营个人博客" class="headerlink" title="✍🏻 如何经营个人博客"></a>✍🏻 如何经营个人博客</h2><ul><li>文章质量决定文章高度</li><li>简洁轻快的博客UI</li><li>优秀的用户体验</li><li>版权意识与推广意识</li></ul><hr><p>本文为原创内容，转载请注明出处，感谢您的阅读🙏</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;养成写博客的习惯&lt;/p&gt;
&lt;p&gt; 这将使你的人生变的非常有意义！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;❓-为什么创建个人博客&quot;&gt;&lt;a href=&quot;#❓-为什么创建个人博客&quot; cla
      
    
    </summary>
    
      <category term="人生感悟" scheme="https://theme-next.org/categories/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="life" scheme="https://theme-next.org/tags/life/"/>
    
      <category term="begin" scheme="https://theme-next.org/tags/begin/"/>
    
  </entry>
  
</feed>
